{"meta":{"title":"PanLiang's blog","subtitle":"","description":"","author":"Pan Liang","url":"https://panlianghnu.github.io","root":"/"},"pages":[{"title":"categories","date":"2020-12-14T06:12:43.000Z","updated":"2020-12-14T06:14:16.000Z","comments":true,"path":"categories/index.html","permalink":"https://panlianghnu.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-12-14T06:10:00.000Z","updated":"2020-12-14T06:10:41.000Z","comments":false,"path":"tags/index.html","permalink":"https://panlianghnu.github.io/tags/index.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2021-02-25T04:07:28.731Z","updated":"2021-02-25T03:32:27.978Z","comments":false,"path":"/404.html","permalink":"https://panlianghnu.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2021-02-25T04:07:28.756Z","updated":"2021-02-25T03:32:27.978Z","comments":false,"path":"about/index.html","permalink":"https://panlianghnu.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"Repositories","date":"2021-02-25T03:52:51.285Z","updated":"2021-02-25T03:32:27.979Z","comments":false,"path":"repository/index.html","permalink":"https://panlianghnu.github.io/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"testBlog","slug":"testBlog","date":"2021-02-25T02:45:45.000Z","updated":"2021-02-25T02:46:50.250Z","comments":true,"path":"2021/02/25/testBlog/","link":"","permalink":"https://panlianghnu.github.io/2021/02/25/testBlog/","excerpt":"","text":"test","categories":[],"tags":[]},{"title":"简单树形P2P网络实现","slug":"简单树形P2P网络实现","date":"2021-02-19T04:36:20.000Z","updated":"2021-02-22T05:21:04.160Z","comments":true,"path":"2021/02/19/简单树形P2P网络实现/","link":"","permalink":"https://panlianghnu.github.io/2021/02/19/%E7%AE%80%E5%8D%95%E6%A0%91%E5%BD%A2P2P%E7%BD%91%E7%BB%9C%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"树形结构： 先写一个种子文件，种子文件里是一个根节点的URL（单点故障）后面可以改成多个节点们 新的客户端接入该 P2P 网络 先读取种子文件，找到根节点 根节点给客户端分配一个（多个）节点，并给其一个ID 客户端连接上这些节点 客户端监听 http、p2p 端口 自己设置，并告诉根节点 根节点维护全局节点的信息，普通节点维护相连的节点的信息 测试 还是一样的 访问 http/ping 每个节点会把 “I am alive” 发送给相邻节点 =》根节点会收到所有节点的消息","categories":[],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://panlianghnu.github.io/tags/nodejs/"},{"name":"P2P","slug":"P2P","permalink":"https://panlianghnu.github.io/tags/P2P/"}]},{"title":"基于WebSocket的聊天室","slug":"基于WebSocket的聊天室","date":"2021-02-04T01:57:56.000Z","updated":"2021-02-19T03:38:07.721Z","comments":true,"path":"2021/02/04/基于WebSocket的聊天室/","link":"","permalink":"https://panlianghnu.github.io/2021/02/04/%E5%9F%BA%E4%BA%8EWebSocket%E7%9A%84%E8%81%8A%E5%A4%A9%E5%AE%A4/","excerpt":"","text":"源码见：github 后端 使用 ‘express’ 封装 http 请求，监听7777端口，返回前端页面 12345var app = require(&#x27;express&#x27;)() // 封装 http app.get(&#x27;/&#x27;,(req, res) =&gt; &#123; res.sendFile(__dirname + &#x27;/chat.html&#x27;) // 返回页面&#125;)app.listen(7777,&#x27;localhost&#x27;) 使用 nodejs-websocket 工具包处理聊天，监听8888端口 123456789101112131415161718var ws = require(&#x27;nodejs-websocket&#x27;)var server = ws.createServer((socket) =&gt; &#123; // 处理聊天 var username = socket.path console.log(username + &#x27; 加入群聊&#x27;) clientList.push(socket) broadcast(username + &#x27; 加入群聊&#x27;) socket.on(&#x27;text&#x27;,(data) =&gt; &#123; console.log(username + &#x27;: &#x27;+data) broadcast(username + &#x27;: &#x27; + data) &#125;) socket.on(&#x27;close&#x27;,(err) =&gt; &#123; console.log(username + &#x27; 退出群聊&#x27;) deleteSocketFromList(socket) broadcast(username + &#x27; 退出群聊&#x27;) &#125;)&#125;).listen(8888) 客户端刚连接服务器时，服务器会用链表 clientList 保存这个 socket 连接，并进行广播 “xxx加入群聊”。 设置了两个事件 text 事件，客户端向服务器发送消息时触发 服务器向所有客户端广播该消息 close 事件，客户端失去连接时触发 服务器删除该 socket 对象，并广播给其他客户端 广播的实现 遍历 socket ，调用 send 发送消息 1234567function broadcast(data)&#123; for(var i=0;i&lt;clientList.length;i++)&#123; if(clientList[i] !== null)&#123; clientList[i].send(data) &#125; &#125;&#125; 前端 定义 url 和 ws 对象 12var url = &quot;ws://localhost:8888/&quot;;var ws = null; 加入群聊，即初始化 websocket 对象，并绑定事件 username 通过用户输入，调用 document.getElementById 得到内容 直接在连接时的 url 字符串后面拼接 username，后端识别 path 得到用户名 123456789101112131415161718192021222324function joinRoom() &#123; if (ws) &#123; alert(&quot;你已经在聊天室，不能再加入&quot;); return; &#125; var username = document.getElementById(&quot;user&quot;).value; ws = new WebSocket(url + username); //与服务端建立连接触发 ws.onopen = function () &#123; console.log(&quot;与服务器成功建立连接&quot;) &#125;; //服务端推送消息触发 ws.onmessage = function (ev) &#123; talking(ev.data); // 接收数据，刷新页面 &#125;; //发生错误触发 ws.onerror = function () &#123; console.log(&quot;连接错误&quot;) &#125;; //正常关闭触发 ws.onclose = function () &#123; console.log(&quot;连接关闭&quot;); &#125;;&#125; 发送数据 123456789function sendMsg() &#123; if(!ws)&#123; alert(&quot;你已掉线，请重新加入&quot;); return; &#125; //消息发送 ws.send(document.getElementById(&quot;sendMsg&quot;).value); document.getElementById(&quot;sendMsg&quot;).value = &quot;&quot;;&#125; 先判断是否已经初始化 websocket 对象 接收数据，刷新页面 1234function talking(content) &#123; document.getElementById(&quot;content&quot;).append(content + &quot;\\r\\n&quot;);&#125;content 是一个 &lt;textarea/&gt; 对象 GUI","categories":[],"tags":[{"name":"websocket","slug":"websocket","permalink":"https://panlianghnu.github.io/tags/websocket/"},{"name":"聊天室","slug":"聊天室","permalink":"https://panlianghnu.github.io/tags/%E8%81%8A%E5%A4%A9%E5%AE%A4/"}]},{"title":"ML学习笔记-1","slug":"ML学习笔记-1","date":"2021-01-03T08:45:14.000Z","updated":"2021-01-03T08:48:43.000Z","comments":true,"path":"2021/01/03/ML学习笔记-1/","link":"","permalink":"https://panlianghnu.github.io/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/","excerpt":"","text":"机器学习 机器学习就是让机器自动找函数 Regression：输出数值 Classification：二分类、多类分类 Generation：生成有复杂结构的东西（如翻译，画二次元头像） 如何告诉机器，想要什么样的函数 Supervised learning 有监督学习，对每个 input，给出一个标准 output，需要对资料做 label 机器就可以对生成的函数做一个评估，有一个 loss function，用来计算 function 的好坏 Reinforcement learning 强化学习，比如阿尔法狗，让机器和自己、别人下棋，然后赢了，机器会知道这样下比较好，哪几步比较好还不是很清楚 强化学习是智能体（Agent）以“试错”的方式进行学习，通过与环境进行交互获得的奖赏指导行为，目标是使智能体获得最大的奖赏，强化学习不同于连接主义学习中的监督学习，主要表现在强化信号上，强化学习中由环境提供的强化信号是对产生动作的好坏作一种评价(通常为标量信号)，而不是告诉强化学习系统RLS(reinforcement learning system)如何去产生正确的动作。由于外部环境提供的信息很少，RLS必须靠自身的经历进行学习。通过这种方式，RLS在行动-评价的环境中获得知识，改进行动方案以适应环境。 机器如何找到函数 1、给定函数范围 linear function network architecture RNN循环神经网络 CNN卷积神经网络 2、函数寻找方法 Gradient Descent 梯度下降 Anomaly detection 能不能知道 自己不知道 meta learning 让机器学习如何学习，让机器自己设计学习的方法 Regression 输出数值（Scalar） 比如无人车驾驶：input 一些sensor ，输出方向盘角度 比如推荐系统：input A和商品B，输出A购买B的可能性 比如宝可梦：输入某只宝可梦，输出他进化后的CP值 三个步骤 1、找到一个model（A set of functions）比如线性model cp_new = b + w*cp_old 2、定义 Loss function，输入一个 function，输出一个 function 评估结果 这里采用的平方 loss function ，用真实数据减去预测数值再取平方 3、找一个最好的 function 穷举所有的 w 和 b，求出最好的 w 和 b Gradient Descent，可以处理任何可以微分的 function 随机选取初始 w0，再初始w0这个位置，计算w参数对L的微分（切线斜率），若斜率为负，则右边 loss 较低，应该增加 w0，增加量为：微分值*(learning rate) 就这样不断地求 w，直到 w 到达 local optimal，但是会陷入局部最优（当然 linear set 没有局部最优） 如果有两个参数呢？ 其实算出来的就是等高线的法线方向 这种情况就会陷入局部最优，但 linear regression 没有 local optimal 求出来 b 和 w 之后，我们关心新数据和预测函数的误差，发现比较大 重新设计 model 二次式：y = b + w1Xcp + w2*(Xcp)^2 一样的用刚才的算法去求最好的 b、w1、w2 三次式：y = b + w1*Xcp + w2*(Xcp)^2 + w3*(Xcp)^3 四次式：。。。不断地拟合，loss function()的值不断变小，但是 test data 效果却更差，这波啊，这波是过拟合 如图，training data 效果特别好，但是显然不是一个合理的宝可梦CP预测的 function 越复杂的model、我们可以找到 training data 的loss function 最低的 function，但是在testing data 的结果是不一样的 testing 的结果反而变差了，拟合的并不是很好（Overfitting） overfitting model 并不是越复杂越好 当收集足够多的数据之后，发现并不是简单的和旧CP值有关 物种是有关键性影响的，重新设计 model ，将 物种（species）考虑进去 这也是一个线性拟合…为啥不分四个训练集呢。。感觉就像是把 Xcp这个 feature 分成四个 feature了，分别表示对四个种类的 cp 值 来个更复杂的 model 对 eevee 考虑的更加复杂一些，其实也不是很复杂，作业可能几百个参数。。。 然后算出来 loss 为1.4，testing data loss 102.3，显然 overfitting 了 如何避免 overfitting 回到 regularization ，redesigned loss function loss function 不应该只考虑误差平方和，还应该加上 wi (wi 为各级x的系数) 的平方和，为什么？ 因为当 wi 比较小，则求出来的 function 比较平滑，输出对输入更加不敏感 更倾向于平滑的 function，因为越平滑，收到 noise 的影响越小 不断的调节 λ ，求出结果， λ 越大则考虑平滑越多 发现越平滑，考虑的err越少，则 training data 的结果越糟糕，但是 testing data 效果反而可能好一些，所以需要调节 λ 来决定 function 的平滑程度，（调节平滑不需要考虑 b） 总结：宝可梦的当前CP和物种决定几乎进化后的CP值（可能还有其他因素） 梯度下降，过度拟合和考虑平滑 error 来自哪里 来自 bias 平均 来自 variance 方差 error 来自 bias，说明你没有瞄准好，导致估计值偏离真实值 error 来自 variance，说明你射的不够稳，还没有收敛/773.0 求各个模型的 f*（100组不同数据） ，发现简单的 model 是比较集中的，即 variance 比较小，不容易散开 model 比较复杂的话，function 散布就会很开，variance 比较开 为什么？ 因为 model 比较复杂，受到不同的 data 影响比较大 bias：large bias，如何评测 f* 和 f^ 的 bias 差多少？ 这里用红色表示各个 function 的结果，蓝色表示平均值，黑色表示正确答案， 可以看到，虽然这些 f* 不知道飘到哪里去了，但是平均起来看，f* 和 f^ 还是比较接近的，即 复杂的 model 的 bias 还是比较小的 所以，当你的 model 越来越复杂，bias 会越来越小，variance 会越来越大 如何分辨现在是 underfitting 还是 overfitting？ 当你的 traning data 结果比较差的时候，是 underfitting 当你的 training data 结果比较好但是 testing data 结果很差的时候，大概是 overfitting 怎么做？ error from bias：重新设计 model、或者用一个更加复杂的 model，找更多 data 也没用 error from variance： 找更多 data、或者 generate 一些假 data 哈哈哈 或者 regularization：再加一些参数，比如曲线平滑度 但是这样子得到的数据可能会伤害你的 bias bias偏移量越大，模型越垃圾。而高阶model往往会造成其bias偏移量较小（参考高数泰勒展开）。从而导致高阶model（或者说是复杂model）的模型更贴合于数据的真实分布。但是当我们用新的测试集在高阶model上进行预测时，由于高阶model的形态过分贴合训练集数据且高阶model群较为繁杂，其在新的测试集数据上的拟合优度一定不会很好。 model 选择 我们希望找一个 bias 和 variance 都比较小的 model should not do： 你的 testing set 只是一个验证 training set 的 set，真实的 testing set 往往都是没有的 所以应该是这样做：用training data 选择 function，用 traning + validation 验证 model，这样才能真实反映 testing 的 bias（也就是不要提前考虑 testing data 的bias） N 折交叉验证： 把 training data 分成 n 份，选一个作为 validation","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://panlianghnu.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"简易区块链C语言实现","slug":"简易区块链C语言实现","date":"2020-12-30T04:11:39.000Z","updated":"2020-12-30T04:15:27.000Z","comments":true,"path":"2020/12/30/简易区块链C语言实现/","link":"","permalink":"https://panlianghnu.github.io/2020/12/30/%E7%AE%80%E6%98%93%E5%8C%BA%E5%9D%97%E9%93%BEC%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"简易区块链C语言实现 在CSDN的第四个任务：实现一个最简单的区块链，不带区块链网络、时间戳、merkle tree等 虽然说技术上难度不大，但是想要实现它，还真是一个不小的工程。。。 除了 SHA256 的计算部分，其余的代码都是自己实现的，写的不好还望见谅 区块链数据结构： 如图所示，每个区块分为区块 head，和区块 body 区块头又分为 SHA_ALL、nonce、SHA_PREV、SHA_BLOCK SHA_BLOCK: 对区块的 body 部分进行一次 SHA256运算，保存在SHA_BLOCK SHA_PREV: 保存上一个区块整体(head+body)的 SHA256 值 nonce: 随机数，意义仅仅只是让区块头（不包含SHA_ALL的部分）+区块体一起进行SHA256运算，使得最终的结果刚好出现 n 个前导0，n 可以设置，代表出块的难度，模拟POW共识算法（比特币采用POW），我看了比特币源码，比特币源码的 nonce 是采用的 long long ，那我这里采用 unsigned long，之前龙哥和我说256位的nonce，我跑了跑发现没有必要，nonce跑到10万就需要我电脑好几秒了。。。unsigned long（8字节） 最大值有18446744073709551615，根本跑不完好吗。。。 当然比特币的 nonce 虽然只有8字节，但这里并不是说比特币的区块取值每次只需要计算2^64种情况，比特币实际挖坑时，最终的哈希值前导 0 特别长，只遍历一次 nonce 是几乎不可能的情况，矿机需要不断地改变区块体里面的 coinbase 里的无意义的值，然后不断地去遍历 nonce ，才能试探出前导0多于 n 个的情况，这将耗费巨大的算力，也是比特币POW共识策略的体现 SHA_ALL: 存放在区块头的最上面，SHA_ALL 保存整个区块（不包含头最上面的这256比特）的SHA256计算结果，必须有 n 个前导0。它的意义在于，只要你修改了这个区块的任意部分，你就需要重新计算 HASH_BLOCK、重新计算 NONCE ，使得最终的 SHA_ALL 算出来要出现 n 个前导0，当 n 比较大，区块链比较长时，想要修改某区块并使整个区块链仍合法的工作量不可估量，这是区块链“不可篡改”的重要因素之一 区块体就比较随意了，我这里只弄了一个字符串 这样就实现了一个最简单的区块链 具体代码实现如下： 123456789101112131415161718typedef union&#123; unsigned char byte[104]; struct&#123; unsigned char sha_all[32]; // 256 bit sha_all unsigned long nonce; // 64 bit nonce unsigned char sha_prev[32]; // 256 bit sha_prev unsigned char sha_block[32]; // 256 bit sha_block &#125;;&#125; block_chain_head;typedef struct&#123; char body[1000];&#125; block_chain_body;typedef struct&#123; block_chain_head head; block_chain_body body;&#125; block; 这里补充一下C语言共用体的知识： 我们知道结构体（Struct）是一种构造类型或复杂类型，它可以包含多个类型不同的成员。在C语言中，还有另外一种和结构体非常类似的语法，叫做共用体（Union），它的定义格式为： union 共用体名{ 成员列表 }; 共用体有时也被称为联合或者联合体，这也是 Union 这个单词的本意。 结构体和共用体的区别在于：结构体的各个成员会占用不同的内存，互相之间没有影响；而共用体的所有成员占用同一段内存，修改一个成员会影响其余所有成员。 结构体占用的内存大于等于所有成员占用的内存的总和（成员之间可能会存在缝隙），共用体占用的内存等于最长的成员占用的内存。共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来成员的值覆盖掉。 这里采用 Union + Struct 的数据结构，是为了录入数据+读取数据都比较方便直观。当我想要录入数据时，我只需要读字节流，将104个字节赋值给 byte 数组即可，当我想访问某些数据时，我又可以用结构体的方式直接访问成员变量，代码非常的简洁，可读性也高 题外话： 之前想着是用哈希值命名文件，区块头可以少一个 sha 字段，看起来好像没啥问题，但是实际实现的时候，用哈希值来命名区块，有一个很严重的 bug 我们使用最终的哈希值有n个前导0，这样来控制难度，文件名是一个字符串，0在字符串里表现为字符 ‘\\0’ ，而这个字符被视为默认的字符串终止符，这个字符串你赋值给 const char* tmp，编译器会发现第一个字符就是字符串终止符，故而会把 tmp 这个字符串常量视为 “” 这样的空字符串保存在常量池，故而不能直接用这个哈希值来作为区块文件的文件名 同样的，但凡这个哈希值里面有 ‘\\0’ ，我们都不能将它作为文件名，所以文件名我不采用哈希值，哈希值还是选择保存在区块头中 功能实现 一个简易的区块链，必须有下面几个功能： 生成创世纪块 读取文件夹下的所有区块 查找创世纪块 查找区块链的最后一个区块 在区块链的尾部追加区块 对区块的SHA计算 求SHA256: 我使用了别人实现的SHA256算法，参考：SHA256-C语言实现 这个程序有一个bug，当我将区块头和尾合并，一起作为字节数组传入时，有时候求出来的SHA256值正常，有时候值是错误的，我检查好久发现他在加密实现的过程中对传入的比特数组做了 strlen() 运算。。。这直接导致了如果传入的数据有 unsigned char 0，将被识别为字符串终结符，strlen() 函数遇到tmp直接终止计算，导致传入的字符串长度识别不正常，故而时好时坏（特别是创世纪块中有大量的 unsigned char 0，一直算出错误的SHA，还难以发现），我手动算字符串长度并作为参数传入计算，算是修了这个bug 生成创世纪块： 先贴代码 1234567891011121314151617181920212223242526272829303132333435363738void init()&#123; // 创建创世纪块 block_chain_head* genesis = malloc(sizeof(block_chain_head)); block_chain_body genesis_body; strcpy(genesis_body.body,&quot;hello world&quot;); memset(genesis-&gt;byte,0,sizeof(block_chain_head)); // 先将区块字节头全部初始化为0 sha256_main(genesis_body.body,sizeof(genesis_body.body),genesis-&gt;sha_block); // 哈希body // 随机 nonce ，对(块头+块体)再次哈希 printf(&quot;开始随机nonce\\n&quot;); while (genesis-&gt;nonce &lt; 0xffffffffffffffff) &#123; // 把块头块体 读入一个 BYTE 数组 BYTE text[10200]; read_head_body(text,genesis,genesis_body); BYTE buf[SHA256_BLOCK_SIZE]; size_t size_of_text = sizeof(block_chain_head)-32 + strlen(genesis_body.body); sha256_main(text,size_of_text,buf); // 计算 sha256 有bug??? (已解决) // 当text 含有 &#x27;\\0&#x27; 时，出现bug // 所以添加变量 size_of_text (注意要减去32 sha_all) printf(&quot;当前nonce为: %lu &quot;,genesis-&gt;nonce); printf(&quot;前8bit为:%02x\\n&quot;,buf[0]); if (check_sha(buf)) &#123; // 检查是否为前导0 printf(&quot;创世纪块nonce为: %lu\\n&quot;,genesis-&gt;nonce); const char* filename = &quot;Genesis.block&quot;; FILE *fp = fopen(filename,&quot;w&quot;); int i; for (i=0;i&lt;SHA256_BLOCK_SIZE;i++) &#123; genesis-&gt;sha_all[i] = buf[i]; &#125; for (i=0;i&lt;sizeof(block_chain_head);i++) &#123; // 写入区块头 fprintf(fp,&quot;%c&quot;,genesis-&gt;byte[i]); &#125; for (i=0;i&lt;strlen(genesis_body.body);i++) &#123; // 写入区块体 fprintf(fp,&quot;%c&quot;,genesis_body.body[i]); &#125; break; &#125; genesis-&gt;nonce++; &#125;&#125; 这里就体现出联合体的优点了，直接可以通过 memset 对整个头初始化，却不影响我访问对应的结构题属性，计算 SHA256 时，我引用了别人的函数，sha256_main()，将对应的属性保存（创世纪块sha_prev = 0)，不断的计算nonce，由于采用了 unsigned long ，遍历只需要递增即可，注意每次递增 nonce，重新计算 SHA 的时候，一定要注意是从区块头的第32个字节开始往下读，一直把区块体的内容也读完，读出来的所有字节放入一个 BYTE text[SHA256_BLOCK_SIZE] 数组里，一起去求 SHA256，这样算出来的 SHA_ALL才是正确的，我这边难度设置的是前 16个 bit 为0，平均大概10秒能出一个块吧 验证 genesis 文件： 使用 Mac 的二进制编辑器Hex Fiend打开查看： 可以看到，前32字节的 sha_all ，是一串乱码，是我们使用SHA256生成的整个文件的256bit 哈希值 接下来8个字节： 再接下来32字节的 sha_prev 全为0，这是我们初始化生成的0，创世纪块没有前一个块嘛 再接下来32字节是 sha_block ，这是区块体的哈希值，可以看到也是一串乱码 最后的部分就是区块 body 的内容了，创世纪块的body 内容我写的很简单，就是hello world，可以看到在右边已经把它解析出来了 读取文件夹下的所有区块： C语言标准库没有提供读取文件夹的函数，官方文档也没找到。。。 我引用了 “dirent.h” 库来读文件夹，调用 readdir(dir) 和 entry-&gt;d_name 来匹配文件名 参考C语言读取文件夹 123456789101112131415161718int read_dir_block(block block_list[],const char* filePath)&#123; // 读文件夹所有块文件 DIR *dir = NULL; struct dirent *entry; if ((dir = opendir(filePath)) == NULL) &#123; printf(&quot;open dir failed\\n&quot;); return -1; &#125; int num=0; while ((entry = readdir(dir))!=NULL) &#123; char* filename = entry-&gt;d_name; if (strstr(filename,&quot;.block&quot;)) &#123; // 匹配区块文件(以.block结尾) read_block(&amp;block_list[num],filename); num++; &#125; &#125; closedir(dir); return num;&#125; 使用 string.h 库函数 strstr() 子串查找，匹配文件名包含 .block 的文件，调用 read_block() 去读取文件 12345678910111213141516void read_block(block *blockitem,const char* filename)&#123; // 读一个块 FILE *fp = fopen(filename,&quot;r&quot;); if(!fp) &#123; perror(&quot;File opening failed&quot;); return; &#125; int c,i=0; while ((c = fgetc(fp)) != EOF) &#123; // standard C I/O file reading loop if (i&lt;sizeof(block_chain_head)) &#123; blockitem-&gt;head.byte[i] = c; &#125; else &#123; blockitem-&gt;body.body[i-sizeof(block_chain_head)] = c; &#125; i++; &#125;&#125; 遍历每个字符，这里又体现出联合体的优势了，直接载入文件的字符流，读 sizeof(block_chain_head) 个字符即可录入头部数据，文件剩余字符全部录入 body 即可 如此便可读取目录下的所有区块文件，放入 block_list 中 查找创世纪块： 实现了读取目录下的所有区块之后，查找创世纪块变得尤其简单，只需要遍历所有的区块，找到某个 SHA_PREV 为全0的区块，即是创世纪块 1234567891011121314151617181920block find_first_block()&#123; block block_list[100]; const char *filePath = &quot;.&quot;; int size = read_dir_block(block_list,filePath); // 一共 size 个区块 block tmp; memset(tmp.head.byte, 0, sizeof(block_chain_head)); if (size &lt;= 0) &#123; printf(&quot;no block file\\n&quot;); return tmp; &#125; BYTE hash[SHA256_BLOCK_SIZE] = &#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00&#125;; int i; for (i=0;i&lt;size;i++) &#123; int cmp = memcmp(hash,block_list[i].head.sha_prev,SHA256_BLOCK_SIZE); if(cmp == 0)&#123; // equal， this is the first block return block_list[i]; &#125; &#125; return tmp;&#125; 我使用memcmp() 函数来比较 SHA_PREV 是否为全0，这是 memcmp 的官方文档： 可以看到，memcmp将二者解释为无符号字符数组，一个个比较，全部相等会返回0，特别方便 所以在这里我直接定义一个32字节全0的字符数组，然后调用 memcmp 比较即可 查找最后一个区块： 这个算是特别常用的一个功能了 在查找文件夹下所有区块和查找创世纪块的基础之上，我们就可以去做区块的拓扑排序了 查找最后一个区块也就变成了求区块的拓扑排序，返回拓扑排序的最后一个区块即可 求拓扑序列的代码很简单我就不展示了，基本上就是一个二重循环，匹配第 j 个区块的 SHA_PREV 和当前区块的 SHA_ALL ，然后在尾部添加即可 尾部添加区块： 有了查找最后一个区块，尾部添加区块也就特别简单了 只需要找到最后一个区块的 SHA_ALL ，新开一个区块，写入 SHA_PREV ，然后就和之前的生成创世纪块类似了， 12345678910111213141516171819202122232425262728293031323334353637383940414243void new_block(const char* block_name ,char* content)&#123; // 和 init 类似，在末尾添加 block last_block = find_last_block(); block_chain_head* genesis = malloc(sizeof(block_chain_head)); block_chain_body genesis_body; strcpy(genesis_body.body,content); memset(genesis-&gt;byte,0,sizeof(block_chain_head)); // 先将区块头全部初始化为0 int i; for (i=0;i&lt;SHA256_BLOCK_SIZE;i++) &#123; genesis-&gt;sha_prev[i] = last_block.head.sha_all[i]; // 写入 sha_prev &#125; sha256_main(genesis_body.body,sizeof(genesis_body.body),genesis-&gt;sha_block); // sha_block // 随机 nonce ，对(块头+块体)再次哈希 printf(&quot;开始随机nonce\\n&quot;); while (genesis-&gt;nonce &lt; 0xffffffffffffffff) &#123; // 把块头块体 读入一个 BYTE 数组 BYTE text[10200]; read_head_body(text,genesis,genesis_body); BYTE buf[SHA256_BLOCK_SIZE]; size_t size_of_text = sizeof(block_chain_head)-32 + strlen(genesis_body.body); sha256_main(text,size_of_text,buf); // 计算 sha256 有bug??? (已解决) // 当text 含有 &#x27;\\0&#x27; 时，出现bug // 所以添加变量 size_of_text (注意要减去32 sha_all) printf(&quot;当前nonce为: %lu &quot;,genesis-&gt;nonce); printf(&quot;前8bit为:%02x\\n&quot;,buf[0]); if (check_sha(buf)) &#123; // 检查是否为前导0 printf(&quot;新区块nonce为: %lu\\n&quot;,genesis-&gt;nonce); const char* filename = strcat(block_name, &quot;.block&quot;); FILE *fp = fopen(filename,&quot;w&quot;); for (i=0;i&lt;SHA256_BLOCK_SIZE;i++) &#123; genesis-&gt;sha_all[i] = buf[i]; &#125; for (i=0;i&lt;sizeof(block_chain_head);i++) &#123; // 写入区块头 fprintf(fp,&quot;%c&quot;,genesis-&gt;byte[i]); &#125; for (i=0;i&lt;strlen(genesis_body.body);i++) &#123; // 写入区块体 fprintf(fp,&quot;%c&quot;,genesis_body.body[i]); &#125; break; &#125; genesis-&gt;nonce++; &#125;&#125; 不要在意为什么新区块也叫 genesis 我懒得改了 除了区块的 filename 、SHA_PREV 、body 不一样，其他的操作完全和创世纪块一样 写新区块时，我需要给新区块后缀命名为 .block c语言不能直接使用 + 运算符对字符串进行拼接，故使用strcat，跑到一半又报错了。。原因是strcat直接在字符数组尾部添加字符，晕，数组越界了。 不得不再次感叹C语言的字符串处理真是太不方便了 可以看到 block_one 的 sha_prev 的部分，变成了 genesis 的前32字节，也就是哈希值指向 genesis 新区块的产生基本和创世纪块一样，只是调用一下 find_last_block ，找到 sha_prev 的值即可，然后自行输入 block_name 和 block_body 再看 block_two 和 block_one 相应的 sha_prev、 sha_all 字段都是一一对应起来的 解析出来的 body 也是正常的 尾部新增区块完成！ 检验区块链合法 在 find_last_block() 函数的实现中，topo 序列只要能构造出来，说明sha_prev 和 sha_all 能够一一对上，该区块链是合法的，所以实现也和 find_last_block 基本一样。如果创世纪块找不到，则区块链不合法，从创世纪块后找 n个区块（n为区块总数目-1），一旦找不到区块的 sha_prev 指向当前 sha_all，则区块链不合法，具体实现在 check_block_chain() 函数里，得到拓扑序列之后，遍历这个序列，计算各个区块的 SHA_，任意区块的 SHA 计算错误则该区块链不合法 建立区块链索引 find_last_block() 和 check_block_chain() 函数里都做过拓扑排序的操作，参考上面的函数即可 源码 感谢能看到最后的小伙伴！代码我开源到 GitHub 了 https://github.com/panlianghnu/block_chain","categories":[],"tags":[{"name":"c语言","slug":"c语言","permalink":"https://panlianghnu.github.io/tags/c%E8%AF%AD%E8%A8%80/"},{"name":"区块链","slug":"区块链","permalink":"https://panlianghnu.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"}]},{"title":"JS 单线程","slug":"JS-单线程","date":"2020-12-22T12:44:08.000Z","updated":"2020-12-22T12:45:02.000Z","comments":true,"path":"2020/12/22/JS-单线程/","link":"","permalink":"https://panlianghnu.github.io/2020/12/22/JS-%E5%8D%95%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"JS 单线程 JS执行是单线程 单线程是指Js引擎执行Js时只分了一个线程给他执行，也就是执行js时是单线程的。 那么问题来了，什么是线程？进程又是什么？ 在分析浏览器的渲染过程之前，我们先了解一下什么是进程和线程： （1）什么是进程？ 进程是CPU进行资源分配的基本单位 （2）什么是线程？ 线程是CPU调度的最小单位，是建立在进程的基础上运行的单位，共享进程的内存空间。 多进程 1、浏览器是多进程 2、不同类型的标签页都会开启一个新的进程 3、相同类型的标签页是会合并到一个进程 1、浏览器进程 （1）负责管理各个标签页的创建和销毁 （2）负责浏览器的页面显示和功能（前进，后退，收藏等） （3）负责资源的管理与下载 2、第三方插件进程 （1）负责每个第三方插件的使用，每个第三方插件使用时候都会创建一个对应的进程 3、GPU进程 （1）负责3D绘制和硬件加速 4、浏览器渲染进程（咱们这回主要分析的） 1、浏览器内核，主要负责HTML，CSS，JS等文件的解析和执行 什么是浏览器内核？ 浏览器内核就是浏览器渲染进程，从接收下载文件后再到呈现整个页面的过程，由浏览器渲染进程负责，主要流程如下： 1、解析HTML文件和CSS文件，加载图片等资源文件，渲染成用户看到的页面 2、执行解析js文件脚本代码 这里主要讲浏览器页面渲染过程，在该过程中浏览器渲染进程会开启多个线程协作完成，主要的线程以及作用如下： 1、GUI渲染线程 2、JS引擎线程 3、事件触发线程 4、定时器出发线程 5、异步HTTP请求线程 JS引擎 1、JS内核，也称JS引擎（例如V8引擎），负责处理执行javascript脚本程序， 2、由于js是单线程（一个Tab页内中无论什么时候都只有一个JS线程在运行JS程序），依靠任务队列来进行js代码的执行，所以js引擎会一直等待着任务队列中任务的到来，然后加以处理。 注意，JavaScript 只在一个线程上运行，不代表 JavaScript 引擎只有一个线程。事实上，JavaScript 引擎有多个线程，单个脚本只能在一个线程上运行（称为主线程），其他线程都是在后台配合 为了利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作 DOM。所以，这个新标准并没有改变 JavaScript 单线程的本质。 V8引擎的内部结构 1、V8是一个非常复杂的项目，使用cloc统计可知，它竟然有超过100万行C++代码。 2、V8由许多子模块构成，其中这4个模块是最重要的： Parser：负责将JavaScript源码转换为Abstract Syntax Tree (AST) Ignition：interpreter，即解释器，负责将AST转换为Bytecode，解释执行Bytecode；同时收集3. TurboFan优化编译所需的信息，比如函数参数的类型； TurboFan：compiler，即编译器，利用Ignitio所收集的类型信息，将Bytecode转换为优化的汇编代码； Orinoco：garbage collector，垃圾回收模块，负责将程序不再需要的内存空间回收； 再次强调：单线程是指Js引擎执行Js时只分了一个线程给他执行，也就是执行js时是单线程的。 既然JS是单线程的，那怎么实现异步的呢？ 单线程意味着什么：JavaScript 同时只能执行一个任务，其他任务都必须在后面排队等待。也就是说代码只能同步执行，必须执行上一行才能执行下一行。 123456console.log(&#x27;1&#x27;)setTimeout(() =&gt; &#123; console.log(&#x27;2&#x27;)&#125;, 0);console.log(&#x27;3&#x27;)12345 然而并不是，还有异步！！！ 程序里面所有的任务，可以分成两类：同步任务（synchronous）和异步任务（asynchronous）。 同步任务是那些没有被引擎挂起、在主线程上排队执行的任务。只有前一个任务执行完毕，才能执行后一个任务。 异步任务是那些被引擎放在一边，不进入主线程、而进入任务队列的任务。只有引擎认为某个异步任务可以执行了（比如 Ajax 操作从服务器得到了结果），该任务（采用回调函数的形式）才会进入主线程执行。排在异步任务后面的代码，不用等待异步任务结束会马上运行，也就是说，异步任务不具有“堵塞”效应。 举例来说，Ajax 操作可以当作同步任务处理，也可以当作异步任务处理，由开发者决定。如果是同步任务，主线程就等着 Ajax 操作返回结果，再往下执行；如果是异步任务，主线程在发出 Ajax 请求以后，就直接往下执行，等到 Ajax 操作有了结果，主线程再执行对应的回调函数。 任务队列和事件循环 （实现异步） JavaScript 运行时，除了一个正在运行的主线程，引擎还提供一个任务队列（task queue），里面是各种需要当前程序处理的异步任务。（实际上，根据异步任务的类型，存在多个任务队列。为了方便理解，这里假设只存在一个队列。） 首先，主线程会去执行所有的同步任务。等到同步任务全部执行完，就会去看任务队列里面的异步任务。如果满足条件，那么异步任务就重新进入主线程开始执行，这时它就变成同步任务了。等到执行完，下一个异步任务再进入主线程开始执行。一旦任务队列清空，程序就结束执行。 异步任务的写法通常是回调函数。一旦异步任务重新进入主线程，就会执行对应的回调函数。如果一个异步任务没有回调函数，就不会进入任务队列，也就是说，不会重新进入主线程，因为没有用回调函数指定下一步的操作。 JavaScript 引擎怎么知道异步任务有没有结果，能不能进入主线程呢？答案就是引擎在不停地检查，一遍又一遍，只要同步任务执行完了，引擎就会去检查那些挂起来的异步任务，是不是可以进入主线程了。这种循环检查的机制，就叫做事件循环（Event Loop）。维基百科的定义是：“事件循环是一个程序结构，用于等待和发送消息和事件（a programming construct that waits for and dispatches events or messages in a program）”。 代码是如何执行的？ 宏任务(macro-task)、微任务(micro-task) 除了广义的同步任务和异步任务，JavaScript 单线程中的任务可以细分为宏任务和微任务。 macro-task包括：script(整体代码), setTimeout, setInterval, setImmediate, I/O, UI rendering。 micro-task包括：process.nextTick, Promises, Object.observe, MutationObserver。 有了宏任务和微任务的概念后，那 JS 的执行顺序是怎样的？是宏任务先还是微任务先？ 第一次事件循环中，JavaScript 引擎会把整个 script 代码当成一个宏任务执行，执行完成之后，再检测本次循环中是否寻在微任务，存在的话就依次从微任务的任务队列中读取执行完所有的微任务，再读取宏任务的任务队列中的任务执行，再执行所有的微任务，如此循环。JS 的执行顺序就是每次事件循环中的宏任务-微任务。 页面刷新率？ 每次微任务执行之后宏任务执行之前如果有UI操作页面会重新渲染，一般页面刷新率60HZ/秒，一帧是16.6毫秒，所以可以理解为事件循环每次轮询的时间大概是16.6毫秒 每一帧浏览器需要做什么？ 我们所看到的网页，都是浏览器一帧一帧绘制出来的，通常认为FPS为60的时候是比较流畅的，而FPS为个位数的时候就属于用户可以感知到的卡顿了，那么在一帧里面浏览器都要做哪些事情呢 渲染帧的流程 渲染帧是指浏览器一次完整绘制过程，帧之间的时间间隔是 DOM 视图更新的最小间隔。 由于主流的屏幕刷新率都在 60Hz，那么渲染一帧的时间就必须控制在 16ms 才能保证不掉帧。 也就是说每一次渲染都要在 16ms 内页面才够流畅不会有卡顿感。 这段时间内浏览器需要完成如下事情： 脚本执行（JavaScript）：脚本造成了需要重绘的改动，比如增删 DOM、请求动画等 样式计算（CSS Object Model）：级联地生成每个节点的生效样式。 布局（Layout）：计算布局，执行渲染算法 重绘（Paint）：各层分别进行绘制（比如 3D 动画） 合成（Composite）：合成各层的渲染结果 最初 Webkit 使用定时器进行渲染间隔控制， 2014 年时开始 使用显示器的 vsync 信号控制渲染（其实直接控制的是合成这一步）。 这意味着 16ms 内多次 commit 的 DOM 改动会合并为一次渲染。 耗时 JS 会造成丢帧 JavaScript 在并发编程上一个重要特点是“Run To Completion”。在事件循环的一次 Tick 中， 如果要执行的逻辑太多会一直阻塞下一个 Tick，所有异步过程都会被阻塞。 一个流畅的页面中，JavaScript 引擎中的执行队列可能是这样的： 1执行 JS -&gt; 空闲 -&gt; 绘制（16ms）-&gt; 执行 JS -&gt; 空闲 -&gt; 绘制（32ms）-&gt; ... 如果在某个时刻有太多 JavaScript 要执行，就会丢掉一次帧的绘制： 1执行很多 JS...（20ms）-&gt; 空闲 -&gt; 绘制（32ms）-&gt; ... 例如下面的脚本在保持 JavaScript 忙的状态（持续 5s）下每隔 1s 新增一行 DOM 内容。 1234567891011121314151617&lt;div id&#x3D;&quot;message&quot;&gt;&lt;&#x2F;div&gt;&lt;script&gt;var then &#x3D; Date.now()var i &#x3D; 0var el &#x3D; document.getElementById(&#39;message&#39;)while (true) &#123; var now &#x3D; Date.now() if (now - then &gt; 1000) &#123; if (i++ &gt;&#x3D; 5) &#123; break; &#125; el.innerText +&#x3D; &#39;hello!\\n&#39; console.log(i) then &#x3D; now &#125;&#125;&lt;&#x2F;script&gt; 可以观察到虽然每秒都会写一次 DOM，但在 5s 结束后才会全部渲染出来，明显耗时脚本阻塞了渲染。","categories":[],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://panlianghnu.github.io/tags/nodejs/"}]},{"title":"python 文字版RPG小游戏","slug":"python-文字版RPG小游戏","date":"2020-12-17T07:44:24.000Z","updated":"2020-12-21T01:31:37.000Z","comments":true,"path":"2020/12/17/python-文字版RPG小游戏/","link":"","permalink":"https://panlianghnu.github.io/2020/12/17/python-%E6%96%87%E5%AD%97%E7%89%88RPG%E5%B0%8F%E6%B8%B8%E6%88%8F/","excerpt":"","text":"之前龙哥给我们布置了两个任务 语言快速上手-学习任务 这是第一个 基本就是实现一个文字版本的RPG小游戏，刚好我今天在bilibili看到一个互动视频觉得很有意思，就想着把这个视频用文字的形式复现出来 视频链接：【互动视频】卢本伟越狱记 这种互动视频有很多选项，每个选项都会影响之后的剧情，所以我使用一个栈来保存之前的选择，也方便每次互动时，玩家选错选项来有机会反悔回到上一步 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196stack = []stack.append(0)while len(stack)&gt;0: case = stack[-1] # 读最后一个case if case == 0: # case0:等待开始游戏 print(&#x27;卢本伟越狱记&#x27;) print(&#x27;卢本伟开挂被抓了，你能帮助卢本伟成功越狱吗？（你需要扮演卢本伟完成越狱）&#x27;) start = input(&quot;输入&#x27;start&#x27;开始游戏，输入其他结束\\n&quot;) if start != &#x27;start&#x27;: print(&quot;你输入了：&quot;,start,&quot; 游戏结束...&quot;) break else: # 游戏开始 stack.append(1) continue if case == 1: # case1:开始游戏 print(&quot;卢本伟被关在牢房，这时来了俩警察&quot;) print(&#x27;警察1:“you are free guy now...骗你的哈哈哈”&#x27;) print(&#x27;警察1:“你有个朋友给你寄了一个包裹，但是你不要想着轻举妄动，我们已经检查过里面了，是吧？”&#x27;) print(&#x27;警察2:“（心虚）是啊是啊，我当然检查过了，这是我的工作嘛”&#x27;) print(&#x27;两个警察把包裹留下就走了&#x27;) print(&#x27;卢本伟打开了包裹，发现一个生日蛋糕，生日蛋糕里面居然藏了东西，你会选择？&#x27;) tmp = input(&#x27;A.锉刀 B.钻机 C.返回上一步 其他.结束游戏\\n&#x27;) if tmp == &quot;A&quot; : stack.append(2) # case2: 选择锉刀 continue if tmp == &quot;B&quot; : stack.append(3) # case3: 选择钻机 continue if tmp == &quot;C&quot; : del stack[-1] continue else : break if case == 2: # case2：选择锉刀 print(&#x27;你选择了锉刀，卢本伟切割了监狱门，并打倒了守卫，这时有人追了过来&#x27;) print(&#x27;卢本伟灵机一动，躲进了一个小房间，但是这不是长久之计，必须找到方法越狱&#x27;) print(&#x27;卢本伟发现房间里有：A.手雷 B.椅子&#x27;) tmp = input(&#x27;聪明的你会选择：A.手雷 B.椅子 C.返回上一步 其他.结束游戏\\n&#x27;) if tmp == &quot;A&quot; : stack.append(4) # case4: 选择手雷 continue if tmp == &quot;B&quot; : stack.append(5) # case5: 选择椅子 continue if tmp == &quot;C&quot; : del stack[-1] continue else : break if case == 4: # case4: 选择手雷 print(&#x27;情急之下，卢本伟拿起了地上的手雷，准备和追来的警察拼死一搏&#x27;) print(&#x27;两个警察追过俩把门堵上，卢本伟失手把自己炸死了&#x27;) print(&#x27;game over&#x27;) tmp = input(&#x27;输入A重开游戏，输入B返回上一步，输入其他结束游戏\\n&#x27;) if tmp == &quot;A&quot;: stack = [] stack.append(0) continue if tmp == &quot;B&quot;: del stack[-1] continue else : break if case == 5: # case5: 选择椅子 print(&#x27;聪明的卢本伟发现通过椅子可以钻进天花板的通风管道&#x27;) print(&#x27;这个时候问题来了，通风管道只能向左或向右&#x27;) tmp = input(&#x27;你会选择？ A.向右 B.向左 C.返回上一步 其他.结束游戏\\n&#x27;) if tmp == &quot;A&quot; : stack.append(6) # case6: 选择向右 continue if tmp == &quot;B&quot; : stack.append(7) # case7: 选择向左 continue if tmp == &quot;C&quot; : del stack[-1] continue else : break if case == 6: # 选择向右 print(&#x27;卢本伟顺着通风管道爬到了天台&#x27;) print(&#x27;在天台，卢本伟发现了 A.喷气背包 B.马桶塞&#x27;) print(&#x27;你会选择什么装备逃生？&#x27;) tmp = input(&#x27;A.喷气背包 B.马桶塞 C.返回上一步 其他.结束游戏\\n&#x27;) if tmp == &quot;A&quot; : stack.append(8) # case8: 选择喷气背包 continue if tmp == &quot;B&quot; : stack.append(9) # case9: 选择马桶塞 continue if tmp == &quot;C&quot; : del stack[-1] continue else : break if case == 7: # 选择向左 print(&#x27;警察们在会议室开会，而卢本伟不小心掉进了会议室，game over&#x27;) tmp = input(&#x27;输入A重开游戏，输入B返回上一步，输入其他结束游戏\\n&#x27;) if tmp == &quot;A&quot;: stack = [] stack.append(0) continue if tmp == &quot;B&quot;: del stack[-1] continue else : break if case == 8: # case8: 选择喷气背包 print(&#x27;伞兵一号卢本伟准备就绪！！！&#x27;) print(&#x27;Oh这是个坏的喷气背包，卢本伟摔死了&#x27;) tmp = input(&#x27;输入A重开游戏，输入B返回上一步，输入其他结束游戏\\n&#x27;) if tmp == &quot;A&quot;: stack = [] stack.append(0) continue if tmp == &quot;B&quot;: del stack[-1] continue else : break if case == 9: # case9: 选择马桶塞 print(&#x27;卢本伟左手一个马桶塞，右手一个马桶塞&#x27;) print(&#x27;凭借强大的臂力和马桶塞的吸力，卢本伟成功的飞檐走壁逃出监狱！！&#x27;) tmp = input(&#x27;输入A重开游戏，输入B返回上一步，输入其他结束游戏\\n&#x27;) if tmp == &quot;A&quot;: stack = [] stack.append(0) continue if tmp == &quot;B&quot;: del stack[-1] continue else : break if case == 3: # case3: 选择钻机 print(&#x27;你选择了钻机，卢本伟使用钻机钻地，发现地下还有个房间&#x27;) print(&#x27;卢本伟想都没想直接跳进了下面的房间，环顾四周&#x27;) print(&#x27;房间里有一个井盖好像可以撬开，还有一个传送器上面写着“你会变得透明并可以穿墙”&#x27;) tmp = input(&#x27;你会选择？ A.传送器 B.撬棍 C.返回上一步 其他.结束游戏\\n&#x27;) if tmp == &quot;A&quot; : stack.append(10) # case10: 选择传送器 continue if tmp == &quot;B&quot; : stack.append(11) # case11: 选择撬棍 continue if tmp == &quot;C&quot; : del stack[-1] continue else : break if case == 10: print(&#x27;你选择了传送器&#x27;) print(&#x27;卢本伟按下了传送器，他开始变得透明，墙无法阻挡他，但是地面也无法支撑他，卢本伟直接沉到了地心，死了&#x27;) tmp = input(&#x27;输入A重开游戏，输入B返回上一步，输入其他结束游戏\\n&#x27;) if tmp == &quot;A&quot;: stack = [] stack.append(0) continue if tmp == &quot;B&quot;: del stack[-1] continue else : break if case == 11: print(&#x27;你选择了撬棍&#x27;) print(&#x27;卢本伟撬开了井盖，钻进井盖发现掉到了一楼大厅走廊上&#x27;) print(&#x27;卢本伟被两个警察发现，警察们追着他跑&#x27;) tmp = input(&#x27;这时你会？ A.往左跑 B.往右跑 C.返回上一步 其他.结束游戏\\n&#x27;) if tmp == &quot;A&quot;: stack.append(12) # case12: 往左跑 continue if tmp == &quot;B&quot;: stack.append(13) # case13: 往右跑 continue if tmp == &quot;C&quot;: del stack[-1] continue else : break if case == 12: print(&#x27;你选择向左逃跑&#x27;) print(&#x27;那两个警察追不上卢本伟，但是追的人越来越多&#x27;) print(&#x27;现在卢本伟被五个带枪的警察包围&#x27;) print(&#x27;但是凭借卢本伟的走位，他们一枪没中，甚至射死了自己人&#x27;) print(&#x27;卢本赶紧趁乱跑到门口抢了一辆警车跑了&#x27;) print(&#x27;越狱成功，game over...&#x27;) tmp = input(&#x27;输入A重开游戏，输入B返回上一步，输入其他结束游戏\\n&#x27;) if tmp == &quot;A&quot;: stack = [] stack.append(0) continue if tmp == &quot;B&quot;: del stack[-1] continue else : break if case == 13: print(&#x27;卢本伟边走位边逃跑的时候还就那个不小心一头簪死在柱子上&#x27;) print(&#x27;无敌的卢本伟倒下了&#x27;) print(&#x27;game over...&#x27;) tmp = input(&#x27;输入A重开游戏，输入B返回上一步，输入其他结束游戏\\n&#x27;) if tmp == &quot;A&quot;: stack = [] stack.append(0) continue if tmp == &quot;B&quot;: del stack[-1] continue else : break 下面是剧情介绍（建议去上面的视频链接，更加清晰）： 卢本伟越狱记 卢本伟开外挂被抓了，你能帮助卢本伟成功越狱吗？（你需要扮演卢本伟完成越狱） 卢本伟被关在监狱，来了俩警察 警察1:“you are free guy，骗你的” 警察1:“你有个朋友给你寄了一个包裹，但是你不要想着轻举妄动，我们已经检查过里面了，是吧？” 警察2:“（心虚）是啊是啊，我当然检查过了，这是我的工作嘛” 卢本伟打开了包裹，发现一个生日蛋糕，生日蛋糕里面居然藏了东西，你会选择？A.锉刀 B.钻机 A.锉刀：你选择了锉刀，卢本伟切割了监狱门，并打倒了守卫，这时有人追了过来 ​ 你躲进了一个小房间，房间里有：A.手雷 B.椅子 ​ A.手雷：两个人来抓你，你把自己炸死了 ​ B.椅子：你通过椅子，爬进了通风管道，向左向右？ ​ A.右 你爬到了天台，天台上有：A.喷气背包 B.马桶塞 ​ A.伞兵一号卢本伟准备就绪，Oh，这是个坏的喷气背包，你摔死了 ​ B.你成功的通过马桶塞一步一步吸住墙壁越狱成功！ ​ B.左 警察们在会议室开会，你不小心掉进了会议室，game over B.钻机：你选择了钻机，使用钻机钻地，你发现地下还有个房间， ​ 房间里有一个井盖好像可以撬开，还有一个传送器上面写着“你会变得透明并可以穿墙” ​ A.传送器 B.撬棍 ​ A.你按下了传送器，墙无法阻挡你，地面也无法支撑你，你直接沉到了地球核心，死了 ​ B.你撬开了井盖，掉到了走廊，两个警察追着你跑 ​ A.往左 你被五个人围住，但是凭借着走位，他们一枪没中，你抢了一辆警车跑路了 ​ B.往右 你撞上了柱子，无敌的你倒下了 游戏装备介绍： 传送器： 马桶塞： 步骤：","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://panlianghnu.github.io/tags/python/"}]},{"title":"Python快速入门","slug":"Python快速入门","date":"2020-12-15T02:49:20.000Z","updated":"2020-12-17T10:10:36.000Z","comments":true,"path":"2020/12/15/Python快速入门/","link":"","permalink":"https://panlianghnu.github.io/2020/12/15/Python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/","excerpt":"","text":"Python快速入门 函数 定义一个函数 123def functionname( parameters ): function_suite return [expression] 参数传递 python里一切都是对象，参数都是对象的引用 不可变类型：如整数、浮点数、字符串、元组() 可变类型：如列表、字典、自定义对象 不可变类型作为参数传入时，对参数的修改其实是修改另一个复制的对象 可变类型作为参数传入时，函数内的修改会影响到函数外 关键字参数 传参数时，要么按照要求（参数顺序，数量）严格传入参数，要么使用关键字参数 12print(climbStairs(climbStairs,5)) # 斐波那契print(climbStairs(n=5,self=climbStairs)) # 斐波那契 使用关键字参数，就可以不严格按照顺序来传参，并且代码可读性更好 注意⚠️：关键字参数不能和普通传参混用，一个参数是关键字参数，其他也要是 默认参数 123def printHello(arg=&quot;hello&quot;): print(arg) return 这个函数可以不输入参数，也可以输入一个参数来替换默认的&quot;hello&quot; 不定长参数 1234567def printAll(arg1, *vartuple): # *vartuple 表示不定长参数，0~n个都可以 # 而 arg1 保证至少有一个参数传进来，该函数不至于输出空 print(arg1) for var in vartuple: print(var) return 匿名函数（lambda） python 使用 lambda 来创建匿名函数 123456# lambda arg1,arg2,arg3... : expressionpow = lambda arg1,arg2 : arg1 ** arg2 # pow变量指向 lambda 这个匿名函数# lambda只是一个表达式，函数体比def简单很多，仅仅能在lambda表达式中封装有限的逻辑进去# 不能访问自有参数列表之外或全局命名空间里的参数！！# 不等同于C或C++的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率 变量作用域 全局变量 定义在函数外，可以在整个程序范围内访问 局部变量 定义在函数内，只能在函数内访问 变量 变量没有类型，变量是任意对象的引用，变量的赋值不需要声明，python是动态类型+强类型的语言 标准数据类型 python 提供了6个标准数据类型 注意⚠️：没有提供数组类型，建议用列表替代 **a = [ 0 for i in range(1000) ] ** Numbers 不可变 Strings 不可变 序列 Tuple (元组) 不可变 序列 （虽然元组的元素不可改变，但是元组可以包含可变对象） List [列表] 序列 Dictionary {字典} Set 集合 Numbers : int （有符号整数） Long (python2.2 之后被移除，int 溢出会自动变为 long) float （浮点数） complex（复数） Strings : 字符串取值： 从左到右 str[0] ~ str[len-1] 从右到左 str[-1] ~ str[-len] 截取字符串：[头下表 : 尾下标] 这将返回一个新的对象 Python列表截取还要第三个参数（步长） 列表： 列表可以完成大多数集合类的数据结构实现 最常用的类型 它支持字符，数字，字符串甚至可以包含列表（即嵌套） 用 + 连接列表， 用 * 表示重复操作 1234a = &#x27;12345&#x27;b = a[2:] + a[4:]print(b * 2)输出：34553455 列表内置方法很多 12append clear copy count extendindex pop remove reverse sort 列表的元素是可以删除的： del a[2] 适用于列表的方法： cmp(list1, list2) , 列表类型不同则没啥意义，类型相同则 哪个列表短哪个列表就小，返回1或-1 一样长则元素小列表就小，返回1或-1 所有元素相同则返回0 len(list)，获得列表长度 max(list)，返回列表元素最大值 min(list)，返回列表元素最小值 list(seq)，将元组转换为列表 元组： 可以理解为只读列表，不能二次赋值 元组用 () 标识 删除元组只能删除整个元组 del tup 字典： 字典(dictionary)是除列表以外python之中最灵活的内置数据结构类型 字典用 {} 标识 通过 dict[key] 来访问 value 字典的key 必须是不可变对象 可以删除 key-value 也能显示删除整个字典 : del dict[‘key’] 、 del dict 字典包括以下内置方法： 12345678910clear get has_key(key)copy(浅复制) items # 以列表返回可以遍历的 key-value 元组fromkeys(seq[,val]) # 返回一个列表，keys为这个序列的值，val为默认值keys(返回所有key)values（返回所有值）upadte(dict2) # 把dict2的键值对更新到dict里pop(key)popitem() # 返回并删除字典中最后一对 key-value 数据类型转换 函数 描述 int(x [,base]) 将x转换为一个整数 long(x [,base]) 将x转换为一个长整数 float(x) 将x转换到一个浮点数 complex(real [,imag]) 创建一个复数 str(x) 将对象 x 转换为字符串 repr(x) 将对象 x 转换为表达式字符串 eval(str) 用来计算在字符串中的有效Python表达式,并返回一个对象 tuple(s) 将序列 s 转换为一个元组 list(s) 将序列 s 转换为一个列表 set(s) 转换为可变集合 dict(d) 创建一个字典。d 必须是一个序列 (key,value)元组。 frozenset(s) 转换为不可变集合 chr(x) 将一个整数转换为一个字符 unichr(x) 将一个整数转换为Unicode字符 ord(x) 将一个字符转换为它的整数值 hex(x) 将一个整数转换为一个十六进制字符串 oct(x) 将一个整数转换为一个八进制字符串 元组包含可变对象时 直接上代码 12345678910111213a = [1,2]b = 4c = (a,b) # c为包含可变对象的元组print(c)a.append(3)print(c)a = [5,6,7]print(c)打印结果：([1, 2], 4)([1, 2, 3], 4)([1, 2, 3], 4) 可以看到，当 a.append(3)后，c[0]变化了。当 a = [5,6,7] 时，c[0]没变 所以，元组的元素不可变应该这样理解，生成元组时，元组里的所有元素都会被保存在数据区 a = [5,6,7]，是像字符串赋值那样重新开辟了内存空间，让a指向新的内存，但是元组内的值还是指向原来的内存，所以这个情况元组的值是不会变化的 a.append(3)，a本身是没有变化的，但是a指向的内存里的值发生了变化，所以元组也&quot;变化&quot;了 再来看一个情况 这个情况也是 a.append()。为什么c没有变化呢？ list底层是数组实现的，添加这么多元素后，a 指向的内存地址发生了变化，而元组内的值指向的内存地址是不会发生变化的，所以这个时候，a和元组内的&quot;a&quot; 不是一个a了 所谓元组的不可变指的是元组所指向的内存中的内容不可变 运算符 算数运算： + - * / % **(返回x的y次幂) //（返回商的整数部分，python里整数除以整数也会转换成浮点数） 比较运算： == 比较对象是否相等 (字符串可以用这个比较) != 比较对象是否不等 &lt; &gt;= &lt;= 位运算： &amp; 按位与 | 按位或 ^ 按位异或 按位取反 &lt;&lt; 左移 （不会溢出，自动变成long） &gt;&gt; 右移 （它是算数右移，-4右移变成-2） 逻辑运算： and or not 成员运算： in：如果在指定的序列中找到值返回 True，否则返回 False。 not in： 如果在指定的序列中没有找到值返回 True，否则返回 False。 身份运算： 用于判断变量是否指向同一个对象 is （和==不一样，==是判断值，is 判断对象） is not 12345678910a = student(name=&quot;panliang&quot;,age=4)b = student(name=&quot;panliang&quot;,age=4)if a == b: print(&quot;a == b&quot;)else: print(&quot;a != b&quot;)if a is b: print(&quot;a is b&quot;)else: print(&quot;a is not b&quot;) 打印结果： 可以看到，自定义对象不能用 == 比较（python字符串可以），就算他们的内容相同 循环 while循环 12while (condition): statements contidion 可以是任何表达式，任何非零、或非空（null）的值均为true。 for循环 12for i in sequence: statements 遍历序列所有的元素 注意⚠️：给列表赋值时，这样写是不行的 for i in seq 返回的是新的对象 for 循环经常和 range 函数配合使用 12for i in range(n): statements range(n)会返回一个列表，i 会从0遍历到n-1 range也支持多个参数，比如反向遍历 range(n,0,-1)，遍历从n到1（不会到0） python3的range()函数返回的是一个可迭代对象（类型是对象），而不是列表（为了性能），所以打印range不会输出列表 循环的else 123456789for num in range(10,20): # 迭代 10 到 20 之间的数字 for i in range(2,num): # 根据因子迭代 if num%i == 0: # 确定第一个因子 j=num/i # 计算第二个因子 print &#x27;%d 等于 %d * %d&#x27; % (num,i,j) break # 跳出当前循环 else: # 循环的 else 部分 print num, &#x27;是一个质数&#x27;# 当循环没有通过break跳出来时， 会执行 else while循环也类似 模块、输入和输出 命令行参数 1234import sysfor i in sys.argv: print(i)print(&#x27;\\nPython路径为：&#x27;,sys.path,&#x27;\\n&#x27;) 代码回输出所有通过命令行传入的参数 sys.path 包含了一个 Python 解释器自动查找所需模块的路径的列表（相当于环境变量） import时，会自动执行被导入的包里的程序 12345如果希望自己的程序不在被import时执行，需要把自己的程序代码写在if __name__==&#x27;__main__&#x27;: print(&#x27;我自己在运行&#x27;)else: print(&#x27;我来自另一模块&#x27;) 包 包是一种管理 Python 模块命名空间的形式，采用 package.module 就不会让不同包的模块混淆以及不同模块之间的全局变量互相影响 在导入一个包的时候，Python 会根据 sys.path 中的目录来寻找这个包中包含的子目录 目录只有包含一个叫做 _init_.py 的文件才会被认作是一个包，主要是为了避免一些滥俗的名字 123456789101112131415161718192021222324可能的包结构sound/ 顶层包 __init__.py 初始化 sound 包 formats/ 文件格式转换子包 __init__.py wavread.py wavwrite.py aiffread.py aiffwrite.py auread.py auwrite.py ... effects/ 声音效果子包 __init__.py echo.py surround.py reverse.py ... filters/ filters 子包 __init__.py equalizer.py vocoder.py karaoke.py ... 可以 imort sound.formats.auwrite 来导入 auwrite 模块 但是调用函数时，也需要sound.formats.auwrite.function 所以不妨这样 from sound.formats import auwrite 调用函数时，只需要 auwrite.function , 无需冗长前缀 甚至可以只导入一个函数或者变量： from sound.effects.echo import echofilter 这种方法会导入子模块: echo，并且可以直接使用他的 echofilter() 函数 当使用 from package import item 时， import 语法会首先把 item 当作一个包定义的名称，如果没找到，再试图按照一个模块去导入。最后按照函数、类、变量这样去找。 如果还没找到，抛出一个 :exc:ImportError 异常。 反之，如果使用形如 import item.subitem.subsubitem 这种导入形式，除了最后一项，都必须是包，而最后一项则可以是模块或者是包，但是不可以是类，函数或者变量的名字。 从包里导入*，会找到目录下所有的子模块，都导入，但是在windows这类大小写不分的平台上工作很不好，需要包作者在 _init_.py 里的一个 all 列表变量写入导入的包名 输入和输出 标准输入输出 Python提供了 input() 内置函数从标准输入读入一行文本 12str = input(&quot;请输入:&quot;)print(str) 读写文件 123txt = open(&#x27;addTowNum.py&#x27;,&#x27;r&#x27;)str = txt.read()print(str) open有两个参数，一个是filename， 一个是文件打开模式（可以不写，默认模式为 r ） file.read()有一个参数size，表示读取的数据数量（可以不写，默认读文件所有字符） file.readline() 读文件一行 file.write(str) 将str写入文件，返回写入的字符数 模式 描述 r 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。 rb 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。 r+ 打开一个文件用于读写。文件指针将会放在文件的开头。 rb+ 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。 w 打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 wb 以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 w+ 打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 wb+ 以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 a 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 ab 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 a+ 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。 ab+ 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。 file.close() 关闭文件 1234with open(&#x27;/tmp/foo.txt&#x27;, &#x27;r&#x27;) as f: read_data = f.read()f.closed使用with 比 try finally 简单 日期和时间 import time 时间戳 time.time() 用于获取当前时间戳（是一个浮点数，表示从1970年1月1日午夜，经过了多少秒） 无法表示1970年之后的、Unix和Windows只支持到2038年 非常适合用于计算时间差 时间元组 很多python函数用包含9个元素的元组来处理时间： struct_time 元组 序号 属性 值 0 tm_year 2008 1 tm_mon 1 到 12 2 tm_mday 1 到 31 3 tm_hour 0 到 23 4 tm_min 0 到 59 5 tm_sec 0 到 61 (60或61 是闰秒) 6 tm_wday 0到6 (0是周一) 7 tm_yday 1 到 366(儒略历) 8 tm_isdst -1, 0, 1, -1是决定是否为夏令时的旗帜 时间戳转换为时间元组 只需要将浮点数传递给如 localtime 之类的函数 12345import timelocaltime = time.localtime(time.time())print(&quot;本地时间为：&quot;,localtime)本地时间为：time.struct_time(tm_year=2020, tm_mon=12, tm_mday=15, tm_hour=17, tm_min=11, tm_sec=52, tm_wday=1, tm_yday=350, tm_isdst=0) 获取格式化时间 你可以获取时间元组，然后自定义输出 但是有一个函数可以很方便得将时间元组转换成字符串 123456import timelocaltime = time.localtime(time.time())asctime = time.asctime(localtime)print(asctime)Tue Dec 15 17:20:16 2020","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://panlianghnu.github.io/tags/python/"}]},{"title":"Anaconda安装","slug":"Anaconda安装","date":"2020-12-14T09:58:36.000Z","updated":"2020-12-14T10:53:45.000Z","comments":true,"path":"2020/12/14/Anaconda安装/","link":"","permalink":"https://panlianghnu.github.io/2020/12/14/Anaconda%E5%AE%89%E8%A3%85/","excerpt":"","text":"Anaconda 是Mac电脑上的一个开源的Python发行版本。Conda是一个开源的包、环境管理器，可以用于在同一个机器上安装不同版本的软件包及其依赖，并能够在不同的环境之间切换。Anaconda包括Conda、Python以及一大堆安装好的工具包，比如：numpy、pandas等。 conda软件包 搜索我们基于云的资源库，查找并安装超过7500个数据科学和机器学习包。使用conda-install命令，您可以开始使用成千上万的开源Conda、R、Python和其他许多软件包。 管理环境 个人版是一个开源、灵活的解决方案，它提供了跨平台方式构建、分发、安装、更新和管理软件的实用工具。Conda可以轻松管理多个数据环境，这些环境可以单独维护和运行，互不干扰。 一、下载安装包 Anaconda安装包下载 官网可能速度比较慢，我在http://www.pc6.com/mac/842752.html下的 二、开始安装 一直下一步就行了 三、安装成功，设置conda环境变量 我这边不用配环境，默认配好了 查看验证 conda list conda常用操作命令 1、查看环境管理的全部命令帮助： 123conda env -h 或者conda 2、查看当前系统下的环境： 123conda info -e或者conda-env list 3、创建环境： 1conda create env_name 【注】 (env_name)是环境名称,这条命令创建一个新的环境，存储位置在安装文件的隐藏文件/.conda文件夹里面 创建指定python版本的环境： 1conda create env_name python&#x3D;3.6 4、激活进入某个环境 1activate env_name 5、退出某个环境： 1deactivate env_name 6、复制某个环境： 1conda create new_env_name old_env_name 7、删除某个环境： 1conda remove env_name 8、安装包： 12conda install xxxpip install xxx 9、指定的安装环境： 1conda install -n env_name 包名 10、查看已安装的包： 1conda list 11、查看指定环境下的包： 1conda list -n 环境名 12、查找包： 1conda search 包名 13、更新包： 1conda update xxx 14、安装anaconda发行版中所有的包: 1conda install anaconda 15、卸载包： 1conda remove xxx 三、管理conda 1、检查conda版本： 1conda -V # 大写V 2、升级当前版本的conda： 1conda update conda","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://panlianghnu.github.io/tags/python/"},{"name":"Anaconda","slug":"Anaconda","permalink":"https://panlianghnu.github.io/tags/Anaconda/"}]},{"title":"python简史","slug":"python简史","date":"2020-12-14T09:35:24.000Z","updated":"2020-12-14T09:37:44.000Z","comments":true,"path":"2020/12/14/python简史/","link":"","permalink":"https://panlianghnu.github.io/2020/12/14/python%E7%AE%80%E5%8F%B2/","excerpt":"","text":"本文作者：Vamei 出处：http://www.cnblogs.com/vamei Python是我喜欢的语言，简洁，优美，容易使用。前两天，我很激昂的向朋友宣传Python的好处。 听过之后，朋友问我：好吧，我承认Python不错，但它为什么叫Python呢？ 我不是很确定：呃，似乎是一个电视剧的名字。 朋友又问：那你说的Guido是美国人么？ (Guido von Rossum，Python的作者) 我再次不是很确定：他从google换到Dropbox工作，但他的名字像是荷兰人的 (有一个von在中间)。 所以，后面我花了些时间调查Python的历史。这是很好的学习。我看到了Python中许多功能的来源和Python的设计理念，比如哪些功能是历史遗留，哪些功能是重复，如何增加功能…… 而且，Python也是开源(open source)运动的一个成功案例。从Python的历史中，我们可以一窥开源开发的理念和成就。 Python的起源 Python的作者，Guido von Rossum，确实是荷兰人。1982年，Guido从阿姆斯特丹大学(University of Amsterdam)获得了数学和计算机硕士学位。然而，尽管他算得上是一位数学家，但他更加享受计算机带来的乐趣。用他的话说，尽管拥有数学和计算机双料资质，他总趋向于做计算机相关的工作，并热衷于做任何和编程相关的活儿。 在那个时候，他接触并使用过诸如Pascal、C、 Fortran等语言。这些语言的基本设计原则是让机器能更快运行。在80年代，虽然IBM和苹果已经掀起了个人电脑浪潮，但这些个人电脑的配置很低 (在今天看来)。比如早期的Macintosh，只有8MHz的CPU主频和128KB的RAM，一个大的数组就能占满内存。所有的编译器的核心是做优化，以便让程序能够运行。为了增进效率，语言也迫使程序员像计算机一样思考，以便能写出更符合机器口味的程序。在那个时代，程序员恨不得用手榨取计算机每一寸的能力。有人甚至认为C语言的指针是在浪费内存。至于动态类型，内存自动管理，面向对象…… 别想了，那会让你的电脑陷入瘫痪。 然而，这种思考方式让Guido感到苦恼。Guido知道如何用C语言写出一个功能，但整个编写过程需要耗费大量的时间 (即使他已经准确的知道了如何实现)。他的另一个选择是shell。Bourne Shell作为UNIX系统的解释器(interpreter)已经长期存在。UNIX的管理员们常常用shell去写一些简单的脚本，以进行一些系统维护的工作，比如定期备份、文件系统管理等等。shell可以像胶水一样，将UNIX下的许多功能连接在一起。许多C语言下上百行的程序，在shell下只用几行就可以完成。然而，shell的本质是调用命令。它并不是一个真正的语言。比如说，shell没有数值型的数据类型，加法运算都很复杂。总之，shell不能全面的调动计算机的功能。 (关于shell，你可以参考Linux架构和Linux命令行与命令) Guido希望有一种语言，这种语言能够像C语言那样，能够全面调用计算机的功能接口，又可以像shell那样，可以轻松的编程。ABC语言让Guido看到希望。ABC是由荷兰的CWI (Centrum Wiskunde &amp; Informatica, 数学和计算机研究所)开发的。Guido在CWI工作，并参与到ABC语言的开发。ABC语言以教学为目的。与当时的大部分语言不同，ABC语言的目标是“让用户感觉更好”。ABC语言希望让语言变得容易阅读，容易使用，容易记忆，容易学习，并以此来激发人们学习编程的兴趣。比如下面是一段来自Wikipedia的ABC程序，这个程序用于统计文本中出现的词(word)的总数： 1234567HOW TO RETURN words document: PUT &#123;&#125; IN collection FOR line IN document: FOR word IN split line: IF word not.in collection: INSERT word IN collection RETURN collection HOW TO用于定义一个函数。一个Python程序员应该很容易理解这段程序。ABC语言使用冒号(:)和缩进来表示程序块(C语言使用{}来表示程序块)。行尾没有分号。for和if结构中也没有括号()。如果将HOW TO改为def，将PUT行改为collection = []，将INSERT行改为collection.append(word)，这就几乎是一个标准的Python函数。上面的函数读起来就像一段自然的文字。 尽管已经具备了良好的可读性和易用性，ABC语言最终没有流行起来。在当时，ABC语言编译器需要比较高配置的电脑才能运行。而这些电脑的使用者通常精通计算机，他们更多考虑程序的效率，而非它的学习难度。除了硬件上的困难外，ABC语言的设计也存在一些致命的问题： 可拓展性差。ABC语言不是模块化语言。如果想在ABC语言中增加功能，比如对图形化的支持，就必须改动很多地方。 不能直接进行IO。ABC语言不能直接操作文件系统。尽管你可以通过诸如文本流的方式导入数据，但ABC无法直接读写文件。输入输出的困难对于计算机语言来说是致命的。你能想像一个打不开车门的跑车么？ 过度革新。ABC用自然语言的方式来表达程序的意义，比如上面程序中的HOW TO (如何)。然而对于程序员来说，他们更习惯用function或者define来定义一个函数。同样，程序员也习惯了用等号(=)来分配变量。这尽管让ABC语言显得特别，但实际上增加了程序员的学习难度 (程序员大都掌握不止一种语言)。 传播困难。ABC编译器很大，必须被保存在磁带(tape)上。当时Guido在访问的时候，就必须有一个大磁带来给别人安装ABC编译器。 这样，ABC语言就很难快速传播。 1989年，为了打发圣诞节假期，Guido开始写Python语言的编译/解释器。Python来自Guido所挚爱的电视剧Monty Python’s Flying Circus (BBC1960-1970年代播放的室内情景幽默剧，以当时的英国生活为素材)。他希望这个新的叫做Python的语言，能实现他的理念(一种C和shell之间，功能全面，易学易用，可拓展的语言)。Guido作为一个语言设计爱好者，已经有过设计语言的(不很成功)的尝试。这一次，也不过是一次纯粹的hacking行为。 Python的诞生 1991年，第一个Python编译器(同时也是解释器)诞生。它是用C语言实现的，并能够调用C库(.so文件)。从一出生，Python已经具有了：类(class)，函数(function)，异常处理(exception)，包括表(list)和词典(dictionary)在内的核心数据类型，以及模块(module)为基础的拓展系统。 最初的Python logo: 由Guido的兄弟Just von Rossum设计 Python语法很多来自C，但又受到ABC语言的强烈影响。来自ABC语言的一些规定直到今天还富有争议，比如强制缩进。但这些语法规定让Python容易读。另一方面，Python聪明的选择服从一些惯例(特别是C语言的惯例)。比如使用等号赋值，使用def来定义函数。Guido认为，如果“常识”上确立的东西，没有必要过度纠结。 Python从一开始就特别在意可拓展性(extensibility)。Python可以在多个层次上拓展。从高层上，你可以引入.py文件。在底层，你可以引用C语言的库。Python程序员可以快速的使用Python写.py文件作为拓展模块。但当性能是考虑的重要因素时，Python程序员可以深入底层，写C程序，编译为.so文件引入到Python中使用。Python就好像是使用钢构建房一样，先规定好大的框架。而程序员可以在此框架下相当自由的拓展或更改。 最初的Python完全由Guido本人开发。Python得到Guido同事的欢迎。他们迅速的反馈使用意见，并参与到Python的改进。Guido和一些同事构成Python的核心团队。他们将自己大部分的业余时间用于hack Python (也包括工作时间，因为他们将Python用于工作)。随后，Python拓展到CWI之外。Python将许多机器层面上的细节隐藏，交给编译器处理，并凸显出逻辑层面的编程思考。Python程序员可以花更多的时间用于思考程序的逻辑，而不是具体的实现细节 (Guido有一件T恤，写着：人生苦短，我用Python)。这一特征吸引了广大的程序员。Python开始流行。 我们不得不暂停我们的Python时间，转而看一看这时的计算机概况。1990年代初，个人计算机开始进入普通家庭。Intel发布了486处理器，windows发布window 3.0开始的一系列视窗系统。计算机的性能大大提高。程序员开始关注计算机的易用性 (比如图形化界面)。 Windows 3.0 由于计算机性能的提高，软件的世界也开始随之改变。硬件足以满足许多个人电脑的需要。硬件厂商甚至渴望高需求软件的出现，以带动硬件的更新换代。C和Java相继流行。C和Java提供了面向对象的编程范式，以及丰富的对象库。在牺牲了一定的性能的代价下，C++和Java大大提高了程序的产量。语言的易用性被提到一个新的高度。我们还记得，ABC失败的一个重要原因是硬件的性能限制。从这方面说，Python要比ABC幸运许多。 另一个悄然发生的改变是Internet。1990年代还是个人电脑的时代，windows和Intel挟PC以令天下，盛极一时。尽管Internet为主体的信息革命尚未到来，但许多程序员以及资深计算机用户已经在频繁使用Internet进行交流 (包括email和newsgroup)。Internet让信息交流成本大大下降。一种新的软件开发模式开始流行：开源 (open source)。程序员利用业余时间进行软件开发，并开放源代码。1991年，Linus在comp.os.minix新闻组上发布了Linux内核源代码，吸引大批hacker的加入。Linux和GNU相互合作，最终构成了一个充满活力的开源平台。 硬件性能不是瓶颈，Python又容易使用，所以许多人开始转向Python。Guido维护了一个maillist，Python用户就通过邮件进行交流。Python用户来自许多领域，有不同的背景，对Python也有不同的需求。Python相当的开放，又容易拓展，所以当用户不满足于现有功能，很容易对Python进行拓展或改造。随后，这些用户将改动发给Guido，并由Guido决定是否将新的特征加入到Python或者标准库中。如果代码能被纳入Python自身或者标准库，这将极大的荣誉。Python自身也因此变得更好。 (Guido不得不作出许多决定，这也是他被称为Benevolent Dictator For Life的原因) Python被称为“Battery Included”，是说它以及其标准库的功能强大。这些是整个社区的贡献。Python的开发者来自不同领域，他们将不同领域的优点带给Python。比如Python标准库中的正则表达(regular expression)是参考Perl，而lambda, map, filter, reduce函数参考Lisp。Python本身的一些功能以及大部分的标准库来自于社区。Python的社区不断扩大，进而拥有了自己的newsgroup，网站(python.org)，以及基金 (Python Software Foundation)。从Python 2.0开始，Python也从maillist的开发方式，转为完全开源的开发方式。社区气氛已经形成，工作被整个社区分担，Python也获得了更加高速的发展。 (由于Guido享有绝对的仲裁权，所以在Python早期maillist的开发时代，不少爱好者相当担心Guido的生命。他们甚至作出假设：如果Guido挂了的话，Python会怎样。见If Guido was hit by a bus) 到今天，Python的框架已经确立。Python语言以对象为核心组织代码(Everything is object)，支持多种编程范式(multi-paradigm)，采用动态类型(dynamic typing)，自动进行内存回收(garbage collection)。Python支持解释运行(interpret)，并能调用C库进行拓展。Python有强大的标准库 (battery included)。由于标准库的体系已经稳定，所以Python的生态系统开始拓展到第三方包。这些包，如Django, web.py, wxpython, numpy, matplotlib,PIL，将Python升级成了物种丰富的热带雨林。 今天Python已经进入到3.0的时代。由于Python 3.0向后不兼容，所以从2.0到3.0的过渡并不容易。另一方面，Python的性能依然值得改进，Python的运算性能低于C++和Java(见Google的讨论)。Python依然是一个在发展中的语言。我期待看到Python的未来。 Python启示录 Python崇尚优美、清晰、简单，是一个优秀并广泛使用的语言 (TIOBE语言排行第八，Google的第三大开发语言，Dropbox的基础语言，豆瓣的服务器语言)。这个世界并不缺乏优秀的语言，但Python的发展史作为一个代表，带给我许多启示。 在Python的开发过程中，社区起到了重要的作用。Guido自认为自己不是全能型的程序员，所以他只负责制订框架。如果问题太复杂，他会选择绕过去，也就是cut the corner。这些问题最终由社区中的其他人解决。社区中的人才是异常丰富的，就连创建网站，筹集基金这样与开发稍远的事情，也有人乐意于处理。如今的项目开发越来越复杂，越来越庞大，合作以及开放的心态成为项目最终成功的关键。 Python从其他语言中学到了很多，无论是已经进入历史的ABC，还是依然在使用的C和Perl，以及许多没有列出的其他语言。可以说，Python的成功代表了它所有借鉴的语言的成功。同样，Ruby借鉴了Python，它的成功也代表了Python某些方面的成功。每个语言都是混合体，都有它优秀的地方，但也有各种各样的缺陷。同时，一个语言“好与不好”的评判，往往受制于平台、硬件、时代等等外部原因。程序员经历过许多语言之争。我想，为什么不以开放的心态和客观的分析，去区分一下每个语言的具体优点缺点，去区分内部和外部的因素。说不定哪一天发现，我不喜欢的某个语言中，正包含了我所需要的东西。 无论Python未来的命运如何，Python的历史已经是本很有趣的小说。","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://panlianghnu.github.io/tags/python/"},{"name":"转载","slug":"转载","permalink":"https://panlianghnu.github.io/tags/%E8%BD%AC%E8%BD%BD/"}]},{"title":"MacOS安装python3并设置默认","slug":"MacOS安装python3并设置默认","date":"2020-12-14T09:17:12.000Z","updated":"2020-12-14T09:18:30.000Z","comments":true,"path":"2020/12/14/MacOS安装python3并设置默认/","link":"","permalink":"https://panlianghnu.github.io/2020/12/14/MacOS%E5%AE%89%E8%A3%85python3%E5%B9%B6%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4/","excerpt":"","text":"MacOS 安装Python3.8并设置为默认版本 1、安装Python版本管理工具 1brew install pyenv 2、添加环境变量（使用bash则添加环境变量到.bashrc 或.profile 或.bash_profile） 1echo &#x27;export PATH=&quot;$(pyenv root)/shims:$PATH&quot;&#x27; &gt;&gt; ~/.zshrc 1source ~/.zshrc 3、安装Python版本 1pyenv install 3.8.5 4、设置默认版本（以后切换也用这个） 1pyenv global 3.8.5 5、检查Python版本 1python -V","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://panlianghnu.github.io/tags/python/"},{"name":"MacOS","slug":"MacOS","permalink":"https://panlianghnu.github.io/tags/MacOS/"}]},{"title":"Coder - 语言快速上手","slug":"Coder-语言快速上手","date":"2020-12-14T03:29:44.000Z","updated":"2020-12-14T03:32:21.000Z","comments":true,"path":"2020/12/14/Coder-语言快速上手/","link":"","permalink":"https://panlianghnu.github.io/2020/12/14/Coder-%E8%AF%AD%E8%A8%80%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/","excerpt":"","text":"Coder - 语言快速上手 图灵完备： 有的语言不是图灵完备的：比如 windows 的 bat 批处理语言、Linux 的 shell、html。只能处理一些自动化的东西 图灵完备的语言： 能控制数据、有输入输出、有逻辑处理等。所有图灵机能做的事情、都能用这个语言实现。图灵完备的语言可以互相替代，但是不一样的语言有不一样的优势 快速学习一门语言： 先了解这个语言的来历、原因、特点、开发环境 程序逻辑：变量定义、程序员的约定（驼峰等）、顺序语句、循环分支（看懂其他、自己会写一种就行）、try catch 变量加深理解 强类型弱类型 c弱类型（比如打印时需要指定%d、正确使用类型靠程序员自己） python强类型（通过 var a = ‘a’，编程语言就知道它是一个字符） 动态类型 （声明变量时不用指定类型）比如python、go、swift 静态类型 （声明变量时需要指定类型） 值类型 （基本类型） 在栈里面直接定义变量（C/C++几乎全是值类型） 引用类型 （封装类型） 有的语言所有的变量都是引用（python和js几乎都是引用类型） 值类型和引用类型（影响 == ），但是有的引用类型语言处理了== 时间和日期（如何处理、保存、计算、格式、方法） 字符串： 理解内存 可变不可变 java有字符串常量池（有时候string a == b 是可以的） 正则表达式（匹配模式） 容器类型：各种方法、遍历、删除、复制（深浅）、容器序列化（xml、） 可以上项目 编程语言的抽象方法、类（继承封装多态）、接口、函数 可以写设计模式 函数式编程的特性 熟练度、生态、包管理工具（pip等） 语言的高级功能：比如 java 的高性能并发、网络支持、磁盘管理、携程等 professional 训练任务： 完成一个支持消息循环的交互程序： 运行后不结束 标准输入输出 单线程就行 不需要UI 文字版RPG小游戏、需要6步以上的剧情 第二个编程语言： 精细控制 对二进制位进行操作 凯撒密码对数据加密 输入加密的移位 输入加密字符串 生成加密的字符串（支持重定向） 还能解密 做一个解密程序（破解凯撒密码、不知道加密的移位）。需要自己判断正确的字符串","categories":[],"tags":[{"name":"Language","slug":"Language","permalink":"https://panlianghnu.github.io/tags/Language/"}]},{"title":"Git 学习笔记","slug":"Git-学习笔记","date":"2020-12-13T12:58:37.000Z","updated":"2020-12-14T10:22:13.000Z","comments":true,"path":"2020/12/13/Git-学习笔记/","link":"","permalink":"https://panlianghnu.github.io/2020/12/13/Git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"Git 学习 以往的 version control 是记录补丁（RCS），记录新文件和上一个文件的变化（比如新增了一行aaa、删除了一行bbbb），从而保证版本控制，可以回退，但是这样的 version control 只能管理文本，不能管理多媒体等其他文件 Git 不一样，每一次提交的文件，都是保存完整的文件，Git 版本库拥有每个版本文件的快照（SNAP），切换速度非常快，除了管理代码外，还可以管理多媒体等文件 集中化的版本控制 让不同系统上的开发者协同工作 有一个单一的集中管理的服务器，保存所有文件的修订版本，大家从这台服务器拉取文件，或者提交更新 好处： 大家都能在一定程度上看到别人在做什么 管理一个CVCS比每个客户端都维护一个本地数据库来得容易 坏处： 单点故障 分布式版本控制 客户端不止提取最新版本的文件快照，而是把代码仓库完整地镜像下来，包括完整的历史记录 每一次的克隆，其实都是对代码仓库的完整备份 避免了单点故障，也不需要维护一个中央服务器 可以在同一项目中和不同的工作小组的人协作 Git 是一个分布式的版本管理系统 Git 特点 直接记录快照，而非差异比较（每当提交更新或者保存项目状态时，就会对当时的全部文件创建一个快照，并保存这个快照的索引。为了效率，没有修改的文件不会重新存储，而是保留一个链接指向之前存储的文件） 近乎所有操作都是本地执行（快！）没有网络延迟 保证完整性，类似区块链，所有数据保存时都计算哈希，并且以哈希来引用！（SHA-1） 几乎只有添加数据，（删除其实也是提交一个快照，所以我之前的阿里云密钥现在还在给我发段信！！！） 三种状态：committed、modified、staged committed：表示数据已经保存在本地数据库中 modified：表示数据已经修改、但还没有保存到数据库中 staged：表示对一个已修改的文件的当前版本作了标记，使之包含在下次提交的快照中（类似暂存吧） 三个阶段：工作区、暂存区、Git 目录 工作区是项目的某个版本的内容，提取出来放在磁盘上供你修改 暂存区是一个文件，保存下次将要提交的文件列表信息，一般在.git里面 Git 仓库目录：.git 文件夹，保存Git 的元数据和对象数据库，克隆就是克隆这个 Git 基本工作流程 1、在工作区中修改文件 2、将想下次提交的更改选择性地暂存（别把配置文件提交！！！） 3、提交更新，将快照永久性地存储到 Git 目录 建立Git 仓库 git init git clone ( git clone 会复制所有的版本，然后将最新版本的文件放在工作区) Git add 没有被 add 的文件，Git 会忽略它 所有被 Git add 的文件都会有副本 git add 是一个多功能命令 没有被追踪的文件，使用 git add 会让 git 将这个文件加入管理范畴 已经追踪的文件，使用 git add 会将该文件放到暂存区 合并时，使用 git add 可以把有冲突的文件标记为已解决 可以理解为将内容添加到下一次提交中 当你修改了文件并且 git add 后，保存在暂存区，之后又修改了这个文件 再次查看 git status 可以看到这个文件同时出现在 to be committed 和 not staged 所以，git add 并不是添加这个文件，而是添加的 SNAP （当时的文件） git add 之后的修改并没有添加到暂存区 Git ignore 我们想要忽略一些编译文件、日志文件等，又不想让他总提示我没追踪，就要git忽略它 编写一个文件 .gitignore 文件 .gitignore 的格式规范如下： 所有空行或者以 # 开头的行都会被 Git 忽略。 可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中。 匹配模式可以以（/）开头防止递归。 匹配模式可以以（/）结尾指定目录。 要忽略指定模式以外的文件或目录，可以在模式前加上叹号（!）取反。 所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。 星号（*）匹配零个或多个任意字符；[abc] 匹配任何一个列在方括号中的字符 （这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）； 问号（?）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符， 表示所有在这两个字符范围内的都可以匹配（比如 [0-9] 表示匹配所有 0 到 9 的数字）。 使用两个星号（）表示匹配任意中间目录，比如 a//z 可以匹配 a/z 、 a/b/z 或 a/b/c/z 等。 一个仓库可能只根目录下有一个 .gitignore 文件。 然而，子目录下也可以有额外的 .gitignore 文件。子目录中的 .gitignore 文件中的规则只作用于它所在的目录中。 Git diff git status 只能看到文件当前的状态 使用 git diff 查看： 当前做的哪些更新尚未暂存？ 有哪些更新已暂存并准备好下次提交？ 只是使用文件补丁的格式给你展示，并不是底层使用文件补丁实现 git diff 不加参数，比较的是工作目录中当前文件和暂存区快照的差异 git diff --staged ，比较的是暂存区快照和最后一次提交的文件的差异 经常 git add 之后 git diff 没有信息就是这个原因 Git commit 只会提交已经 add 的文件作为快照 git commit -a ：将所有已经跟踪的文件一并提交（跳过 add 过程） 这很方便，但是很有可能会提交一些你不想提交的文件（比如说配置文件） git commit --amend : 上次提交漏掉了几个文件（马上git add）、或者提交信息写错了，用这个命令 123git commit -m &quot;asd&quot;git add forgotten_filegit commit --amend 最终只会有一个提交 移除文件 从 Git 中移除某个文件，就需要将它移出跟踪文件清单（也是从暂存区移出） git rm ： 连带着在工作区也删除了（因为工作区只是 .git 的一个版本快照） 如果只是在工作目录删除文件，那只会作为一次操作记录，会出现 Changes not staged for commit 如果要删除之前修改过、已经放到暂存区的文件，需要使用 git rm -f ， 这样的数据不能被 Git 恢复 删除 git 暂存区的文件 而保留在磁盘： git rm --cached README 移动文件 （不重要） git mv file_from file_to git mv 相当于下面三个命令： mv file1 file2 git rm file1 git add file2 查看提交历史（重要） git log ： -n 显示最近 n 次提交 -p 按照补丁格式显示统计信息 –stat 显示简略统计信息 –pretty(很有用)，比如 git log --pretty=oneline ， 将信息展示为一行 –pretty=format 还有很多种参数 撤销操作（重要） 一、取消暂存的文件： 不同的版本不一样，git status 会提示你，怎么取消暂存，我这边是 git restore --staged 二、撤销对文件对修改： 不同的版本不一样，git status 会提示你，怎么取消修改，我这边是 git restore file 12“这是一个危险的命令。 你对那个文件在本地的任何修改都会消失Git 会用最近提交的版本覆盖掉它。 除非你确实清楚不想要对那个文件的本地修改了，否则请不要使用这个命令。” Git 中任何 已提交 的东西几乎总是可以恢复 远程仓库使用（重要） 并不一定是 github 或者 gittee 才是远程仓库，任何不在本地的 git 仓库都是远程仓库 12git remote &#x2F;&#x2F; 查看已经配置的远程仓库git remote -v &#x2F;&#x2F; 查看简写以及URL，会全部列出 查看远程仓库 1git remote show &lt;remote&gt; (常用) 可以看到远程有两个分支、一个main一个master 添加远程仓库 1git remote add &quot;shortname&quot; &quot;url&quot; fetch 和 pull（重要） git fetch remote 会访问远程仓库，拉取所有你还没有的数据。拉取完后，会拥有所有分支的引用 如果 clone 了一个仓库，会自动添加远程仓库，默认为 origin git fetch origin 会抓上一次抓取后新的推送的所有工作 fetch 只会将数据下载到本地仓库，而不会自动合并 pull 在抓取数据后会尝试直接合并分支 ，git pull 会从最初克隆的服务器上抓取数据并自动尝试合并 git pull 相当于三条命令 1234git pull&#x2F;fetch &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; (常用)git fetch origin master:tmp &#x2F;&#x2F; 从远程拉一个分支到tmp分支git merge tmp &#x2F;&#x2F; 尝试合并当前分支和tmp分支git branch -d tmp &#x2F;&#x2F; 删除tmp分支 pull 自带的merge 不是很好用（有时候会发生错误），建议还是 git fetch origin master:tmp push 1git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt; 如果省略远程分支名，则表示将本地分支推送与之存在&quot;追踪关系&quot;的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。 1git push origin master push 前一定要先抓取、消除冲突，再 push。开始工作前也 fetch 一下，在最新的版本上开发 git tag git tag 命令查看所有标签 也可以 git tag -l “v1.8*” 列出所有版本号为1.8开头的版本 git 有两种标签： 轻量标签：只是某个特定 commit 的引用 git tag v1.4 附注标签：是Git 数据库中的一个完整对象，是可以被校验的，包含打标签的人的名字、邮箱、日期、还可以签名验证 、 创建附注标签很简单 git tag -a v1.4 -m ”my version 1.4“ 标签要另外push才会到远程 1git push origin v1.1 注意⚠️：tag 是和某个 commit 直接绑定的，而非 branch 所以你切换分支了，还是可以看到这个 tag（ git show v1.2 ) 所以你推到远程去， 不需要指定分支 而是直接 push origin v1.2 版本回滚（重要） 首先通过 git log 或者 git tag 查看 xxx git reset --hard xxx ( xxx为某个 commit 的hash 或者某个 tag ) 回滚后看不到 git log 了怎么办？( tag还是能看见 ) git reflog git 分支（重要） 将每个commit 理解为链表的节点、就很容易理解分支了 HEAD 指针，指向当前所在的本地分支，HEAD指向master，你就在master分支上 其实所有的 HEAD、master、dev、都是一个指向commit 的指针，只是不同的分支向不同的方向延续 git switch 切换分支、会改变你的工作目录 这种情况如果修改了同一个文件，merge会冲突，这个时候需要手动解决冲突，再 add 、 commit git branch 查看（新建）分支（基本命令） git branch -d 删除分支 稳定分支的指针总是在提交历史中落后一大截，而前沿分支的指针往往比较靠前。 删除远程分支： 12git push origin --delete serverfixTo https:&#x2F;&#x2F;github.com&#x2F;schacon&#x2F;simplegit 变基 整合分支最容易的就是 merge 命令，会将两个分支的最新快照、以及二者的最近共同祖先，三者合并，生成新的 commit 还有一种合并的方法： 变基： git switch c4 \\ git rebase c5 将 C4 的修改 按顺序应用到 C5 提取C4的补丁和修改、在C3的基础上再应用一次 结果都是一样，但是变基使得提交历史更加整洁 变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起 变基的风险： 如果提交存在于你的仓库之外，而别人可能基于这些提交进行开发，那么不要执行变基 大厂实际工作中 Git 流程 master 永远是正常稳定可用的主干分支 拉出一个 dev 分支，check out from master （master镜像）、类似防火墙 dev 是所有开发小组的一个共用分支 但是如果开发人员都向dev 提交，会频繁发生冲突 所以开发人员各再拉分支 开发人员要提交到dev之前，小组内先合一下 测试人员一般从 dev 拉代码测试、没问题了之后，运维把 dev 合并到 master 从 master 拉一些 Tag 、 Release 发布小更新 、 feature（加一些新的东西、不想影响原来的东西） git 5、6成的时间都在解决冲突 大厂还有专门的 CMO ：配置管理员：解决各种冲突","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://panlianghnu.github.io/tags/git/"}]},{"title":"操作系统原理与程序逻辑训练","slug":"操作系统原理与程序逻辑训练","date":"2020-12-13T12:57:34.000Z","updated":"2020-12-14T10:21:16.000Z","comments":true,"path":"2020/12/13/操作系统原理与程序逻辑训练/","link":"","permalink":"https://panlianghnu.github.io/2020/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E7%A8%8B%E5%BA%8F%E9%80%BB%E8%BE%91%E8%AE%AD%E7%BB%83/","excerpt":"","text":"C语言和操作系统的交互 C语言的main函数其实就是和操作系统的交互之一，执行程序前，操作系统将程序的二进制可执行代码加载到内存的代码段，同时会把函数名为main的函数作为程序的入口 Linux 的终端里： 命令1 &amp;&amp; 命令2 表示先执行命令1，成功了再执行命令2，如果命令1执行错误则不会执行命令2 小技巧：可以用 echo $? 查看上一个命令执行的返回值 而C语言的 int main() 需要有一个int 类型的返回值，这也涉及到和Linux 操作系统的交互 return 0 不是乱写，而是代表执行成功，程序正常退出，操作系统可以获得main 函数的返回值，通过 echo $? 打印到终端，通过main 函数的返回值，操作系统可以执行不同的逻辑 C语言的int main(int argv,char * argc[]) ，参数从终端读参数， argv代表参数个数，argc代表参数列表 这些是操作系统和C语言的交互 经典程序 1234567#include &lt;stdio.h&gt;int main(int argc,char* argv [])&#123; int i; for(i=0;i&lt;argc;i++) printf(&quot;argc[%d] is %s\\n&quot;,i,argv[i]); return 0;&#125; 这个程序可以很直观的看到Linux 在调用C语言程序时，传入的各个参数 Linux 标准输入输出流、错误流 stdin stdout stderr stdin : 默认是键盘输入，可以通过流的重定向改变输入流 stdout：默认是显示器输出，也可以重定向到网卡、打印机等 stderr：错误流 echo $? 命令可以打印出当前程序的返回值 流在Linux 系统里被抽象成一个个文件，比如我要往打印机写东西，我就会打开“打印机”这个文件，往里面写东西 每启动一个包含&lt;stdio.h&gt;的程序，Linux会默认打开 stdin\\ stdout\\ stderr这三个文件 比如 : printf(“hello”) = fprintf(stdout,“hello”) scanf(&quot;%d&quot;,&amp;a) = fscanf(stdin,&quot;%d&quot;,&amp;a) fprintf(stderr, “the value must &gt; 0”) 输出到 stderr 默认也是显示器，我以前在DevC++里输出到stderr， 是输出红色字体，ubuntu的终端好像没有对这个stderr进行特殊标记，只能通过重定向或者 echo $? 来知道确实是发生了错误 Linux 流的重定向 0 是标准输入流 1 是标准输出流 2 是标准错误流 ./a.out 1&gt;&gt; a.txt 代表对a.out 这个程序的 标准输出流 重定向 到 a.txt （1可以默认不写） 12345#include &lt;stdio.h&gt;int main()&#123; printf(&quot;hello world&quot;); return 0;&#125; 可以看到 ls -l 的信息被输出到了文件 b.txt 其实双箭头和单箭头都可以作为流的重定向，他们有小小的区别 双箭头不会覆盖文件，会在文件末尾写值 单箭头则会覆盖文件 ./a.out &gt; a.txt &lt; 是标准输入流的重定向 这三个重定向是可以组合使用的 Linux 管道 | 表示管道 比如： ls /etc/ | grep ab 表示，将 ls 产生的标准输出流，通过管道，传递给 grep（文本搜索的小程序）的标准输入流 看看实际操作： 这就是grep 搜索 ls 的结果，找出结果里包含ab的行，输出到标准输出流 这就是grep 搜索 ps 的结果，找出结果里包含ssh的进程，输出到标准输出流 Linux 管道实战 两个程序，一个输出sum和count，一个通过sum和count求平均值 这两个程序可以直接通过管道相连，让第一个程序的输出进入下一个程序的标准输入 这次直接输出来的是平均数 很简单的将两个独立小工具变成更加复杂的工具使用 Make 学习 在代码目录下 编写Makefile 文件 # 代表注释 hello.out: max.o hello.c #这行代表hello.out 需要max.o 和 hello.c 两个文件 gcc max.o hello.c -o hello.out # 这行必须以table开头，表示实际的gcc命令 max.o: max.c gcc -c max.c 可以看到我的Makefile 里定义了main.out 和 compute.o 的编译方式，为了调试方便我加了 -g 现在make 试一下 可以看到运行make 后，生成了 main.out compute.o 运行也是没有问题的 为什么使用make？ 使用make ，可以让大型程序在小部分代码改动时，不至于全部重新编写 make 会在Makefile文件中查询需要的文件是否已经有了，如果某部分文件已经存在则会跳过 make可以大大的节省编译时间（已经编译了不需要重新编译的文件 make 会帮我们跳过），并且Makefile写好各文件的依赖规则，每次编译都能方便程序员直接调用（大型项目自己写gcc不可想象） GDB 调试 先编译时加 -g 参数 执行 gdb ./main.out b 12 标记断点 l 输出源代码 n 下一步 s 单步进入 p 打印参数数据、地址、函数等 bt 打印堆栈 f 进入栈帧 函数指针 指向函数的指针变量。 因此“函数指针”本身首先应是指针变量，只不过该指针变量指向函数。这正如用指针变量可指向整型变量、字符型、数组一样，这里是指向函数。C在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。有了指向函数的指针变量后，可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样。 函数指针有两个用途：调用函数和做函数的参数 &amp;a 是 得到a的地址 p 打印一个 x/3d 打印三个整数 x/3cb 打印三个字符，b是一个个打印 回调函数： 在调用一个函数（A函数）时，传入一个函数指针（B函数）作为参数，在A函数运行期间，调用了B函数，那么这就是一个回调。回调函数可以帮助我们实现很多功能 比如 C语言标准库就为我们实现了快速排序，但是标准库的快速排序它并不知道你要排序的数据是整数、还是字符，甚至是自己定义的结构体，如果是基本类型还好说，但如果是你要对自己定义的结构体排序的话，它并不知道你的结构体是如何进行排序的，这个时候你需要把排序的定义告诉它，即你需要实现一个比较大小的函数，将这个函数作为参数传递给这个标准库函数。这时就可以调用快速排序为你的结构体排序了。 可以看到有了回调，我们就不需要关心快速排序实现的细节，只需要将我们定义的比较函数传给排序函数，就可以帮助我们实现快速排序。 操作系统内存管理 如图所示：操作系统内核使用的是高地址段，代码段是最低的地址段 系统内核是不允许被其他进程修改的 代码段用于保存运行的各个程序的二进制代码 代码段上面是数据段，用来存储一些全局变量、常量、字符串等 堆 数据段上面是堆内存空间，是程序动态申请的内存空间，堆内存比较大，所以程序如果要申请一个大数组什么的，需要调用malloc来申请一片堆内存，堆内存是需要自己去释放的（C语言），Java、go等语言有垃圾回收，不需要程序员来手动回收 栈 栈内存用于维护程序运行时环境，每调用一个函数，即会开辟一个新的栈帧（所以在递归调用时，如果递归深度太高会产生巨大的空间复杂度，甚至会出现段错误，核心转储 每个栈帧都有两个寄存器，一个栈指针寄存器（ESP寄存器，指向栈顶），一个栈的基地址（EBP，指向栈的底部），当然栈是往下长的，EBP的地址会大一些 每次调用函数即会在栈帧底部保存一个返回值（EBP的值），然后向下新开辟一个栈帧（让EBP往下指，ESP=EBP - 栈大小），(push ebp) (mov ebp, esp) 然后栈内存记录函数里新定义的各个变量 函数执行完，返回的时候，mov esp,ebp， 让esp = ebp，再pop ebp，栈顶弹出之前保存的返回值给ebp，这样就回到了上一个栈帧，返回值一般是eax寄存器传递 程序调用时内存变化 当操作系统调用执行一个程序时 将二进制代码（text）放入代码段 将二进制程序的常量、字符串、全局变量等 放入数据段 根据代码段，新开辟栈帧用于维护运行时环境，然后cpu根据PC寄存器取指令，执行指令 终端执行一个 ./main.out 时，函数的调用流程： 用户在终端敲击回车时，会触发CPU的中断，CPU会保存当前程序的各种寄存器的值，保存栈帧的信息等，放入进程结构体中（内存），操作系统陷入内核态，根据中断向量表和中断编号，找到对应的中断处理函数，发现现在要调用一个程序，于是操作系统将程序二进制可执行代码载入内存的代码段，常量、字符串等载入内存的数据段，为该程序申请时间片，把程序的状态修改为就绪状态，当程序执行时，新开辟（或者从进程结构体中读取之前的）栈帧，执行代码段段二进制代码 抽象 昨天写了一些简单程序设计，打印正方形、空心正方形、等腰三角形、空心菱形、“回”字等 很久没写过这种程序了。。。刚开始写正方形、三角形都还好，基本上写一遍就过了，不会一直调试，反复测试才能过。后面到了复杂的菱形、“回”字，就需要大量的调试，不断的设计 i、j 的值。让 i、j、num这三个变量组成一个线性函数，设计一个二维的矩形 但是龙哥让我们把一些重复劳动抽象出来 比如写一个 printChar(char ch, int n) ; 打印 n 个字符，这个简单的函数就大大地提升了我们的开发效率，让我们不需要将注意力集中在打印几个字符上，我们只需要关注这个图形的规律，第几行先打印几个空格，再打印几个字符即可 程序设计确实应该是一个不断抽象的过程，如果main 函数里的每一行代码都设计到最后的结果，那以后再来看这份代码又看不懂了。开发的时候应该逻辑更清晰一些，哪几行代码干了什么事，什么函数负责干什么，main 函数里只负责很宏观的事情，实现细节应该抽象出来","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https://panlianghnu.github.io/tags/linux/"},{"name":"c语言","slug":"c语言","permalink":"https://panlianghnu.github.io/tags/c%E8%AF%AD%E8%A8%80/"}]},{"title":"2020-12-4-学习笔记","slug":"2020-12-4-学习笔记","date":"2020-12-13T12:57:04.000Z","updated":"2020-12-14T06:24:45.000Z","comments":true,"path":"2020/12/13/2020-12-4-学习笔记/","link":"","permalink":"https://panlianghnu.github.io/2020/12/13/2020-12-4-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"处理器的架构不断变化 X86架构是通用指令集，X86的芯片也是通用芯片 即这个芯片可以完成各种其他架构芯片的任务，比如作为鼠标芯片、路由器芯片、交换机芯片等 ARM架构是精简指令集、功耗低、速度快、手机上和苹果M1芯片是ARM架构 磁盘阵列 磁盘阵列就是把几个盘组合起来，操作系统读出来是一个盘，但底层是好几个盘 RAID0: 操作系统对磁盘的读写在两个盘同时进行，数据被分片在两个盘分开存储，读写速度几乎翻倍，容量不变（还是两个盘的大小） RAID1:操作系统对磁盘的读写会被镜像一次，相当于另一个盘作为实时备份，这样两个盘变成一个盘，速度不变，容量减半（两个盘读出来只有一个盘的大小），大大的增加了系统的可靠性，数据损坏可以实时恢复，甚至一个盘坏了还能换一个新盘用 RAID10（不是十）：四个盘变成一个盘，把RAID0和RAID1结合起来 负载均衡 集群（今天是简单集群，不是分布式集群） 服务器对外提供服务时，服务器承受的压力随着用户的增加而增加，对服务器的性能要求也会不断上升，提升服务器性能的方式有两种，一种垂直扩容，一种平行扩容 垂直扩容 升级CPU、内存等 好处：简单、最稳定，源代码不需要修改可以直接获得性能提升 坏处：花钱多，性能提升一倍、业务负载并不能提升一倍（OS对硬件管理开销增加、散热问题等） 同时服务器也不可能无限升级 平行扩容 比较麻烦，需要负载均衡 很多种负载均衡： 轮询（默认） 比如：DNS服务器的域名轮询解析 （dns port 缓存用户的session id，让他每次访问统一服务器，就会话维持），但是数据库不能轮询， F5负载均衡器，类似NAT一样接一端外网，一端接很多服务器，可用性高，安全性也高，服务器不会被直接攻击，以前比较贵，现在比较便宜了 LVS负载均衡，linux服务器作为负载均衡 nginx反向代理（实验），中小企业最常用，C语言实现，可以承载比tomcat 多10几倍的并发请求 今天先不写了，晚安","categories":[],"tags":[{"name":"分布式","slug":"分布式","permalink":"https://panlianghnu.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"nginx","slug":"nginx","permalink":"https://panlianghnu.github.io/tags/nginx/"}]},{"title":"Linux 安装时的一些坑","slug":"Linux-安装时的一些坑","date":"2020-12-13T12:56:08.000Z","updated":"2020-12-14T06:26:26.000Z","comments":true,"path":"2020/12/13/Linux-安装时的一些坑/","link":"","permalink":"https://panlianghnu.github.io/2020/12/13/Linux-%E5%AE%89%E8%A3%85%E6%97%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/","excerpt":"","text":"Linux 安装时分区的挂载问题 Linux 单独挂载 /boot。可以单独更新内核，不怕更新内核丢失数据 Linux 单独挂载/swap。 Swap分区会在内存不够时，作为虚拟内存使用（但速度很慢），现在内存一般都够了，这个分区是否单独挂载就无所谓了。 有的古老的应用可能对内存小的机器有优化，有的变量内存需求比较高或者不常用，因而故意取一个很大的地址（让操作系统分配不了这么大的内存地址，从而分配一个虚拟内存），这样的软件如果没有挂载swap分区是有可能跑不起来的 Linux 单独挂载/var 。 默认tomcat、navicat等应用的日志文件放在这里，单独挂载可以在日志快满时换一个盘来，不至于丢失用户日志数据，并且可以热插拔 Linux单独挂载/opt 。 可以建议自己写的程序放在/opt，非必须 Linux单独挂载/usr 。 方便备份软件 Linux单独挂载/user 。 方便备份用户数据 BIOS、EFI的区别 主板使用BIOS还是EFI，对Linux 启动盘的制作有很大影响！ BIOS 是简单输入输出系统 是固化到计算机主板上一个ROM上的程序 当计算机启动时，CPU会加载ROM上的程序 BIOS 完成机器的自检后，会扫描硬盘，读取硬盘特定位置的操作系统引导程序（操作系统自举程序），引导程序启动操作系统的各程序 BIOS的功能非常简单，对于操作系统来说，如果主板使用的是BIOS，那么操作系统就必须面对所有的硬件，大到主板显卡，小到鼠标键盘，每次重装系统或者系统升级，都必须手动安装新的驱动 BIOS 主板的系统，虽然攻击者不知道系统盘中操作系统的密码进不了系统，但是可以通过插入一个U盘进入系统，如果其他磁盘没有其他加密手段的话，攻击者可以轻易窃取其他磁盘的数据 UEFI全称Unified Extensible Firmware Interface，即“统一的可扩展固件接口” UEFI是一个微内核系统，具有操控所有硬件资源的能力 可以在里面进行各种设置，比如安全设置，用户用U盘启动系统，只能查看自己U盘里的数据，不能对别的盘进行操作 用户可以进入一个类似shell 的环境，调入执行任何UEFI 程序，可以是自检程序、可以是操作系统引导软件等 Mac 的UEFI 甚至可以在里面驱动网卡、连接投影仪，在UEFI里的各种操作可以直接投影出去 UEFI 的u盘启动盘一般可以兼容BIOS，即使主板只有BIOS，也可以 UEFI 引导进系统，但是当你u盘拔了，可能又进不了系统了 ， 所以制作启动盘的时候一定要注意主板型号（大部分服务器主板较老还是用的bios）","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https://panlianghnu.github.io/tags/linux/"},{"name":"操作系统","slug":"操作系统","permalink":"https://panlianghnu.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"bios","slug":"bios","permalink":"https://panlianghnu.github.io/tags/bios/"}]},{"title":"Linux常用命令","slug":"Linux常用命令","date":"2020-12-13T12:55:30.000Z","updated":"2020-12-15T12:36:08.000Z","comments":true,"path":"2020/12/13/Linux常用命令/","link":"","permalink":"https://panlianghnu.github.io/2020/12/13/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"Linux 常用命令 Linux 命令太多，很多命令又有很多参数，不常用的命令是很容易忘记的，做一个备忘 参考的博客链接 显示目录和文件的命令 Ls：用于查看所有文件夹的命令。 ls -l，显示详细信息（常用） Tree： 以树状图列出目录内容（需要apt install tree) Du：显示目录或文件大小 ，查看磁盘信息 修改目录，文件权限和属主及数组命令 Chmod：用于改变指定目录或文件的权限命令。 Chown：用于改变文件拥有属性的命令。 Chgrp：用于改变文件群组的命令。 Chattr：用于设置文件具有不可删除和修改权限。 Lsattr：用于显示文件或目录的隐藏属性。 创建和删除目录的命令 Mkdir：用于创建目录 Rm -f：用于删除目录 创建和删除，重命名，复制文件的命令 Touch：创建一个新的文件 Vi:创建一个新的文件 Rm：删除文件或目录 Mv：重命名或移动文件的命令 Cp：复制命令 Scp：用于将本地的文件或目录复制到远程服务器 Wget：用于下载ftp或http服务器文件到本地。 ##显示文件内容的命令 Cat：用于显示指定文件的全部内容 More：用分页的形式显示指定文件的内容 Less：用分页的形式显示指定文件的内容，区别是more和less翻页使用的操作键不同。 Head：用于显示文件的前n行内容。 Tail：用于显示文件的后n行内容。 Tail -f：用于自动刷新的显示文件后n行数据内容。 查找命令 Find：查找指定目录或文件的命令。 Whereis：查找指定的文件源和二进制文件和手册等 Which：用于查询命令或别名的位置。 Locate：快速查找系统数据库中指定的内容。 Grep：在指定的文件或标准输出，标准输入内，查找满足条件的内容。 关机和重启计算机的命令 Shutdown：-r 关机后立即重启（reboot now 也行） 123-k 并不真正的关机，而只是发出警告信息给所有用户 -h 关机后不重新启动 Poweroff：用于关机和关闭电源 Init：改变系统运行级别 123456789101112130级用于关闭系统1 级用于单一使用者模式2级用来进行多用户使用模式（但不带网络功能）3级用来进行多用户使用模式（带网络全功能）4级用来进行用户自定义使用模式5级表示进入x windows时的模式6级用来重启系统 Reboot： 用于计算机重启 Halt：用于关闭计算机系统 压缩和打包命令 Tar：用于多个文件或目录进行打包，但不压缩，同时也用命令进行解包 123456789101112131415-A 新增压缩文件到已存在的压缩-c 建立新的压缩文件-d 记录文件的差别-r 添加文件到已经压缩的文件-u 添加改变了和现有的文件到已经存在的压缩文件-x 从压缩的文件中提取文件-t 显示压缩文件的内容-z 支持gzip解压文件-j 支持bzip2解压文件-Z 支持compress解压文件-v 显示操作过程-l 文件系统边界设置-k 保留原有文件不覆盖-m 保留文件不被覆盖-W 确认压缩文件的正确性 用户操作命令 Linux用户在操作系统可以进行日常管理和维护，涉及到的相关配置文件保存在 /etc/ Su：切换用户命令 Sudo：一系统管理员的身份执行命令 Passwd：用于修改用户的密码 adduser：用于创建新用户，同时会创建该用户的组，默认用户a属于主组a，还会创建用户的默认home目录等信息 deluser：用于删除用户，删除用户后home目录并不会主动删除，需要手动再删除 三个change chmod ， 修改文件权限：rwxrwxrwx，比如 chmod 777 a.txt 打开a的所有权限 chgrp ， 修改文件或文件夹所属的组。 比如chgrp group1 a .txt 让a属于group1 chown， 修改文件或文件夹的所有者。 比如chown user1 a.txt 让a属于user1 改变目录和查看当前目录命令 Cd：进入工作目录 Cd …：会退到上一级命令 Pwd：显示当前用户所在工作目录位置 文件连接命令 Ln：为源文件创建一个连接，并不将源文件复制一份，即占用的空间很小。 123可以分为软件连接和硬链接。软连接：也称为符号连接，即为文件或目录创建一个快捷方式。 硬链接：给一个文件取多于一个名字，放在不同目录中，方便用户使用。 Ln命令参数如下： 12345678910111213-f：在创建连接时，先将与目的对象同名的文件或目录删除。-d：允许系统管理者硬链接自己的目录。-i：在删除与目的对象同名文件或目录时先询问用户。-n：在创建软连接时，将目的对象视为一般的文件。-s：创建软连接，即符号连接。-v：在连接之前显示文件或目录名。-b：将在连接时会被覆盖或删除的文件进行备份。 其他命令 Ps：显示瞬间进程的动态 Date：显示或设定系统的日期与时间。 Kill： 杀死一些特定的进程 Logout：退出系统 Clear：清屏 Passwd：设置用户密码 vi编辑器 首先用vi命令打开一个文件 末行模式命令： :n,m w path/filename 保存指定范围文档（ n表开始行，m表结束行） :q! 对文件做过修改后，强制退出 :q 没有对文件做过修改退出 Wq或x 保存退出 dd 删除光标所在行 set number 显示行号 n 跳转到n行 s 替换字符串 : s/test/test2/g /g全局替换 /也可以用%代替 / 查找字符串 网络通信常用的命令 Arp：网络地址显示及控制 ftp：文件传输 Lftp：文件传输 Mail：发送/接收电子邮件 Mesg：允许或拒绝其他用户向自己所用的终端发送信息 Mutt E-mail 管理程序 Ncftp ：文件传输 Netstat：显示网络连接.路由表和网络接口信息 Pine：收发电子邮件，浏览新闻组 Ping：用于查看网络是否连接通畅 Ssh：安全模式下远程登陆 Telnet：远程登录 Traceroute：显示到达某一主机所经由的路径及所使用的时间。 Wget：从网路上自动下载文件 SSH 注意事项 确保配置好了SSH登陆、再关闭密码登陆，否则有登不上服务器的风险 员工离职了直接deluser、再删除他的home，他就无法再登陆服务器了 SSH端口最好配置一下端口，默认的22端口可能会被恶意扫描","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https://panlianghnu.github.io/tags/linux/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://panlianghnu.github.io/tags/ubuntu/"},{"name":"转载","slug":"转载","permalink":"https://panlianghnu.github.io/tags/%E8%BD%AC%E8%BD%BD/"}]},{"title":"安装Ubuntu","slug":"安装Ubuntu","date":"2020-12-13T12:52:33.000Z","updated":"2020-12-14T06:25:36.000Z","comments":true,"path":"2020/12/13/安装Ubuntu/","link":"","permalink":"https://panlianghnu.github.io/2020/12/13/%E5%AE%89%E8%A3%85Ubuntu/","excerpt":"","text":"前言 以前我会写一些学习笔记.md，但没有发博客的习惯，现在参加了线下脱产的CSDN技术训练营，要求每个人定期的发自己的学习心得，刚好让我养成发博客的习惯。 安装Ubuntu 既然要学习Linux 和C语言编程，那么第一件事当然是装一个Linux系统。 我这里选择的是Ubuntu 20.04LTS版本，Ubuntu 的安装有全图形界面、驱动也比较好装（比如对英特尔显卡支持就比很多Linux发行版好），用的是Debian系的软件包管理，软件资源丰富。Ubuntu用的人很多，找各种教程也比较方便。 下面是安装Ubuntu的步骤了，安装之前先要空出一个磁盘来，或者分一个盘出来，如果经常用建议50GB往上，我主要就做做实验就只分了20GB 一、下载镜像 二、下载启动盘制作工具 Rufus 可以方便地制作一个启动盘 因为我之前做过kubuntu的启动盘所以我的u盘名字叫Kubuntu…听说要装ubuntu20.04LTS，我又把kubuntu格了… 三、制作启动盘 导入之前下好的Ubuntu镜像文件，系统类型选择UEFI（后面会介绍EFI和BIOS区别），文件系统选默认的FAT32就好（FAT32可以同时被Windows和MacOS识别，兼容性不错，其他的默认就好 四、重启电脑 插入U盘，重启电脑，按住F2进入BIOS 五、进入bios 直接在Exit里选择UEFI 回车即可从U盘启动 六、加载启动盘 系统在检查U盘里的数据 七、选择安装路径 请原谅我的手机拍电脑屏幕… 我直接将根目录/ 挂载到我之前分出来的20GB新盘里去了，格式化选择EXT4文件系统（现在Linux一般都用EXT4） 我是图省事，只挂载了根目录/ ，其他目录都是默认的，后面会介绍各个目录分别挂载的好处，我只是图方便，大家看看就好，没必要照着我的弄 这一步完了之后都是自动化安装了 八、安装成功 uname -a 查看ubuntu的版本信息 九、切换国内源 在使用Ubuntu的时候，我们会经常用到 apt-get install 命令，这个命令就是从你的源地址下载互联网软件包到本机并安装，Ubuntu官方的源速度很慢，经常有一个软件包下几小时的情况，所以我们得换个源 Ubuntu20.04自带了换源GUI 打开软件和更新，进入设置-Ubuntu软件-下载自 这里可以选择下载服务器，我选择的阿里云的源，确定后会自动让你更新源，相当于执行apt-get update，输密码即可 十、驱动N卡 Ubuntu 默认是用核显的，我们想要使用独显还得装一下驱动 ubuntu 对n卡支持很好，直接在软件和更新-附加驱动上点两下就装好了 deepin还要加油，装个n卡驱动死活装不上 终端执行nvidia-smi 查看n卡信息： 可以看到n卡被正确驱动了 安装deepin-wine Linux 的软件生态对比Windows 还是差了点 比如QQ for Linux 还是09年的界面，微信、钉钉就压根没有官方的Linux 支持版本（QQ微信的Web端还经常不让你用），但是2020年了，谁能摆脱这几个软件呢，想在Linux 里跑Windows 软件，我们需要装一个deepin-wine wget -O- https://deepin-wine.i-m.dev/setup.sh | sh sudo apt-get install deepin.com.wechat sudo apt-get install deepin.com.qq.im 可惜，ubuntu对wine支持不好，最小化有bug，没有deepin支持得好","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https://panlianghnu.github.io/tags/linux/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://panlianghnu.github.io/tags/ubuntu/"}]},{"title":"修复不显示图片","slug":"修复不显示图片","date":"2020-12-13T11:56:16.000Z","updated":"2020-12-14T06:21:25.000Z","comments":true,"path":"2020/12/13/修复不显示图片/","link":"","permalink":"https://panlianghnu.github.io/2020/12/13/%E4%BF%AE%E5%A4%8D%E4%B8%8D%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87/","excerpt":"","text":"hexo 图片显示问题及使用typora设置图片路径 使用hexo生成静态资源后,由于url的问题会出现图片加载的问题,现在网上的文章及官方的解决方案大概分为三种: 将图片放入source/images目录下,每次generate都会生成图片,在使用相对或绝对路径进行引用 配置hexo的_config.yml文件, 将 post_asset_folder 设置为true, 这样每次new 生成一个文章时都会同步生成一个同名的文件夹,然后设置相对或绝对路径. 使用hexo官方的解决方案,使用模版变量, &#123;% asset_img slug [title] %&#125; 但是在配置过程中发现这三种方式都多多少少存在一些问题,前两中首页跟内容页会有一个加载失败的问题,而第三种则失去了markdown的意义. 解决方法： 1234设置post_asset_folder 为 true, 安装插件 asset-imagenpm install https:&#x2F;&#x2F;github.com&#x2F;CodeFalling&#x2F;hexo-asset-image设置图片为相对路径hexo clean &amp;&amp; hexo generate &amp;&amp; hexo s 运行查看 Nice！","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://panlianghnu.github.io/tags/hexo/"}]},{"title":"first blog","slug":"first-blog","date":"2020-12-12T08:19:55.000Z","updated":"2020-12-12T08:21:49.000Z","comments":true,"path":"2020/12/12/first-blog/","link":"","permalink":"https://panlianghnu.github.io/2020/12/12/first-blog/","excerpt":"","text":"这是我的第一个博客 😁 😄 😂","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://panlianghnu.github.io/tags/nodejs/"},{"name":"P2P","slug":"P2P","permalink":"https://panlianghnu.github.io/tags/P2P/"},{"name":"websocket","slug":"websocket","permalink":"https://panlianghnu.github.io/tags/websocket/"},{"name":"聊天室","slug":"聊天室","permalink":"https://panlianghnu.github.io/tags/%E8%81%8A%E5%A4%A9%E5%AE%A4/"},{"name":"机器学习","slug":"机器学习","permalink":"https://panlianghnu.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"c语言","slug":"c语言","permalink":"https://panlianghnu.github.io/tags/c%E8%AF%AD%E8%A8%80/"},{"name":"区块链","slug":"区块链","permalink":"https://panlianghnu.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"python","slug":"python","permalink":"https://panlianghnu.github.io/tags/python/"},{"name":"Anaconda","slug":"Anaconda","permalink":"https://panlianghnu.github.io/tags/Anaconda/"},{"name":"转载","slug":"转载","permalink":"https://panlianghnu.github.io/tags/%E8%BD%AC%E8%BD%BD/"},{"name":"MacOS","slug":"MacOS","permalink":"https://panlianghnu.github.io/tags/MacOS/"},{"name":"Language","slug":"Language","permalink":"https://panlianghnu.github.io/tags/Language/"},{"name":"git","slug":"git","permalink":"https://panlianghnu.github.io/tags/git/"},{"name":"linux","slug":"linux","permalink":"https://panlianghnu.github.io/tags/linux/"},{"name":"分布式","slug":"分布式","permalink":"https://panlianghnu.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"nginx","slug":"nginx","permalink":"https://panlianghnu.github.io/tags/nginx/"},{"name":"操作系统","slug":"操作系统","permalink":"https://panlianghnu.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"bios","slug":"bios","permalink":"https://panlianghnu.github.io/tags/bios/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://panlianghnu.github.io/tags/ubuntu/"},{"name":"hexo","slug":"hexo","permalink":"https://panlianghnu.github.io/tags/hexo/"}]}