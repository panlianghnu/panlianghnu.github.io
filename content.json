{"meta":{"title":"PanLiang's blog","subtitle":"","description":"","author":"Pan Liang","url":"https://panlianghnu.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2021-09-23T02:53:25.441Z","updated":"2021-02-25T03:32:27.970Z","comments":false,"path":"/404.html","permalink":"https://panlianghnu.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2021-09-23T02:53:25.437Z","updated":"2021-02-25T03:32:27.970Z","comments":false,"path":"about/index.html","permalink":"https://panlianghnu.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"categories","date":"2020-12-14T06:12:43.000Z","updated":"2020-12-14T06:14:16.000Z","comments":true,"path":"categories/index.html","permalink":"https://panlianghnu.github.io/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-09-23T02:53:24.111Z","updated":"2021-02-25T03:32:27.970Z","comments":false,"path":"repository/index.html","permalink":"https://panlianghnu.github.io/repository/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-12-14T06:10:00.000Z","updated":"2020-12-14T06:10:41.000Z","comments":false,"path":"tags/index.html","permalink":"https://panlianghnu.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"小程序框架选择","slug":"小程序框架选择","date":"2021-06-29T08:51:33.000Z","updated":"2021-06-30T02:15:20.860Z","comments":true,"path":"2021/06/29/小程序框架选择/","link":"","permalink":"https://panlianghnu.github.io/2021/06/29/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6%E9%80%89%E6%8B%A9/","excerpt":"","text":"小程序框架选择微信小程序主流框架微信小程序开发目前有三种主流的框架 WEPY MpVue Taro 1 WEPY WEPY是腾讯团队开源的一款类vue语法规范的小程序框架 WEPY借鉴了Vue的语法风格和功能特性,支持了Vue的诸多特征，比如父子组件、组件之间的通信、computed属性计算、wathcer监听器、props传值、slot槽分发，还有很多高级的特征支持：Mixin混合、拦截器等;WePY发布的第一个版本是2016年12月份，也就是小程序刚刚推出的时候，到目前为止，WePY最新版本为2.1.0; 2 MpVue MpVue是美团团队开源的一款使用 Vue.js 开发微信小程序的前端框架 使用此框架，开发者将得到完整的 Vue.js 开发体验，同时为 H5 和小程序提供了代码复用的能力。mpvue在发布后的几天间获得2.7k的star,上升速度飞起,截至目前为止已经有20.3k的star; 3 Taro是京东凹凸实验室开源的一款使用 React.js 开发微信小程序的前端框架，Github上Star达到了29.1k，最高 京东凹凸实验室开源的一款使用 React.js 开发微信小程序的前端框架。它采用与 React 一致的组件化思想，组件生命周期与 React 保持一致，同时支持使用 JSX 语法，让代码具有更丰富的表现力，使用 Taro 进行开发可以获得和 React 一致的开发体验。同时因为使用了react的原因所以除了能编译h5, 小程序外还可以编译为ReactNative; 注：现在Taro支持React的同时也支持Vue，并且UI组件多，解决方案多，推荐使用Taro进行开发 详细的性能评测参考：跨端框架深度评测：微信原生、wepy、mpvue、taro","categories":[],"tags":[]},{"title":"CNN","slug":"CNN","date":"2021-04-19T07:55:50.000Z","updated":"2021-04-20T03:09:15.090Z","comments":true,"path":"2021/04/19/CNN/","link":"","permalink":"https://panlianghnu.github.io/2021/04/19/CNN/","excerpt":"","text":"CNN is sub of deep learning why CNN for image？ 有些图案比整个图像小得多（Convolution） 相同的特征图案出现在不同的位置（Convolution） 对图片进行降维几乎不会影响图像识别（Max pooling） Convolution 卷积 有很多 Filter，对应做内积，可以发现是否有 斜对角111 的出现，发现两个三，就找到了两个斜线 在一个 Convolution 里面有很多的 Filter，去找到对应的特征，把 6x6 的 image 变成了 4x4的 Feature Map for 彩色图片，Filter 变成立体的 CNN 和 Fully connected 的关系 Convolution 其实就是一个 Fully Connected 拿掉一些 weight 某个神经元只连接到9个input，并非全连接。而且神经元会共用 weight，Shared weights。 Max pooling ，选出4x4的Feature Map的最大值，就变成了 4x4 的image是比较小的 image，可以不断的卷积+MaxPooling 1x28x28(黑白，28x28) 25x26x26(25个Filter, 卷积让长宽减2) Max Pooling 则4个合起来选一个做代表，让长宽都减半，不断重复 最后 call model2.add(Flatten()) 把matrix拉直，丢进一个 fully connected network CNN 学到了什么 第K层，是侦测一些特征，比如第三个Filter侦测一些斜的重复条纹 可能学到黑白电视也能识别为数字。。。机器的认知和人还是有区别","categories":[],"tags":[]},{"title":"Deep-Forest","slug":"Deep-Forest","date":"2021-04-11T05:36:50.000Z","updated":"2021-04-26T02:51:39.270Z","comments":true,"path":"2021/04/11/Deep-Forest/","link":"","permalink":"https://panlianghnu.github.io/2021/04/11/Deep-Forest/","excerpt":"","text":"Deep ForestAbstract现如今大部分的深度学习模型都是基于神经网络（即：多层参数化、可微分、非线形模型，通过反向传播训练） 在本文中，探索了一种基于不可微分的深度学习模型的可能性。 我们推测，深层神经网络成功背后的奥秘主要归功于三个特征： 一层一层地处理 模型内的特征变换 足够的模型复杂性 本文提出了 gcForest 方法，生成 deep forest 来保持这三个特征。 这是一种决策树集成方法，比起深度神经网络需要更少的超参数，它的模型复杂度可以由数据依赖自动决定。 实验结果表明它的性能对于超参数的设置有很强的鲁棒性，在大多数情况下，甚至跨不同领域的不同数据，它都能够通过使用相同的默认配置得到很好的性能。这个研究打开了基于不可微分模型的深度学习领域的大门，并展示了不使用反向传播构建深层模型的可能性。 Introduction深度学习在很多领域都很火热。那么，什么是深度学习？大家都回答大概就像这样“深度学习是机器学习的子领域，使用深度神经网络”。实际上，深度神经网络（DNNs）在视觉和语音识别的成功，导致了深度学习的兴起。几乎所有当前的深度学习应用都是基于深度神经网络模型，或者更加专业一点地说，多层参数化、可微分、非线形模型，通过反向传播进行训练。 尽管深度神经网络很强大，仍然有很多不足之处。 的确，尽管有些作者都使用卷积神经网络，实际上由于许多原因（比如卷积层结构）他们在使用的是不同的学习模型。 First，DNNs有太多的超参数，学习性能严重依赖于仔细的参数调整。这一事实不仅使得训练非常地棘手，让深度学习更像一种 art 而非 science/engineering，还让DNNs的理论分析变得非常困难，因为干扰因素太多，几乎是无限的构型组合，有点不讲道理的意思。 Second，我们都知道DNNs的训练需要大量的训练数据，因此，当只有少部分训练数据时，DNNs就几乎不能被应用了，当数据规模不大不小时，有时甚至训练失败。注意到，在大数据领域，许多真实的训练任务缺乏足够多的labeled data，导致DNNs在这些任务中的性能较差。 Moreover，我们都知道神经网络是一个black-box，它的 decision process 通常难以理解，学习行为也很难以进行理论分析。 Furthermore，神经网络架构需要在训练之前确定好。因此，模型复杂度也是提前确定好的。我们推测深度模型通常比实际需要的要复杂得多，通过观察，最近有很多关于DNNs通过add shortcut connection来提高性能的报道得到了证实。因为这些操作简化了原始网络，实际上降低了模型的复杂性。所以如果能够让模型的复杂度由数据依赖自动地决定，应该可以大大改善性能。 同样值得注意的是，尽管DNNs已经得到了很好的发展，但仍有许多任务DNNs并不优越，有时甚至不足，比如，Random Forest、XGBoost 仍然在许多 Kaggle competition task 里获胜。 我们相信，为了处理复杂的学习任务，学习模型可能必须 go deep。然而当前的深度模型，总是基于神经网络。综上所述，有充分的理由来探索一个 non-NN(不基于神经网络) 的深度模型，in other words，考虑是否可以与其他模块一起实现深度学习，因为它们有自己的优势，如果能够深入，可能会显示出巨大的潜力。 特别是，不是所有的世界上的 properties 都是可微分的（或者建模为可微分的），这篇文章将解决这个基本问题： “Can deep learning be realized with non-differentiable modules?” 这个问题的答案可以帮助我们理解很多重要问题，比如 deep models ?=DNNs（或者，深层模型只能用可微模来构造？） 不使用反向传播可以训练深度模型吗？ 可以让深度模型战胜其他模型吗比如 Random Forest、XGBoost 实际上，机器学习社区以及开发了许多的机器学习模型，其中许多是不可微分的。理解是否可以基于不可微分模型构建一个深度学习模型将阐明这个问题（这些模块是否可以在深度学习中加以利用） 在这篇论文里，我们提出了一种 non-NN style deep model。 这是一种新的决策树集成，具有级联结构，能够通过森林进行表示学习。 它的表征学习能力可以通过多粒度扫描进一步增强，从而使gcForest具有上下文或结构感知能力。 级联level 可以自动确定，这样模型的复杂性就可以通过依赖于数据的方式来确定，而不是在训练前手动设计；这使得gcForest即使在小规模数据上也能很好地工作，并且使用户能够根据可用的计算资源来控制训练成本。 比起DNNs有更少的超参数 它的性能对超参数设置有很强的鲁棒性，使用 default setting 可以在大部分情况得到很好的性能，尽管跨不同领域不同数据 剩下的部分是这样：Section2 分析为什么深度学习很牛，解释设计灵感；Section3 提出方法；Section4 展示实验报告；Section5 提出一些相关工作；Section6 提出一些问题和未来方向；Section7 结束语。 Inspiration灵感 from DNNs众所周知，表征学习能力是深度学习成功的关键。那么什么是表征学习的关键呢？我们认为是 layer-by-layer processing. Fig1. 当抽象层从底层向上时，更高层次的特征就会显现出来。 考虑到如果其他问题得到解决，更大的模型复杂性（或者更准确地说，模型容量）通常会导致更强大的学习能力，将DNNs的成功归因于巨大的模型复杂性听起来是合理的。 然而，无法解释为什么浅层网络不如深层网络成功，因为人们可以通过增加几乎无限多个隐藏单元来增加浅层网络的复杂性。 因此，我们认为仅仅只有模型复杂性无法解释 DNNs 的成功。相反，我们猜想层层处理才是DNNs背后最重要的因素。因为扁平的网络（比如，单一隐藏层的网络）不管多么复杂，也无法保留层层处理的特征（the characteristics of layer-by-layer processing）。尽管我们没有严格的理由，但是这一猜想对森林的设计具有重要的启示。 有人可能会质疑，有些学习模型，例如决策树和Boosting机器，也进行逐层处理，为什么它们没有DNNs那么成功？ 我们认为最重要的区别是：与如图1所示生成新特征的DNNs不同，决策树和Boosting机器总是在原始特征表示上工作，而不在学习过程中创建新特征，或者换句话说，没有模型内特征转换（in-model feature transformation），而且，与具有任意高的模型复杂度的DNNs不同，决策树和Boosting机只能具有有限的模型复杂度。虽然模型的复杂性本身并不一定能解释DNNs的成功，但它仍然很重要，因为开发大的训练数据需要大的模型容量。 总的来说，我们推测DNNs的奥秘背后有三个关键特征，即逐层处理、模型特征转换和足够的模型复杂性。我们将尝试将这些特性赋予我们的非NN风格的深度模型。 灵感 from 集成学习集成学习(ensemble learning)可以说是现在非常火爆的机器学习方法了。它本身不是一个单独的机器学习算法，而是通过构建并结合多个机器学习器来完成学习任务。也就是我们常说的“博采众长”。集成学习一般可以获得比单一学习者更好的泛化性能。 为了组合一个好的集成，各个 learners 应该准确、多样。仅仅结合准确的 learners 往往不如结合一些准确的学习者和一些相对较弱的 learners，因为互补性比纯粹的准确更重要。 误差-分歧分解 Error-ambiguity decomposition误差-分歧分解指将集成后的泛化误差分解开的过程，可以用下式表示： {E= \\overline {E}- \\overline {A}}该式中左边 E 表示集成后的泛化误差，右侧 E 是 个体学习器的平均泛化误差， A 表示个体学习器的集成分歧，从该式可以得出结论：个体学习器的准确性越高、多样性越大，集成效果越好。然而，这个公式并不能作为一个优化目标函数，因为分歧项是在推导中用数学方法定义的，不能直接操作。后来，集合社区设计了许多多样性度量，但没有一个被公认为是多样性的正确定义。 在实践中，多样性增强的基本策略是在训练过程中引入基于启发式的随机性。粗略地说，有四种机制： 用不同的数据样本来训练各个 learners，比如Bagging[2]利用了bootstrap抽样[12]，而AdaBoost采用了序贯重要性抽样 第二种是输入特征操作，通过生成不同的特征子空间来训练各个 learners，比如随机子空间方法[24]为每个学习者随机挑选特征子集 使用不同参数设置的基础学习算法生成不同的 learners，比如不同的初始权重可用于单个神经网络[28]，而不同的分割选择可用于单个决策树[37] 使用不同的输出表征产生不同的 learners，比如ECOC方法[10]采用纠错输出码，而翻转输出方法[4]随机改变一些训练实例的标签 不同的方法可以组合起来使用，但是这些方法也总是有效，比如数据样本操作对稳定的学习者不起作用，而稳定的学习者的表现不会因训练数据的轻微修改而发生显著变化。 gcForest，它可以被视为一种决策树集成方法，利用几乎所有种类的机制来增强多样性。 The gcForest Approach这一段会先介绍级联森林结构，然后介绍多粒度扫描，然后对总体架构和超参数进行说明。 Cascade Forest Structure深层神经网络中的表征学习主要依赖于原始特征的逐层处理。受这个影响，gcForest利用级联结构，如图2，每一个 level of cascade 接受上一层的处理过的 feature information，然后输出处理结果到下一层。 Fig 2. 层叠森林结构示意图。假设级联的每一级由两个随机森林（黑色）和两个完全随机的树林（蓝色）组成。假设预测结果是三种 classes，因此，每个森林将输出一个三维分类向量，然后连接起来重新表示原始输入。 每个 level 都是决策树森林的集合。然而，我们包括不同类型的森林以鼓励多样性，因为多样性对于整体建设至关重要[63]。为简单起见，假设我们使用两个完全随机的森林和两个随机森林[5]。 每个完全随机树林包含500个完全随机树[37]，通过在树的每个节点上随机选择一个特征进行拆分，并将树生长到纯叶，即每个叶节点仅包含相同的 class。 同样的，每个随机森林包括500个树，通过随机选取 根号d 个特征作为候选特征（d是输入特征的个数），选择基尼值最佳的特征进行分割。每个森林中的树木个数是一个超参数，将在第3.3节中讨论。 给一个实例，每个森林都产生一个类分布的估计值，by 计算相关实例所在叶节点上不同类的训练实例的百分比，然后对同一林中的所有树进行平均。图三中，红色高亮显示实例遍历到叶节点的路径。 图3，分类向量生成，叶节上不同的标记意味着不同的类。 使用 K-fold 交叉验证来减少 overfitting risk 每个实例都将作为训练数据使用 k-1 次，产生 k-1 个分类向量，然后对其进行平均以产生最终分类向量，作为下一级的增强特征。扩展一个新的层次后，可以在验证集上估计整个级联的性能，如果没有显著的性能增益，训练过程将终止；因此，级联的层次数目是自动确定的。注意，当训练成本较高或可用计算资源有限时，也可以使用训练误差而不是交叉验证误差来控制级联增长。与大多数模型复杂度固定的深层神经网络不同，gcForest通过在适当的时候终止训练来自适应地确定其模型复杂度。这使得它能够适用于不同规模的训练数据，而不限于大规模的训练数据。 多粒度扫描深层神经网络在处理特征关系方面很强大，卷积神经网络对原始像素之间的空间关系非常重要的图像数据非常有效；递归神经网络对顺序关系很重要的序列化数据很有效。受这些影响，我们提出多粒度扫描来增强级联森林。 图4，feature re-representation。假设有三个分类，原始 feature 是一个400维的序列，采用100维的滑动窗口对输入特征进行处理。 对于序列数据，每滑动一个特征的窗口，将生成一个100维的特征向量，总共产生301个 feature vector。如果原始 feature 有特殊关系，比如它是一个 20*20 的pixel，那么会生成 10*10的 window，产生11*11=121个 feature vector 所有的从正/负训练样本中提取的 feature vector 被视为正/负 instances，将用来生成分类向量：instances 将用来 train 完全随机森林 和 随机森林，然后生成 class vector 然后连接为变换特征 在图4中， 假定有3个class、100维的 window，然后，每个森林会生成 301 个三维 class vector，得到一个1806维的变换特征向量，对应于原始的400维原始特征向量。 对于每个滑动窗口生成的 instance，我们简单的用原始训练数据的标记来标记它。在这里，一些标签分配本身就是不正确的。比如，假设原始的 training example 是一个 positive image about “car”，显然从 car 提取的 instance 没有包含一个 car，因此，它们被标记为 positive 是不正确的。这实际上与 Flipping Output method[4]有关，集合分集增强的一种典型输出表示方法? 图4只显示了一种尺寸的滑动窗口。通过使用多种大小的滑动窗口，将生成不同粒度的特征向量，如图5所示。 Fig.5 gcForest的整个过程。假设有三个类要预测，原始特征是400维，使用三种尺寸的滑动窗口。 第一步：使用多粒度扫描对输入特征进行预处理。以使用三个尺寸的滑动窗为例，分别为100-dim，200-dim和300-dim。输入数据为400-dim的序列特征，使用100-dim滑动窗会得到301个100-dim向量，然后输入到一个completely-random tree forest和一个random forest中，两个森林会分别得到的301个3-dim向量（3分类），将两个森林得到的特征向量进行拼接，会得到1806-dim的特征向量。同理，使用200-dim和300-dim滑动窗会分别得到1206-dim和606-dim特征向量。","categories":[],"tags":[]},{"title":"药物-靶点相互作用网络重建的细节","slug":"药物-靶点相互作用网络重建的细节","date":"2021-04-10T03:32:35.000Z","updated":"2021-04-10T09:15:17.210Z","comments":true,"path":"2021/04/10/药物-靶点相互作用网络重建的细节/","link":"","permalink":"https://panlianghnu.github.io/2021/04/10/%E8%8D%AF%E7%89%A9-%E9%9D%B6%E7%82%B9%E7%9B%B8%E4%BA%92%E4%BD%9C%E7%94%A8%E7%BD%91%E7%BB%9C%E9%87%8D%E5%BB%BA%E7%9A%84%E7%BB%86%E8%8A%82/","excerpt":"","text":"我们从6个常用数据源收集了FDA批准的药物的高质量物理药物-靶向相互作用，并使用已报道的结合亲和性数据定义了物理药物-靶向相互作用：抑制常数/效价(Ki)，离解常数(Kd)，中位有效浓度(EC50)，中位抑制浓度(IC50) &lt;= 10 uM. 从DrugBank数据库获取药物与靶点的相互作用.","categories":[],"tags":[]},{"title":"异构网络表示学习综述","slug":"异构网络表示学习综述","date":"2021-04-06T02:40:23.000Z","updated":"2021-04-13T05:48:08.050Z","comments":true,"path":"2021/04/06/异构网络表示学习综述/","link":"","permalink":"https://panlianghnu.github.io/2021/04/06/%E5%BC%82%E6%9E%84%E7%BD%91%E7%BB%9C%E8%A1%A8%E7%A4%BA%E5%AD%A6%E4%B9%A0%E7%BB%BC%E8%BF%B0/","excerpt":"","text":"异构网络表示学习前言表征学习为何重要：210用6除是非常直截了当的，但是如果用罗马字符 CCX，会一下想到用 VI 除吗，可以看到阿拉伯数字相比于罗马数字更加的让人容易处理除法。 机器学习算法的成功与否不仅仅取决于算法本身，也取决于数据的表示。数据的不同表示可能会导致有效信息的隐藏或是曝露，这也决定了算法是不是能直截了当地解决问题。表征学习的目的是对复杂的原始数据化繁为简，把原始数据的无效信息剔除，把有效信息更有效地进行提炼，形成特征，这也应和了机器学习的一大任务——可解释性。 也正是因为特征的有效提取，使得今后的机器学习任务简单并且精确许多。在我们接触机器学习、深度学习之初，我们就知道有一类任务也是提炼数据的，那就是特征工程。与表征学习不同的是，特征工程是人为地处理数据，也是我们常听的“洗数据”。 而表示学习是借助算法让机器自动地学习有用的数据和其特征。 不过这两个思路都在尝试解决机器学习的一个主要问题——如何更合理高效地将特征表示出来。 什么因素决定了一种表示比另一种表示好呢： 提供Disentangling of Causal Factors的线索 One hypothesis is that an ideal representation is one in which the features within the representation correspond to the under- lying causes of the observed data, with separate features or directions in feature space corresponding to different causes, so that the representation disentangles the causes from one another. This hypothesis motivates approaches in which we first seek a good representation for p(x). Such a representation may also be a good representation for computing p(y | x) if y is among the most salient causes of x. 一个假设：理想表示法是这样一种表示法，即表示法中的特征对应于观测数据的潜在原因，而特征空间中的独立特征或方向对应于不同的原因，这样表示法就可以将原因相互分离开来。 这一假设激发了我们首先寻找p（x）的良好表示的方法。如果y是x的最显著原因之一，那么这种表示也可以是计算p（y | x）的良好表示。 这是一个混合高斯分布，学习到好的p(x)，对y的预估会变得更容易，但如果p(x)是一个均匀分布，则对y的预估就一点用的没有。 distribution representation的优势，分布表征 对于上面两个图，分别表示distribution representation和one hot representation对空间的分割，明显可以看到，distribution的版本，可以用更少的线分割出更多的区域，即在统计上更有效（statistics effective） Deep带来的Exponential级别的增益 我们有了解过神经网络的universal approximators理论，Deep的模型比shallow的模型能用更少的weight，描述更复杂的function，在representation里面，也适用。 事实证明，在许多不同的情况下，通过许多非线性的组合和重用特征的层次结构来组织计算，可以在使用分布式表示的指数提升的基础上，给统计效率带来指数提升。 why and when pretrain work: 无监督的预训练结合了两种不同的想法。首先，它利用了这样一种思想，即深度神经网络初始参数的选择可以对模型产生显著的正则化效果（并且在较小程度上可以改善优化）。其次，它利用了一个更一般的思想，即了解输入分布有助于了解从输入到输出的映射。 目前更多的信息表明，deep模型，local mini不是严重的问题，而pretrain可能能帮助我们找到更好的路径绕开变态Hessian matrix的区域。 其基本思想是，一些对无监督学习任务有用的特征也可能对有监督学习任务有用。例如，如果我们训练汽车和摩托车图像的生成模型，它需要知道车轮，以及图像中应该有多少个车轮。所以当unsupervised学习到的表达对supervised的帮助不大时，即共同性没有那么强时，效果就不理想了。 另外由于pretrain把模型训练分为了两个stage，不是end2end，无论是调参反馈还是参数量上，都更慢或更多，随着supervised能用的样本越来越多，pretrain开始退出历史舞台。 Abstract异构网络表示学习的目标，就是将输入异构网络中的顶点嵌入到一个潜在的嵌入空间中，使得网络的结构和关系属性都能被编码和保持。嵌入生成的向量就可以作为机器学习的 features 表达性嵌入学习，目前主要分为两类： 浅层嵌入学习 图神经网络 文章确定了几个最尚未解决的挑战，建立了异构网络图的 benchmark Introduction​ 现实世界的复杂系统通常是多个对象多个关系构成的。比如 science enterprise，它利用五种对象（论文、作者、研究所、地点、领域），其他在社会学、生物学、经济学等各个领域都能看到。通常，这些复杂系统能够被有效地抽象为异构网络（不同类型的顶点在唯一关系下连接【Sun and Han,2012】） ​ 异构网络的定义：有向图 G = (V,E)，每个顶点 v 属于 V，每个边 e 属于 E，顶点和边通过 type mapping function 联系起来 τ(v): V \\rightarrow T_V \\space\\space and \\space\\space φ(e):E \\rightarrow T_ETv 和 Te 分别代表顶点和边的各个类型 | \\space T_V \\space | + | \\space T_E \\space | > 2 如果两个边有相同的关系，有相同的顶点类型 (source v -&gt; target v) ，如果 |TV |=1 and |TE|=1,这是一个具有相同类型顶点和边的异构网络，其实就是普通的有向图 对异构网络分析的过程，一般由提取类型化结构化的 features 开始，它们被进一步输入到下游图形任务的机器学习模型中，通常这会涉及到以下几个概念： Meta Relation（元关系）：异构网络中的每个边和它的元关系相关联 For \\space an \\space edge \\space e = (s,t) \\space ,its \\space meta \\space relation \\space is \\space denoted \\space as \\space ⟨τ (s), φ(e), τ (t)⟩.Network Schema（网络架构）：给定一个异构网络G，它的网络架构定义为 T_G = (T_V,T_E)网络架构包含G中所有的元关系，G的顶点类型 Tv，G的边类型Te Meta Path（元路径）：一个G中元关系组成的序列，比如一个OAG中一个说明性的元路径是这样的：”author-paper-venue-paper-author”表示在同一地点发布的两个作者的语义 比如，Figure 1 说明了OAG的网络架构和元路径： 基于这些概念和工具，各种异构网络挖掘方法被提出并应用于各种与图形相关的应用，如顶点分类、在线推荐、链接预测、社区检测、异常检测等。 近年来，异构网络挖掘的研究范式逐渐转向基于表征学习的技术。 网络表征学习的目标是自动化的学习潜在的低纬度网络对象的嵌入表示 应用前提是输入网络固有的结构和语义特性可以被编码到潜在的嵌入向量中，从而有利于异构网络上的应用和任务。比如，user 和 items 的网络嵌入向量可以作为在线推荐系统的特征输入。 异构网络挖掘历史异构网络的形式化可以追溯到对异构信息网络的研究，其中作者提出利用不同类型顶点之间的链接来生成簇。更重要的是，作者认为“多类型对象之间的相互作用在揭示网络所承载的丰富语义方面起着关键作用”。 应用除聚类外，图的非均匀性在其他图挖掘任务中的重要性也得到了证明，包括顶点分类、排序、相似搜索、链路预测、异常检测等。 传统的挖掘模式挖掘异构网络的传统工作流程是首先在网络模式上定义元路径或其变体，如元图或元结构，然后将其作为特征来开发机器学习模型 以学术网络中的链接预测任务为例，我们可以定义“作者-论文-作者”元]路径来提取异构结构特征，并利用这些特征来推断每对作者之间是否存在协作关系 挑战异构网络挖掘的主要挑战在于元路径的设计。通常，为了解决输入网络的特定图形问题，我们必须人工定制特定于任务和数据的元路径，这需要相关的领域知识和经验。 此外，元路径的传统用法仅限于离散空间。如果图中的两个顶点没有结构上的连接，基于元路径的技术就无法捕捉它们之间的关系。例如，假设一位学者发表的论文都是 NeurIPS，而另一位学者的所有论文都发在 ICML，根据”author-paper-venue-paper-author”元路径，这两个学者之间的相关性是0，然而 NeurIPS 和 ICML 有很强的相关性。 这种由离散结构引起的挑战可以通过在连续空间中使用潜在的表示来自然地解决。 异构网络表征近年来，利用神经网络学习物体潜在嵌入的神经表征学习在计算机视觉、自然语言处理和语音识别等领域取得了革命性的成果。受此启发，有人尝试将表征学习应用到网络中。网络表示学习的前提是不需要手工构造结构特征，而是能够将网络结构自动嵌入到潜在空间中，然后用于现有的网络挖掘任务。 神经网络表示学习的主要障碍是非欧几里德图结构到欧几里德嵌入空间的转换，因为图数据和神经网络之间存在差距。最近，弥补这一差距的主要进展是借鉴图论的思想。例如，一个方向的尝试是利用random walks将图结构转换为序列，这可以被基于序列的嵌入学习算法（比如DeepWalk 和 node2vec模型）来调用。 异质网络的表征学习技术大多是在同质网络表征学习的基础上发展起来的。核心问题是如何将不同类型的顶点和边之间的结构转换为潜在空间，从而编码和保持异构网络的结构和语义特性。 异构网络嵌入我们回顾了基于浅层学习的异构网络嵌入方法。 “浅层”方法的特点是嵌入查找表，即它们直接将每个顶点编码为一个向量，而这个嵌入表是要优化的参数。沿着这条线，方法可以根据它们所建立的假设进行分类。 基于分布假设的方法 Skip-gram 是一种浅层嵌入学习算法，最初是为了捕捉自然语言中单词的语义相似性而提出的。它基于分布假设，该假设指出出现在同一上下文中的词往往具有相似的含义 随后，该假设被扩展到网络：共享相同结构上下文的顶点在嵌入空间中趋于接近为了解决这一问题，人们提出了几种基于skip-gram的同质网络嵌入方法，如DeepWalk和node2vec以及NetMF PTE：为了对异质网络中的分布假设进行建模，PTE模型首先将输入的异质网络投影到几个同质/二部网络中，假定：具有相似邻域的顶点彼此相似，因此应该在低维空间中紧密地表示在这种假设下，PTE在每个网络上应用skip-gram框架，并联合优化所有嵌入表 metapath2vec：为了更好地捕捉图的异质性，提出了 metapath2vec 模型：它的主要思想是扩大随机游走策略，这些策略最初用于收集节点上下文，以模拟同质网络中的分布假设。具体地说，它引入了基于元路径的随机游走策略，其中游走者被限制在特定类型的顶点之间的转换。与PTE相比，该策略能更好地统一描述不同类型顶点之间的结构依赖关系。对于嵌入学习，metapath2vec直接利用带负采样的skip-gram学习异构网络中所有类型顶点的嵌入。此外，它的增强版进一步提出了基于类型的skip-gram负采样，有效地建模了异构网络中的结构依赖和语义依赖 后来，各种解决方案利用元路径来构建异构上下文，以便为不同的下游任务学习表示。例如，与word2vec的phrase2vec扩展类似，HIN2vec直接将元路径作为对象/上下文来学习顶点和元路径的嵌入。GATNE将该框架扩展到多个异构网络，TapEm进一步将顶点对嵌入和元路径嵌入结合起来。HeteSpaceyWalk通过在元路径、图和模式的指导下提出异构个性化spacey随机行走算法，进一步推进了基于元路径的随机行走。更重要的是，这种随机游走策略与顶点之间的收敛平稳分布有关 其他方法 除了基于skip-gram的方法外，其他异构网络嵌入技术还包括基于标签传播、因子分解和生成对抗网络的方法。此外，大多数这些技术都是特定于任务的，需要监督信息。 LSHM：2014年，最初尝试异构网络表征学习的方法是基于标签传播的LSHM模型，LSHM借用了同构网络中标签传播的平滑性假设——两个连接的节点往往具有相同的标签，用于异构网络。它的思想是通过使用顶点类型特定的分类来强制（不同类型的）顶点具有相似的表示。该方法是在标签传播框架下进行顶点分类的。在此基础上，针对异构链路预测问题，提出了一种类似的任务和结构损失联合优化方法。它的 structure loss 是基于在异构网络中为特定任务手工设计的元路径来构造的。总之，这些方法是（半）监督的，作者认为不同类型之间的结构依赖和标签依赖可以建模。 HERec：与PTE类似，HERec模型还根据定制的元路径将输入异构网络投影到多个维度。然后在每个投影中使用metapath2vec框架学习顶点嵌入，所有顶点嵌入都通过基于因子分解的融合模型与来自推荐任务的监督信息进行融合。不同的是，HueRec方法认为不同元路径之间存在相互关系，因此它将它们统一为异构网络中推荐任务的端到端框架。 大多数基于skip-gram的嵌入方法都与负采样相结合，以实现可伸缩的快速学习。更广泛地说，该技术属于噪声对比估计（NCE）领域，APE模型在此基础上有效地学习了不同顶点类型与“上下文相关”噪声分布之间的交互概率，而无需考虑大数据空间。此外，最近的一项研究提出了基于生成性对抗网络（GAN）的框架HeGAN来实现这一点。HeGAN的目标不是直接采样，而是生成潜在的顶点分布，从而生成具有异质结构的更好的负样本。 总结 在浅嵌入的背景下，对于异构网络有无监督和有监督两种学习框架。大多数无监督方法都是建立在分布假设应用于异构网络的基础上，如基于 skip-gram 的模型。对于（半）监督框架，学习目标通常是异构结构建模和特定任务优化的组合。 然而，在这两种学习环境下，大多数方法都依赖于人工探索异构结构，即选择元路径或变体来获取结构和语义依赖。 异构图神经网络最近几年，图神经网络（GNN）在构造和关系数据建模方面显示出了有希望的结果。和基于浅层学习的异构网络嵌入方法不一样，GNN通常由更复杂的编码器授权，通常是一个深层的神经网络，支持结构和顶点属性的自然建模。这一部分，会总结最近的GNNs对网络表征学习的进展。 我们首先介绍了关系数据的通用GNN框架。一种方法是将其视为神经信息传递框架，其中输入图的结构用作传播（顶点或边）信息的主干，以形成表达性表示。或者，我们可以将其视为特征聚合过程，其中对于每个顶点，其邻域被视为接收场，从中递归地聚合信息。 在形式上，这个聚合过程可以抽象成公式： H^{(l+1)} = \\sigma (\\widehat{A} H^{(l)} W^{(l)}) H(l) W(l) 是第l层的（隐藏）节点表示和参数矩阵 A^ 表示从某种形式的图结构导出的滤波器，比如，在GCN中，它是对称的归一化邻接矩阵 σ 通常是一个非线形的 function 在这个框架下，有人提出了一系列的研究来更好地学习网络表示。接下来，我们总结异构图神经网络的最新发展 Relational GCN. 关系图卷积网络 使用GNN对多关系图建模的最早尝试之一是关系图卷积网络（RGCN） 它为每种边类型保留不同的线性投影权重，为了处理具有大量关系的图，RGCN还将特定关系的参数分解为若干基矩阵的线性组合。 另一个值得注意的工作是 Decagon model，它在以蛋白质、药物、多药副作用为顶点的多模态图中，对每种类型的关系应用特定的图卷积滤波器。请注意，Decagon model 中特定于关系的参数对于不同的顶点是共享的。 Heterogeneous GNNs.异构神经网络 为了处理异构图结构和节点属性，异构图神经网络（HetGNN）使用类型特定的RNN对每种类型的相邻顶点的特征进行编码，然后使用另一个RNN来聚合不同类型的编码的相邻表示。 Heterogeneous Graph Attention.异构图注意 为了将 Attention 融入到异构GNN设计中，GEM方法对每个关系使用不同的聚合器，并学习用于建模不同类型顶点重要性的注意系数。 后来，异质图注意网络（HAN）[Wang et al.，2019a]使用元路径作为边来评价图，并为每个元路径定义的边保持不同的权重矩阵。它还利用高级语义注意来区分和聚合来自不同元路径的信息。 Heterogeneous Graph Transformer.异构图转换器 所有以前的工作都是单独使用节点顶点或边类型来确定GNN权重矩阵，然而，对于那些不明显的关系，很难学习精确的关系特定权重。Heterogeneous Graph Transformer 使用每条边的Meta Relation（元关系）来参数化这个 Transformer-like self-attention 架构，以便通过使用更少的参数来捕获不同关系的共同模式和特定模式。 此外，与大多数现有的需要手工设计元路径的工作不同，HGT可以通过多层GNN的特性自动学习隐式元路径的重要性，以融入高阶异构邻居信息。 它还学习了边类型和复合关系的软选择，以生成有用的多跳元路径来扩充输入图形。然后，对增广图采用 vanilla GCN层，得到上下文化的顶点嵌入。 Summary. 图神经网络的性质保证了上述所有方法都能得到任何不可见顶点或图的归纳嵌入，而不是像浅嵌入方法那样为图中的每个顶点保持一个大的查找表。此外，它们还可以通过神经网络编码器自然地利用丰富的顶点属性。 为了适应异构环境，所有现有模型对每种关系类型采用不同的权重矩阵。他们中的大多数利用人类设计的元路径来扩充图，而最近的一些工作利用自我注意机制来自动学习“软”元路径。 知识图 &amp; 属性网络异构网络与 知识图&amp;属性网络 非常接近，在这个简短的 survey 里，我们没有深入挖掘他们之间的差异和联系 一般来说，知识图嵌入是一种完成知识图三元组的技术。其主要解决方案可分为两类： 神经嵌入 tensor factorization 属性网络嵌入与图神经网络具有相似的输入 值得注意的是，提出了ANE和DANE模型来模拟网络结构和属性之间的内在关联，并将其扩展到动态环境。最近，Cen等人将属性化的多重异构网络的表示学习问题形式化。为了解决属性化、多重性和异质性的挑战，他们提出了GATNE框架，并从理论上证明了它的表达优势 应用由于异构网络能够对现实世界中的复杂系统进行抽象和建模，因此异构网络的表示学习在相似性搜索、知识图推理、问答和推荐等方面有着广泛的应用。例如，metapath2vec方法已经部署在 Microsoft Academic 中用于相似性搜索。另一个得益于异构网络嵌入的行业系统是电子商务中的在线推荐模块 挑战、方向、Open Data在其发展过程中，表征学习为挖掘（异构）网络提供了一种范式转换。特别明显的是，图神经网络能够显著地重构异构网络表示学习，从而有利于异构网络数据的所有可能应用。因此，我们将重点讨论基于GNN的技术，讨论仍然存在的挑战和未来的发展方向。 Future Directions 避免元路径设计 表征学习的大前提是，避免涉及手动工作和领域专业知识的特征工程。 如上所述，大多数异构表示学习方法都需要手动定制元路径或其变体（例如，元图），以便模型捕获给定异构结构下的语义。 例如，metapath2ve、HetGNN和HAN必须将预定义的元路径作为输入来处理指定的任务。基本上，它们的表示能力仅限于特定数据上的特定任务。 避免元路径设计的一个很有希望的尝试是最近的HGT模型[Hu et al.，2020b]，在该模型中，通过GNNs跨多个层的特征传播自然解决了该问题。因此，为了充分发挥表示学习的威力，有必要在不进行元路径预设计的情况下自动学习异构网络表示，即避免对网络结构和语义进行预探索 多感官表征 迄今为止，大多数嵌入都是从复杂的、多类型的异构网络中学习的。以分布假设为例，结构语境之间没有区别。具体来说，如果我们以学者“贾维汉”为例，我们可以为他说出几个不同的意义。在科学协作意识下，与他最为相似的学者是他的博士生“简培”和“阎锡峰”。或者，在场地出版物的意义上，“菲利普·S·余”和“克里斯托斯·法鲁索斯”与他最为相似。或者，在数据挖掘的科学影响下，他更像数据库中的“Rakesh Agrawal”和IR中的“Bruce Croft”。从这个例子中，我们可以清楚地看到异质网络中存在着多意义表示。如何定义、学习和使用它们在很大程度上仍然是开放和未探索的。 （异构）GNNs的预训练 如前一节所述，现有的（异构的）GNN是在（半）监督的环境中进行端到端训练的。换句话说，我们需要每个数据集上每个任务的专用标签数据。这在现实世界中通常是很昂贵的，特别是对于Web规模的异构图。为了解决标签稀缺的问题，已经采用了预先训练的神经模型，并显著促进了各种人工智能的发展，例如自然语言处理领域的BERT[Devlin et al.，2019]。 预训练模型的好处包括 大多数情况下，它是以无监督（或自我监督）的方式训练的，不需要特定于任务和数据的标签信息； 它可以用于对不同的下游任务进行微调，甚至可以推广到各种数据。 在这里，我们设想了两种类型的（异质）GNN预训练方向，以供将来的研究 首先，0 然后，我们在一组网络（不同类型）上预先训练GNN模型，目的是捕捉这些网络的内在结构特性，从而促进不同（看不见的）网络上的下游任务。 当然，异构GNNs的预训练也面临着图形异构性的挑战，使得它不同于现有的同质文本/图像/语音数据预训练技术，并且比现有的预训练技术更具挑战性。 多任务学习 近年来，多任务学习使得深度学习方法在自然语言处理（NLP）和自然语言处理（CV）中的学习表征方面优于传统的单任务学习方法。它的思想是并行处理多个任务，以识别和利用这些任务之间的相似性/差异。研究表明，与特定任务模型相比，这样做可以提高整体绩效[Ruder，2017；Wu等人，2020]。请注意，给定一个由多种类型的顶点和边组成的异构网络，它通常与各种挖掘任务相关联。例如，在一个异构的学术网络上有许多实际应用，如名称消歧、论文主题或作者研究兴趣的推断、文献和引文推荐、相似性搜索等。所有这些异质网络任务都可以从多任务学习中受益。 在多任务学习中，任务间的共享表示被学习，任务特定的参数可以对其他任务做出贡献。异构网络的独特特性是包含多种类型的顶点和边，这可能是多任务学习的自然应用。 动态性和可拓展性 在现实世界中，大多数网络都是随着时间的推移而演化的，其建模一直是一个研究难题。当网络中存在不同类型的顶点和边时，网络动态问题就变得特别具有挑战性。现有的方法大多是基于时间戳将输入动态网络分解为多层网络来处理。因此，跨不同层的结构和时间依赖通常被忽略。为此，如何有效地对动态异构网络进行建模仍是一个有待解决的问题，更不用说表示学习了。 另一个常见的挑战在于真实世界图形的大规模。OAG由数十亿个顶点和边组成，跨越1800到2020年。其他网络规模的图表可以更大。对于大多数现有的异构网络表示学习技术来说，在Web规模的图上学习是非常昂贵的。因此，可扩展和计算的可行模型是未来工作的关键方向。 其他 通用GNN模型也面临着一些挑战，例如许多GNN层堆叠时的 over-smoothing 和 over-fitting 问题 Open Data and BenchmarkConclusion在这项工作中，我们介绍了异构网络表示学习的问题，并讨论了其潜在的挑战。我们回顾了最近在应对这些挑战方面取得的进展。更重要的是，我们深入探讨问题，揭示未来应该解决的关键问题和痛点。为了促进这一快速发展的课题的开放性和可复制性研究，我们首先为研究社区发布 异构图的 Benchmark。","categories":[],"tags":[]},{"title":"python实现发送短信验证码","slug":"python实现发送短信验证码","date":"2021-04-01T07:50:25.000Z","updated":"2021-04-01T09:46:32.460Z","comments":true,"path":"2021/04/01/python实现发送短信验证码/","link":"","permalink":"https://panlianghnu.github.io/2021/04/01/python%E5%AE%9E%E7%8E%B0%E5%8F%91%E9%80%81%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81/","excerpt":"","text":"调用 smtplib、MIMEText、formataddr库函数 发邮件、邮件格式、标准地址 代码如下 12345678910111213141516171819202122232425262728293031import smtplibfrom email.mime.text import MIMETextfrom email.utils import formataddrfrom hashlib import md5my_sender = &#x27;2261834866@qq.com&#x27; # 发件人邮箱账号my_pass = &#x27;xxxxxxxxxxxxxxxxxxx&#x27; # 发件人邮箱密码, 可能是授权码# 返回True则发送成功，返回False则发送失败def send_mail(receiver=&#x27;&#x27;): try: code = generate_code(receiver) msg = MIMEText(&#x27;您的验证码为：&#x27; + code, &#x27;plain&#x27;, &#x27;utf-8&#x27;) msg[&#x27;From&#x27;] = formataddr([&quot;From AIdrug&quot;, my_sender]) # 括号里的对应发件人邮箱昵称、发件人邮箱账号 msg[&#x27;To&#x27;] = formataddr([&quot;nick_name&quot;, receiver]) # 括号里的对应收件人邮箱昵称、收件人邮箱账号 msg[&#x27;Subject&#x27;] = &quot;感谢使用AIdrug&quot; # 邮件的主题，也可以说是标题 server = smtplib.SMTP_SSL(&quot;smtp.qq.com&quot;, 465) # 发件人邮箱中的SMTP服务器，端口是25 server.login(my_sender, my_pass) # 括号中对应的是发件人邮箱账号、邮箱密码 server.sendmail(my_sender, [receiver, ], msg.as_string()) # 括号中对应的是发件人邮箱账号、收件人邮箱账号、发送邮件 server.quit() # 关闭连接 except Exception: # 如果 try 中的语句没有执行，则会执行下面的 ret=False return False return Truedef generate_code(email: str = &quot;&quot;): code = md5(email.encode()) return code.hexdigest()[0:4] 这里我采用了 md5 来生成验证码，这样算是比较简单的一种加密方式吧，但是这样有个问题就是用户操作时每次验证码都会相同，但是我们这里只有注册时用到验证码，就无所谓吧。后期可以改成每5分钟换一下加密方式（或者在email后混一个字符串再进行MD5）来解决这个问题。","categories":[],"tags":[]},{"title":"Flask操作数据库","slug":"Flask操作数据库","date":"2021-03-31T07:49:40.000Z","updated":"2021-03-31T08:20:24.620Z","comments":true,"path":"2021/03/31/Flask操作数据库/","link":"","permalink":"https://panlianghnu.github.io/2021/03/31/Flask%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"","text":"安装1pip install flask-sqlalchemy 配置 配置选项 说明 SQLALCHEMY_DATABASE_URI 连接数据库。示例：mysql://username:password@host/post/db?charset=utf-8 SQLALCHEMY_BINDS 一个将会绑定多种数据库的字典。 更多详细信息请看官文 绑定多种数据库. SQLALCHEMY_ECHO 调试设置为true SQLALCHEMY_POOL_SIZE 数据库池的大小，默认值为5。 SQLALCHEMY_POOL_TIMEOUT 连接超时时间 SQLALCHEMY_POOL_RECYCLE 自动回收连接的秒数。 SQLALCHEMY_MAX_OVERFLOW 控制在连接池达到最大值后可以创建的连接数。当这些额外的 连接回收到连接池后将会被断开和抛弃。 SQLALCHEMY_TRACK_MODIFICATIONS 如果设置成 True (默认情况)，Flask-SQLAlchemy 将会追踪对象的修改并且发送信号。这需要额外的内存， 如果不必要的可以禁用它。 操作数据库需要先创建一个db对象，通常写在exts.py文件里。 12from flask_sqlalchemy import SQLAlchemydb = SQLAlchemy() flask项目一般将数据库配置写入configs.py文件里面，配置在创建引擎前需写好，不要在程序运行时修改配置，如下。 1234567891011121314DIALECT = &#x27;mysql&#x27;DRIVER = &#x27;pymysql&#x27;USERNAME = &#x27;root&#x27;PASSWORD = &#x27;********&#x27;HOST = &#x27;127.0.0.1&#x27;PORT = &#x27;3306&#x27;DATABASE = &#x27;AIdrug&#x27;# mysql 不会认识utf-8,而需要直接写成utf8SQLALCHEMY_DATABASE_URI = &quot;&#123;&#125;+&#123;&#125;://&#123;&#125;:&#123;&#125;@&#123;&#125;:&#123;&#125;/&#123;&#125;?charset=utf8&quot;.format( DIALECT, DRIVER, USERNAME, PASSWORD, HOST, PORT, DATABASE)SQLALCHEMY_TRACK_MODIFICATIONS = FalseSQLALCHEMY_ECHO = True 写完数据库配置后需要和app绑定，main.py文件里写flask应用的创建和蓝图的注册等等，如下： 123456789from flask import Flaskimport configsfrom exts import dbapp = Flask(__name__)# 加载配置文件app.config.from_object(configs)# db绑定appdb.init_app(app) 模型 数据类型 说明 Integer 整型 String 字符串 Text 文本 DateTime 日期 Float 浮点型 Boolean 布尔值 PickleType 存储一个序列化（ Pickle ）后的Python对象 LargeBinary 巨长度二进制数据 表的创建 123456789101112131415161718192021222324252627282930# 建表写在models.py文件里面from .exts import db&quot;&quot;&quot;建表以下表关系：一个用户对应多篇文章（一对多）一篇文章对应多个标签，一个标签对应多个文章（多对多）&quot;&quot;&quot;&quot;&quot;&quot;一对一关系中，需要设置relationship中的uselist=Flase，其他数据库操作一样。一对多关系中，外键设置在多的一方中，关系（relationship）可设置在任意一方。多对多关系中，需建立关系表，设置 secondary=关系表&quot;&quot;&quot;# 用户表class User(db.Model): __tablename__ = &#x27;user&#x27; id = db.Column(db.Integer, primary_key=True, autoincrement=True) email = db.Column(db.String(30)) username = db.Column(db.String(30))# Log表class Log(db.Model): __tablename__ = &#x27;log&#x27; id = db.Column(db.Integer, primary_key=True, autoincrement=True) userId = db.Column(db.Integer, db.ForeignKey(&#x27;user.id&#x27;)) # 外键 log = db.Column(db.String(50)) 表的映射 创建好表后需要映射到数据库中，这里用flask-migrate库，编写启动文件manage.py 12345678910111213from flask_script import Manager, Serverfrom main import appfrom flask_migrate import Migrate, MigrateCommandfrom dao.exts import dbfrom dao import models # 模型文件必须导入进来，否则运行报错manager = Manager(app)Migrate(app=app, db=db)manager.add_command(&#x27;db&#x27;, MigrateCommand) # 创建数据库映射命令manager.add_command(&#x27;start&#x27;, Server(port=8000, use_debugger=True)) # 创建启动命令if __name__ == &#x27;__main__&#x27;: manager.run() 编写好启动文件后，进入项目根目录，输入： 123python manage.py db initpython manage.py db migratepython manage.py db upgrade 表的增删改查 1234567891011121314151617181920212223242526272829303132333435# 原生sql语句操作sql = &#x27;select * from user&#x27;result = db.session.execute(sql)# 查询全部User.query.all()# 主键查询User.query.get(1)# 条件查询User.query.filter_by(User.username=&#x27;name&#x27;)# 多条件查询from sqlalchemy import and_User.query.filter_by(and_(User.username ==&#x27;name&#x27;,User.password==&#x27;passwd&#x27;))# 比较查询User.query.filter(User.id.__lt__(5)) # 小于5User.query.filter(User.id.__le__(5)) # 小于等于5User.query.filter(User.id.__gt__(5)) # 大于5User.query.filter(User.id.__ge__(5)) # 大于等于5# in查询User.query.filter(User.username.in_(&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;D&#x27;))# 排序User.query.order_by(&#x27;age&#x27;) # 按年龄排序，默认升序，在前面加-号为降序&#x27;-age&#x27;# 限制查询User.query.filter(age=18).offset(2).limit(3) # 跳过二条开始查询，限制输出3条# 增加use = User(id,username,password)db.session.add(use)db.session.commit() # 删除User.query.filter_by(User.username=&#x27;name&#x27;).delete()# 修改User.query.filter_by(User.username=&#x27;name&#x27;).update(&#123;&#x27;password&#x27;:&#x27;newdata&#x27;&#125;) 成功！","categories":[],"tags":[]},{"title":"MacOS安装MySQL","slug":"MacOS安装MySQL","date":"2021-03-31T02:28:20.000Z","updated":"2021-03-31T03:12:44.550Z","comments":true,"path":"2021/03/31/MacOS安装MySQL/","link":"","permalink":"https://panlianghnu.github.io/2021/03/31/MacOS%E5%AE%89%E8%A3%85MySQL/","excerpt":"","text":"MacOS安装MySQL安装登陆MySQL网站，使用dmg方式安装 打开MySQL官网，选择下面的MySQL community Server，选择dmg文件下载 可以选择不登陆直接下载 下载完成后一路确定，输入你要设置的密码 打开MySQL服务 进入系统偏好设置 点击MySQL 红色代表还没启动，绿色代表启动了 我服了，刚设的密码忘记了 卸载重装！ asd990711","categories":[],"tags":[]},{"title":"网易云音乐解锁灰歌-MacOS","slug":"网易云音乐解锁灰歌-MacOS","date":"2021-03-27T16:23:21.000Z","updated":"2021-03-27T16:33:13.430Z","comments":true,"path":"2021/03/28/网易云音乐解锁灰歌-MacOS/","link":"","permalink":"https://panlianghnu.github.io/2021/03/28/%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E8%A7%A3%E9%94%81%E7%81%B0%E6%AD%8C-MacOS/","excerpt":"","text":"网易云音乐解锁灰歌For MacOS github链接 简易版本123git clone https://github.com/nondanee/UnblockNeteaseMusic.gitcd UnblockNeteaseMusicnpm i 接着信任证书，双击目录下的 ca.crt 文件，点击添加 输入密码后再双击： 按照指引点击，输入密码 1. 寻找网易云服务器的IP1ping music.163.com 得到IP：59.111.181.60 2. 向hosts文件添加记录1234sudo vim /etc/hostsappend127.0.0.1 music.163.com127.0.0.1 interface.music.163.com 3. 设置参数启动12cd UnblockNeteaseMusicnode app.js -p 80:443 -f 59.111.181.60 接着使用 safari 打开 https://music.163.com 确保可以访问（如果弹出无法访问，再信任一次） 重启网抑云～ 或者可以使用别人的一键脚本： unblockNeteaseShell","categories":[],"tags":[]},{"title":"Flask+Vue 前后端分离JWT用户验证","slug":"Flask-Vue-前后端分离JWT用户验证","date":"2021-03-25T08:35:28.000Z","updated":"2021-03-25T09:12:04.860Z","comments":true,"path":"2021/03/25/Flask-Vue-前后端分离JWT用户验证/","link":"","permalink":"https://panlianghnu.github.io/2021/03/25/Flask-Vue-%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBJWT%E7%94%A8%E6%88%B7%E9%AA%8C%E8%AF%81/","excerpt":"","text":"传统Flask通过Flask-Login的login_user()解决登录问题，通过session进行处理，不适合前后端分离系统，所以使用JWT进行用户认证 传统Flask通过Flask-Login的login_user()解决登录问题，通过session进行处理，不适合前后端分离系统，所以使用JWT进行用户认证 Session-cookie:Session是对于服务端来说的，客户端是没有Session一说的。Session是服务器在和客户端建立连接时添加客户端连接标志，最终会在服务器软件(Apache、Tomcat、JBoss)转化为一个临时Cookie(SessionId)发送给给客户端，当客户端请求时服务器会检查是否携带了这个SessionId(临时Cookie)，如果没有则会要求重新登录。 问题： 如果我们的页面出现了 XSS 漏洞，由于 cookie 可以被 JavaScript 读取，XSS 漏洞会导致用户SessionId泄露，而作为后端识别用户的标识，cookie 的泄露意味着用户信息不再安全。在设置 cookie 的时候，其实你还可以设置 httpOnly 以及 secure 项。设置 httpOnly 后 cookie 将不能被 JS 读取，浏览器会自动的把它加在请求的 header 当中，设置 secure 的话，cookie 就只允许通过 HTTPS 传输。 httpOnly 选项使得 JS 不能读取到 cookie，那么 XSS 注入的问题也基本不用担心了。但设置 httpOnly 就带来了另一个问题，就是很容易的被 XSRF或CSRF(跨站请求伪造)。当你浏览器开着这个页面的时候，另一个页面可以很容易的跨站请求这个页面的内容。因为 cookie 默认被发了出去。 由于后端保存了所有用户的Session，后端每次都需要根据SessionId查出用户Session进行匹配，加大了服务器端的压力。 JWT:JWT 是一个开放标准(RFC 7519)，它定义了一种用于简洁，自包含的用于通信双方之间以 JSON 对象的形式安全传递信息的方法。JWT 可以使用 HMAC 算法或者是 RSA 的公钥密钥对进行签名。它具备两个特点： 简洁(Compact) 可以通过URL, 参数或者在 HTTP header 发送，因为数据量小，传输速度快 自包含(Self-contained) 负载中包含了所有用户所需要的信息，避免了多次查询数据库 JWT一共由三部分组成，header（头部）、payload（负载）、signature（签名）通过‘.’进行拼接 header(头部) 转Base64 payload(负载) 自定义信息内容, 不建议存储敏感信息(如密码) 转Base64 signature(签名) 一共三部分。转base64的header和转base64的payload拼接之后，然后使用header中声明的加密方式和secret加盐的方式加密字符串 转Base64的header 转Base64的payload secret(私钥) 最后一步签名的过程，实际上是对头部以及负载内容进行签名，防止内容被窜改。如果有人对头部以及负载的内容解码之后进行修改，再进行编码，最后加上之前的签名组合形成新的JWT的话，那么服务器端会判断出新的头部和负载形成的签名和JWT附带上的签名是不一样的。如果要对新的头部和负载进行签名，在不知道服务器加密时用的密钥的话，得出来的签名也是不一样的。 iss 签发者 sub 面向的用户 aud 接收jwt的一方 exp 过期时间(必须大于签发时间jat) nbf 定义在什么时间之前，该jwt都是不可用的 jat 签发时间 jti 唯一身份标识，主要用来作为一次性token,从而回避重放攻击 alg 加密算法 typ 类型 差异比较 Session方式存储用户id的最大弊病在于Session是存储在服务器端的，所以需要占用大量服务器内存，对于较大型应用而言可能还要保存许多的状态。一般而言，大型应用还需要借助一些KV数据库和一系列缓存机制来实现Session的存储。 JWT方式将用户状态分散到了客户端中，可以明显减轻服务端的内存压力。除了用户id之外，还可以存储其他的和用户相关的信息，例如该用户是否是管理员、用户所在的分组等。虽说JWT方式让服务器有一些计算压力（例如加密、编码和解码），但是这些压力相比磁盘存储而言可能就不算什么了。具体是否采用，需要在不同场景下用数据说话 单点登陆 Session方式来存储用户id，一开始用户的Session只会存储在一台服务器上。对于有多个子域名的站点，每个子域名至少会对应一台不同的服务器，例如：www.taobao.com，nv.taobao.com，nz.taobao.com，login.taobao.com。所以如果要实现在login.taobao.com登录后，在其他的子域名下依然可以取到Session，这要求我们在多台服务器上同步Session。使用JWT的方式则没有这个问题的存在，因为用户的状态已经被传送到了客户端。 JWT认证流程 首先，前端通过Web表单将自己的用户名和密码发送到后端的接口。这一过程一般是一个HTTP POST请求。建议的方式是通过SSL加密的传输（https协议），从而避免敏感信息被嗅探。 后端核对用户名和密码成功后，将用户的id等其他信息作为JWT Payload（负载），将其与头部分别进行Base64编码拼接后签名，形成一个JWT。形成的JWT就是一个形同hhh.ppp.sss的字符串。 后端将JWT字符串作为登录成功的返回结果返回给前端。前端可以将返回的结果保存在localStorage或sessionStorage上，退出登录时前端删除保存的JWT即可。 前端在每次请求时将JWT放入HTTP Header中的Authorization位。(解决XSS和XSRF问题) 后端检查是否存在，如存在验证JWT的有效性。例如，检查签名是否正确；检查JWT是否过期；检查JWT的接收方是否是自己 验证通过后后端使用JWT中包含的用户信息进行其他逻辑操作，返回相应结果。 Vue前端Vue-router成功登录时，将后端返回的jwt存入sessionStorage 使用Vue-router在前端每次界面切换前都判断jwt，不符合要求则跳转至login登录界面 1234567891011121314151617181920212223242526272829303132333435363738394041// 路由守护router.beforeEach((to, from, next)=&gt;&#123; const accessToken = window.sessionStorage.getItem(&#x27;accessToken&#x27;) if(accessToken) &#123; // 重新登录后，转到之前的页面 if(Object.keys(from.query).length !== 0) &#123; let redirect = from.query.redirect if(to.path === redirect) // 解决无限循环问题 &#123; next() &#125; else &#123; next(&#123;path:redirect&#125;) // 重新登录后，转到之前的页面 &#125; &#125; &#125; if(accessToken &amp;&amp; to.path !== &#x27;/login&#x27;) &#123; // 有token 但不是去 login页面 next() &#125; else if(accessToken &amp;&amp; to.path === &#x27;/login&#x27;) &#123; //用户已经登陆，不让访问Login登录界面 next(&#123;path: from.fullPath&#125;) &#125; else if(!accessToken &amp;&amp; to.path !== &#x27;/login&#x27;) &#123; // 未登录 next(&#x27;/login&#x27;) &#125; else &#123; next() &#125;&#125;) axiosaxios 全局配置拦截器 request拦截器每次向后端请求携带header头Authorization信息 12345678910111213// http request 拦截器axios.interceptors.request.use( config =&gt;&#123; if(sessionStorage.getItem(&quot;accessToken&quot;)) &#123; config.headers.Authorization = sessionStorage.getItem(&quot;accessToken&quot;) &#125; return config; &#125;, err =&gt; &#123; return Promise.reject(err); &#125;) response拦截器若接收到401错误，则是未登录，无权访问，则清除sessionStorage信息并跳转至login登录界面 1234567891011121314151617181920212223/ http response 拦截器axios.interceptors.response.use( response =&gt; &#123; return response; &#125;, error =&gt; &#123; if(error.response)&#123; console.log(&#x27;axios:&#x27; + error.response.status); switch(error.response.status)&#123; case 401: // 返回401 清除token信息并跳转到登录页面 sessionStorage.clear() router.replace(&#123; path: &#x27;/login&#x27;, query: &#123;redirect: router.currentRoute.fullPath&#125; // 重新登录后，返回之前的页面 &#125;) Message(&#123;showClose:true, message:&#x27;未登录，返回登陆界面&#x27;, type:&#x27;error&#x27;, duration:3000&#125;) &#125; &#125; return Promise.reject(error); // 返回接口的错误信息 &#125;) Flask后端 安装PyJWT pip install PyJWT 编写JWT生成函数与解密函数(util.py) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253key = &quot;123456&quot; # secret私钥,可通过配置文件导入def generate_access_token(username: str = &quot;&quot;, algorithm: str = &#x27;HS256&#x27;, exp: float = 2): &quot;&quot;&quot; 生成access_token :param username: 用户名(自定义部分) :param algorithm: 加密算法 :param exp: 过期时间 :return:token &quot;&quot;&quot; now = datetime.utcnow() exp_datetime = now + timedelta(hours=exp) access_payload = &#123; &#x27;exp&#x27;: exp_datetime, &#x27;flag&#x27;: 0, #标识是否为一次性token，0是，1不是 &#x27;iat&#x27;: now, # 开始时间 &#x27;iss&#x27;: &#x27;leon&#x27;, # 签名 &#x27;username&#x27;: username #用户名(自定义部分) &#125; access_token = jwt.encode(access_payload, key, algorithm=algorithm) return access_tokendef decode_auth_token(token: str): &quot;&quot;&quot; 解密token :param token:token字符串 :return: &quot;&quot;&quot; try: payload = jwt.decode(token, key=key, algorithms=&#x27;HS256&#x27;) except (jwt.ExpiredSignatureError, jwt.InvalidTokenError, jwt.InvalidSignatureError): return &quot;&quot; else: return payloaddef identify(auth_header: str): &quot;&quot;&quot; 用户鉴权 &quot;&quot;&quot; if auth_header: payload = decode_auth_token(auth_header) if not payload: return False if &quot;username&quot; in payload and &quot;flag&quot; in payload: if payload[&quot;flag&quot;] == 0: return payload[&quot;username&quot;] else: return False return False 编写登录保护函数(util.py) 1234567891011121314151617def login_required(f): &quot;&quot;&quot; 登录保护，验证用户是否登录 :param f: :return: &quot;&quot;&quot; @wraps(f) def wrapper(*args, **kwargs): token = request.headers.get(&quot;Authorization&quot;, default=None) if not token: return &#x27;not Login&#x27;,&#x27;401 Permission Denied&#x27; username = identify(token) if not username: return &#x27;not Login&#x27;,&#x27;401 Permission Denied&#x27; # return 响应体, 状态码, 响应头 return f(*args, **kwargs) return wrapper tips: Flask的Response常用返回 return 响应体, 状态码, 响应头","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://panlianghnu.github.io/tags/python/"},{"name":"Flask","slug":"Flask","permalink":"https://panlianghnu.github.io/tags/Flask/"},{"name":"Vue","slug":"Vue","permalink":"https://panlianghnu.github.io/tags/Vue/"},{"name":"JWT","slug":"JWT","permalink":"https://panlianghnu.github.io/tags/JWT/"}]},{"title":"直播小工具","slug":"直播小工具","date":"2021-03-15T05:33:01.000Z","updated":"2021-03-15T07:13:48.280Z","comments":true,"path":"2021/03/15/直播小工具/","link":"","permalink":"https://panlianghnu.github.io/2021/03/15/%E7%9B%B4%E6%92%AD%E5%B0%8F%E5%B7%A5%E5%85%B7/","excerpt":"","text":"直播小工具前言最近有充分的时间摸鱼…我捣鼓了一个看直播的小工具 - inspired by Zlive 自从我手机端下载了Z直播，我就卸载了其他直播软件（斗鱼、虎牙），一个软件看各大平台直播实在是太好了。而且它还轻便，不用注册，没广告，没礼物，没全站喇叭…… 可惜，Z直播并没有PC客户端，我就想着自己捣鼓一个程序看全网直播，不拘束于各大平台。 特点优雅地看直播 跨直播平台 无广告 高清流畅 没有礼物特效 无需注册账号 展示下面是GIF： 如何使用12git clone https://github.com/panlianghnu/WatchLive_cross-platform.gitcd WatchLive_cross-platform/ 1、安装依赖1pip install 2、修改订阅按照 “平台” “房间号” “标注” 的格式，每一行代表一个直播间，行内元素用空格分开 如图: 3、修改播放器第 59 行，修改 open_app 的值，改成自己的支持流媒体输出的视频播放器的路径，比如你是 IINA 播放器，就写 open_app = “open -a /Applications/IINA.app” 如果不是 MacOS ，可能命令不是 open -a，需要自己修改 4、运行在当前目录直接运行 python main.py 即可啦 可以像我一样在桌面放置一个 shell 文件，修改路径为自己的 shell 和 main.py 123#! /bin/zsh## author:panliangpython ~/real-url/main.py 本工具仅在 python3 的环境测试 获取斗鱼的直播源，需 JavaScript 环境，可使用 node.js 实现原理流媒体地址获取参考 real-url 通过 real-url 获取直播间的真实播放源，然后通过一些可以播放流媒体的播放器打开播放源，达到不用注册、不用看广告、直接高清观看直播的目的 可以打开直播源的播放器很多：INNA、PotPlayer、VLC、DPlayer…… 源代码","categories":[],"tags":[]},{"title":"杭电OJ","slug":"杭电OJ","date":"2021-03-14T09:05:52.000Z","updated":"2021-03-14T14:50:13.190Z","comments":true,"path":"2021/03/14/杭电OJ/","link":"","permalink":"https://panlianghnu.github.io/2021/03/14/%E6%9D%AD%E7%94%B5OJ/","excerpt":"","text":"刷刷OJ放松一下1001-数列和原题链接 这个题目就是给一个正整数n，求 sum = 1 + 2 + 3 + … + n 我的第一反应就是循环相加或者递归相加复杂度太高，可能过不了。直接用求和公式即可 当我写下 sum = (n+1)*n/2 以为稳过的时候，提交后 err 了。。。想了很久代码应该没问题，去网上查发现这个题递归就能AC，崩溃！最后发现是中间结果爆 int 了，改成判断奇偶做就 AC 了 12345678910111213141516171819//// main.c// OJ-HD-1004//// Created by panliang on 2021/3/12.//#include &lt;stdio.h&gt;int main(int argc, const char * argv[]) &#123; int n; while (scanf(&quot;%d&quot;,&amp;n)!=EOF) &#123; n%2==0? printf(&quot;%d\\n\\n&quot;,n/2*(n+1)) : printf(&quot;%d\\n\\n&quot;,(n+1)/2*n); &#125; return 0;&#125; 1002-大数相加原题链接 这个题目就是不断输入两个正整数，然后求他们的和，数据很大很大，需要用高精度来做 用字符串保存数据，一步步模拟加法过程即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172//// main.c// OJ-HD-1002//// Created by panliang on 2021/3/12.//#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#define maxsize 1010char* plus(char*,char*);int main(int argc, const char * argv[]) &#123; // two big positive integer plus int n,i=1; scanf(&quot;%d&quot;,&amp;n); for(;i&lt;=n;i++)&#123; char a[maxsize]; memset(a,0,sizeof(char)*maxsize); char b[maxsize]; memset(b,0,sizeof(char)*maxsize); scanf(&quot;%s%s&quot;,a,b); char* c = plus(a,b); // a plus b if(i&gt;1) printf(&quot;\\n&quot;); printf(&quot;Case %d:\\n%s + %s = %s\\n&quot;,i,a,b,c); &#125; return 0;&#125;void reverse(char* a)&#123; char tmp[maxsize]; strcpy(tmp,a); unsigned long len = strlen(a); int i=0; for (;i&lt;len;i++) &#123; a[i] = tmp[len-i-1]; &#125;&#125;char* plus(char* a,char* b)&#123; reverse(a); reverse(b); char* c = malloc(sizeof(char)*maxsize); memset(c,0,sizeof(char)*maxsize); int i=0; for (;i&lt;maxsize;i++) &#123; // 按位相加 if (a[i]+b[i]) &#123; // 如果不同时为&#x27;\\0&#x27; c[i] = &#x27;0&#x27;; if (a[i]&gt;=&#x27;0&#x27;) &#123; c[i] += a[i] - &#x27;0&#x27;; &#125; if (b[i]&gt;=&#x27;0&#x27;) &#123; c[i] += b[i] - &#x27;0&#x27;; &#125; &#125; &#125; // 处理进位，两个数相加无需回溯考虑，最多也就19 =&gt; 9 for (i=0;i&lt;maxsize-1;i++) &#123; if(c[i]&gt;&#x27;9&#x27;)&#123; c[i] -= 10; c[i+1]++; &#125; &#125; reverse(a); // 程序健壮性 reverse(b); // reverse只是方便处理相加，返回前应该复原 reverse(c); return c;&#125; 1003-最大子序列和原题链接 给一个序列，求一个子序列，要求这个子序列的和，是所有子序列的和中最大的那个。输出子序列的和、起始索引、终止索引 这个题目我的第一反应是二维动态规划，使用一个数组 dp[i][j] 表示 sum = arr[i]+…+arr[j]，然后数据太大爆内存了。。后来发现这个题目好像没有必要二维动态规划，只是求最大值而已，一维即可。 做法是遍历数组，需要5个变量作为中间变量 sum : 记录最大子序列的和，最终输出 left : 记录最大子序列的左索引，最终输出 right : 记录最大子序列的右索引，最终输出 tmp_sum : 保存中间序列的和，动态变化，不断和 sum 比较大小 tmp_left : 保存中间序列的左索引，如果中间序列的和是负数，则开新窗口，移动 tmp_left 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//// main.c// OJ-HD-1003//// Created by panliang on 2021/3/12.//#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define maxsize 100010int arr[maxsize];int main(int argc, const char * argv[]) &#123; int t; scanf(&quot;%d&quot;,&amp;t); int cases=1; for(;cases&lt;=t;cases++)&#123; memset(arr,0,sizeof(arr)); int len,i; scanf(&quot;%d&quot;,&amp;len); for (i=0;i&lt;len;i++) &#123; scanf(&quot;%d&quot;,&amp;arr[i]); &#125; // 求 arr 的最大子序列和 // 二维动态规划必定爆内存，100010*100010*sizeof(int) // dp[i][j] = sum of arr[i] +...+ arr[j] int left=0,right=0,sum=-1010,tmp_sum=0,tmp_left=0; for (i=0;i&lt;len;i++) &#123; tmp_sum += arr[i]; if (tmp_sum &gt; sum) &#123; sum = tmp_sum; left = tmp_left; right = i; &#125; if(tmp_sum &lt; 0)&#123; tmp_left = i+1; tmp_sum = 0; &#125; &#125; if(cases&gt;1)&#123; printf(&quot;\\n&quot;); &#125; printf(&quot;Case %d:\\n%d %d %d\\n&quot;,cases,sum,left+1,right+1); &#125; return 0;&#125; 1004-Let the Balloon Rise原题链接 输入N(0&lt;N&lt;=1000)个字符串，求出现次数最多的字符串 最简单的就是使用 map，但是C语言标准库没有 string，也没有 map 。。。 我看N不大，没有用 hash，直接使用数组也过了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//// main.c// OJ-HD-1004//// Created by panliang on 2021/3/14.//#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;struct&#123; char str[16]; int num;&#125; colors[1010];int len=0;void insertColor(const char* toinsert)&#123; strcpy(colors[len].str,toinsert); colors[len++].num = 1;&#125;void clearColor()&#123; len=0;&#125;void handleColor(const char* str)&#123; // 找到则+1，没找到则 insert int i; for (i=0;i&lt;len;i++) &#123; if (strcmp(colors[i].str, str) == 0) &#123; colors[i].num++; return; &#125; &#125; insertColor(str);&#125;const char* maxColor()&#123; int i,tmpMax=0; char* res=&quot;&quot;; for (i=0;i&lt;len;i++) &#123; if (tmpMax &lt; colors[i].num) &#123; tmpMax = colors[i].num; res = colors[i].str; &#125; &#125; return res;&#125;int main(int argc, const char * argv[]) &#123; // hashmap[] is the best way, but c has no stl int n,i; while (scanf(&quot;%d&quot;,&amp;n) &amp;&amp; n) &#123; clearColor(); for (i=0;i&lt;n;i++) &#123; char str[16]; scanf(&quot;%s&quot;,str); handleColor(str); &#125; printf(&quot;%s\\n&quot;,maxColor()); &#125; return 0;&#125; 1005-Number Sequence原题链接 f(1) = 1, f(2) = 1, f(n) = (A f(n - 1) + B f(n - 2)) mod 7. 给你 A B n， (1 &lt;= A, B &lt;= 1000, 1 &lt;= n &lt;= 100,000,000)，求 f(n) 这个题目涉及到 mod 运算，那么贴一个 mod 运算的性质 模运算满足结合律、交换律、分配率，具体如下： A. 结合律 ((a+b)%p+c)%p=(a+(b+c)%p)%p ((ab)%p c)%p= (a (bc)%p)%p B. 交换律 (a+b)%p=(b+a)%p (ab)%p=(ba)%p C. 分配率 (a+b)%p=(a%p+b%p)%p ((a+b)%pc)%p = ( (ac)%p + (b*c)%p )%p 所以这个题目我可以先对输入的 A、B求mod，不会影响最终的结果，大幅缩小A、B的值会让中间的乘法运算更快，然后我交了一次，超时了。。。 我开始找数组的规律，可以发现 f(i) 只和 f(i-1) f(i-2) 有关，f(1) = f(2) = 1，所以只要当后面计算出来的结果也有连续的1，这个数字序列就进入了循环了，上代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//// main.c// OJ-HD-1005//// Created by panliang on 2021/3/14.//////A number sequence is defined as follows://f(1) = 1, f(2) = 1, f(n) = (A * f(n - 1) + B * f(n - 2)) mod 7.//Given A, B, and n, you are to calculate the value of f(n).// 周期性函数,什么时候 one two 都变成1 ，就是一个周期到了//#include &lt;stdio.h&gt;int main(int argc, const char * argv[]) &#123; int a,b,n,i; while (scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;n) &amp;&amp; (a+b+n)) &#123; if(n==1 || n==2)&#123; printf(&quot;1\\n&quot;); continue; &#125; a = a%7; b = b%7; int tmp=0,one=1,two=1;; int circle = 0; // 新增一个数组，循环最多49次就会出现 for (i=3;i&lt;=n;i++) &#123; tmp = (a*two + b*one)%7; // tmp = f(i) one = two; // one = f(i-1) two = tmp; // two = f(i) if (one == 1 &amp;&amp; two == 1) &#123; // 周期 --&gt; f(i) = f(2) f(i-1) = f(1) circle = i-2; n = n%circle + circle; // 加一个circle 防止落在0 , 大幅度缩小 n.... md还是超时... break; &#125; &#125; if (circle) &#123; if(n==1 || n==2)&#123; printf(&quot;1\\n&quot;); continue; &#125; for (i=3;i&lt;=n;i++) &#123; tmp = (a*two + b*one)%7; // tmp = f(i) one = two; // one = f(i-1) two = tmp; // two = f(i) &#125; &#125; printf(&quot;%d\\n&quot;,tmp); &#125; return 0;&#125; 提交！ 还是超时了😭 我去看看别人的博客发现了序列的循环不一定是整个循环，可能出现序列运行一段时间然后陷入循环，这个时候循环的部分不一定是以连续两个1开始。 知道了错误即可重新优化 n 的值 定义一个 hasShow[one][two] ，保存连续出现的两个值 one two 的索引（保存的是 one 的索引） 每次迭代计算新的 one two 时，标记 hasShow，直到命中 hasShow，即可确定循环在何处开始，训话你的大小是多少。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;#include &lt;string.h&gt;int hasShow[7][7]; // hasShow[one][two] 代表 one two 排列已经出现，值为one出现的indexint main(int argc, const char * argv[]) &#123; int a,b,n,i; while (scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;n) &amp;&amp; (a+b+n)) &#123; if(n==1 || n==2)&#123; printf(&quot;1\\n&quot;); continue; &#125; a = a%7; b = b%7; memset(hasShow,0,sizeof(hasShow)); hasShow[1][1] = 1; // one=1 two=1 已经出现， index of one is 1 int tmp=0,one=1,two=1; int fall_in_cycle = 0; for (i=3;i&lt;=n;i++) &#123; tmp = (a*two + b*one)%7; // tmp = f(i) one = two; // one = f(i-1) two = tmp; // two = f(i) if (hasShow[one][two]) &#123; // cycle is (index of one - hasShow[one][two]) and now one is i-1 int cycle = i-1 - hasShow[one][two]; // 然后就可以定位 n 了，从 hasShow[one][two]开始,不断按照cycle循环 n = n - (hasShow[one][two]-1); // 减去循环前的一段 int index = n%cycle; //找到落在每个循环的 index 0 &lt;= index &lt;= cycle n = (i-1)-1 + index; // 将 n 定位到循环中去 fall_in_cycle = cycle; break; &#125; else&#123; hasShow[one][two] = i-1; // one 出现的 index &#125; &#125; // 已经找到 n 的缩小值 one=two=1;tmp=0; for (i=3;i&lt;=n;i++) &#123; tmp = (a*two + b*one)%7; // tmp = f(i) one = two; // one = f(i-1) two = tmp; // two = f(i) &#125; printf(&quot;%d\\n&quot;,tmp); &#125; return 0;&#125; 2012-素数判断原题链接 对于表达式n^2+n+41，当n在（x,y）范围内取整数值时（包括x,y）(-39&lt;=x&lt;y&lt;=50)，判定该表达式的值是否都为素数。 经典大素数判定问题，大一上的ACM选修课专门讲过… 如果我们对每一个数进行素数判断，而素数判断的复杂度又是 O(n)，那么复杂度就是 O(n^2)，而数据很大的情况绝对是超时的。所以我们采用填坑法，所有素数的倍数都不是素数，其他的数就是素数了，填坑法的复杂度只需要 O((logn)^2)，所以没被填的坑就是素数了，最后的判断就很简单了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//// main.c// OJ-HD-2012//// Created by panliang on 2021/3/11.//#include &lt;stdio.h&gt;#include &lt;string.h&gt;int prime[2610];int isPrime(int);void initPrime();int main(int argc, const char * argv[]) &#123; initPrime(); // number = n^2+n+41 // n = x ~ y // n is between 41 ~ 2591 int x,y,n,number; while (scanf(&quot;%d%d&quot;,&amp;x,&amp;y) &amp;&amp;!(x==0&amp;&amp;y==0)) &#123; int isPutSorry=0; n = x; while(n&lt;=y) &#123; number = n*n+n+41; if (!isPrime(number)) &#123; printf(&quot;Sorry\\n&quot;); isPutSorry=1; break; &#125; n++; &#125; if(!isPutSorry) printf(&quot;OK\\n&quot;); &#125; return 0;&#125;void initPrime()&#123; memset(prime,0,sizeof(prime)); // 初始化为0 =&gt; 都是素数 // 51*51 = 2601 int i=2; // 所有素数的倍数都不是素数 for (;i&lt;=51;i++) &#123; int t=2; for (;t&lt;=i;t++) &#123; prime[i*t] = 1; // 标记为1 =&gt; 不是素数 &#125; &#125;&#125;int isPrime(int a)&#123; return prime[a]?0:1;&#125; 2025-查找最大元素原题链接 对于输入的每个字符串，查找其中的最大字母，在该字母后面插入字符串“(max)”。 这是一个简单的 ascii 字符排序问题 处理输入的时候因为可能有空格，需要自己写一个 getLine() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//// main.c// OJ-HD-2025//// Created by panliang on 2021/3/11.//#include &lt;stdio.h&gt;#include &lt;string.h&gt;void getLine(char*);int table[300];int main(int argc, const char * argv[]) &#123; char str[110]; while(1)&#123; getLine(str); if(str[0] == &#x27;\\0&#x27;) break; memset(table,0,sizeof(table)); int i=0; for (;i&lt;110;i++) &#123; // 扫描输入字符串,打表 if(str[i] == &#x27;\\0&#x27;) break; table[str[i]]++; &#125; char maxchar = 0; for(i=299;i&gt;0;i--)&#123; // 反向扫描table 找到 maxchar if(table[i] != 0)&#123; maxchar = i; break; &#125; &#125; for(i=0;i&lt;110;i++) &#123; if (str[i] == &#x27;\\0&#x27;) break; if (str[i] == maxchar) &#123; printf(&quot;%c(max)&quot;,str[i]); &#125; else&#123; printf(&quot;%c&quot;,str[i]); &#125; &#125; printf(&quot;\\n&quot;); &#125; return 0;&#125;void getLine(char * str)&#123; int i=0; while(1)&#123; char c = getchar(); if(c == &#x27;\\n&#x27; || c == EOF)&#123; str[i] = &#x27;\\0&#x27;; break; &#125; str[i++] = c; &#125;&#125; 2058-The sum problem原题链接 给定一个序列 1，2，3，…N，你的工作是计算所有可能的子序列，子序列的和是M。 输入：N，M（ 1 &lt;= N, M &lt;= 1000000000 ） 需要输出所有可能的序列 [x,y] 使得 x+…+y = M 又是子序列和的题目，我第一反应就是用等差数列求和公式+滑动窗口来做，这样时间复杂度是O(n)，因为每次循环 a 和 b 都在单向移动，但是超时了。 这是滑动窗口的代码 12345678910111213141516171819#include &lt;stdio.h&gt;int main()&#123; int n,m; while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m) &amp;&amp; n+m)&#123; int a=1,b=1,sum=0; while(b&lt;n)&#123; sum = (a+b)*(b-a+1)/2; if(sum&lt;m) b++; else if(sum&gt;m) a++; else&#123; printf(&quot;[%d,%d]&quot;,a,b); b++; &#125; &#125; &#125;&#125; 超时了之后我考虑优化滑动窗口。我想着让窗口从右往左滑动，这样窗口大小不会变小，想着这样可能不会有回溯的过程，，写了半天最后发现其实并没有提高效率，还是超时了。但是从窗口大小的角度思考让我得到了灵感！ 假设有 n 个窗口能够满足序列和刚好是 M，那么这 n 个窗口的长度一定是越来越短的，因为窗口内的元素越来越大了 分析一下每个窗口应该是什么情况： 如果这个窗口宽度为1，那么显然就是 M 本身，也就是输出 [M,M] 如果这个窗口宽度为2，那么显然是这样的：(M/2向下取整) + (M/2向上取整) 如果这个窗口宽度为3，那么显然是这样的：(M/3-1) + (M/3) + (M/3+1) …… 显然窗口宽度和窗口内容是密切相关的 这样复杂度会显著降低了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//// main.c// OJ-HD-2058//// Created by panliang on 2021/3/11.//#include &lt;stdio.h&gt;#define maxsize 200int length = 0;int stack[maxsize][2];int isEmpty()&#123; return !length;&#125;void push(int l,int r)&#123; stack[length][0] = l; stack[length][1] = r; length++;&#125;void pop()&#123; if(isEmpty()) return; length--; printf(&quot;[%d,%d]\\n&quot;,stack[length][0],stack[length][1]);&#125;int main(int argc, const char * argv[]) &#123; int n,m; while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m) &amp;&amp; n &amp;&amp; m)&#123; int num=1; while(num&lt;m)&#123; if(num%2 == 1 &amp;&amp; m%num == 0)&#123; // num 为奇数 且能被m整除 int center = m/num; int l = center-num/2; if(l&lt;=0)&#123; break; &#125; int r = center+num/2; push(l,r); &#125; else if(num%2 == 0)&#123; // num 为偶数 int centerSmall = m/num; int l = centerSmall - num/2 + 1; if(l&lt;=0)&#123; break; &#125; int r = centerSmall + num/2; int sum = (l+r)*num/2; if(sum == m) push(l,r); &#125; else&#123; // none &#125; num++; &#125; while(!isEmpty())&#123; pop(); &#125; printf(&quot;\\n&quot;); &#125; return 0;&#125; 为了反过来输出结果，我写了一个栈。虽然对窗口大小由大到小遍历可以省略栈，但是会增加遍历的次数，窗口由小往大遍历的话我们就可以在 (这种情况) =&gt; {要从负数开始加到正数才等于M} 直接跳出循环，这时窗口更大是不可能了，窗口最左边已经到负数了，跳出循环可以显著降低循环次数。 这次终于AC了！","categories":[],"tags":[]},{"title":"ML学习笔记-2","slug":"ML学习笔记-2","date":"2021-03-10T07:10:34.000Z","updated":"2021-03-14T14:59:14.510Z","comments":true,"path":"2021/03/10/ML学习笔记-2/","link":"","permalink":"https://panlianghnu.github.io/2021/03/10/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/","excerpt":"","text":"学习算法可能有很多 feature、attribute 如何处理无穷多的 feature 而不爆内存，比如 support vector machine 监督学习就是对数据集标 label ，然后算法预测正确值 机器学习无监督学习聚类算法聚类算法-clustering: 给许多没有label或相同label的数据，在data set 里面找到structure，分成几个 cluster，这就叫聚类算法 比如谷歌新闻每天收集成千上万的新闻，将他们组成一个个新闻专题，点击URL跳转到其他公司的网站 比如社交网络划分圈子，比如客户画像 聚类算法和分类算法的比较 聚类分析是研究如何在没有训练的条件下把样本划分为若干类。在分类中，对于目标数据库中存在哪些类是知道的，要做的就是将每一条记录分别属于哪一类标记出来。聚类需要解决的问题是将已给定的若干无标记的模式聚集起来使之成为有意义的聚类，聚类是在预先不知道目标数据库到底有多少类的情况下，希望将所有的记录组成不同的类或者说聚类，并且使得在这种分类情况下，以某种度量（例如：距离）为标准的相似性，在同一聚类之间最小化，而在不同聚类之间最大化。无监督学习不依赖预先定义的类或带类标记的训练实例，需要由聚类学习算法自动确定标记 分类学习的实例或数据样本有类别标记。 鸡尾酒会问题两个人都在说话，传到两个距离不一的麦克风，用算法将叠加在一起的声音们分离出开。将多个音源的录音分离出声音。 吴恩达推荐 octave，作为机器学习编程环境 矩阵乘法具有结合律但没有交换律 AxBxC = Ax(BxC) AxB != BxA 多元线性回归假设函数 x 是一个包含 features 的 vector，乘以各个待求系数的 vector，即为假设函数 使用梯度下降解决多元线性回归 不断地求 cost function 各个参数的偏导，然后向量减法调整参数的值 怎么求偏导不重要，各种开源库 特征缩放假设x1是房屋面积(0~2000)，x2是卧室数量(0~5) 他们取值范围差别很大时，最终的梯度下降等高线会成为特别瘦长的椭圆，梯度下降会来回振荡(偏导可能不会指向 HIT )，下降的很慢 尽量让 feature 的取值集中在 -1 ~ 1 各个 feature 的数量级要一致 具体的操作为： 特征缩放不需要很精确，只是让梯度下降快速一些 feature 的次方不同时，参数进行特征缩放很重要： 学习率选择只要学习率足够小，cost function 会随着迭代不断下降，最终会收敛，但是算法效率会很慢 学习率太大，则可能不会每次 cost function 都下降，甚至无法收敛 正规方程法（非迭代）一次性求出参数的最佳值 算法： cost function 是参数的 function，那么可以直接求出该 function 的最小值，以及 cost function 取最小时，参数等于多少。比如求导+令导数=0。或者求出所有偏导并令所有偏导等于0。偏微分可能很复杂 梯度下降和正规方程法比较梯度下降 更普遍适用，即使有上百万 features 也可以正常运行 适合更复杂的学习算法 正规方程法： 不需要特征缩放，不需要选择学习率，不需要迭代，不用检查收敛，n 比较小时快得多 但是计算值的复杂度大概是 n^3，n 为 feature 数量，计算会比梯度下降慢很多，如果 n 大于万级，则不要使用正规方程法 不适合更复杂的学习算法，比如分类算法逻辑回归 向量化计算假设函数时，使用向量有很多好处 模型预测的向量化 h_\\theta(x) = \\sum_{j=0}^n \\theta_j x_j \\Rightarrow h_\\theta(x) = \\theta^Tx123prediction = 0.0for i in range(n): prediction = prediction + theta(i)*x(i) 向量化后变成 1234import numpy as nptheta = np.array([1,2,3])x = np.array([x1,x2,x3])prediction = np.matmul(theta.T, x) # 转置巨震 不需要自己写循环，而且更高效 Gradient descent 的向量化 变成了简单的 \\theta = \\theta - \\alpha \\delta \\delta = \\frac1m \\sum_{i=1}^m (h_\\theta x^{(i)}-y^{(i)})x^{(i)}逻辑回归(分类)最流行的学习算法 二分类比如可以简单的线性回归，设置一个阈值，大于输出1、小于输出0，但是这样做不准确，通常不是一个好主意，如图 训练样本的错误率很高，无法很好拟合 逻辑回归：令 h(x) 处在0和1之间 h_\\theta(x) = g(\\theta^Tx) g(z) = \\frac1{1+e^{-z}}这样就让 prediction 落在 [0,1] 了，function g is called logistics function","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://panlianghnu.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"AOPEDF学习","slug":"AOPEDF学习","date":"2021-03-03T11:26:04.000Z","updated":"2021-04-10T09:15:13.780Z","comments":true,"path":"2021/03/03/AOPEDF学习/","link":"","permalink":"https://panlianghnu.github.io/2021/03/03/AOPEDF%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"同构网络和异构网络同构网络同构网络：所有的节点有相同的 function，一个用户可以与下一个用户交换基本功能，比如，固定电话网络中，每个节点（电话）基本上执行与其他任何节点相同的功能，并且人们出于相同的原因使用电话。通常，电信网络是同构的。 异构网络异构网络：节点不止有一个类别，按照功能和效用分成多个类别。比如，在HoneyBook市场网络中，活动策划和摄影师的行为就不一样，摄影师和花店的行为也不一样。eBay上的买方节点和卖方节点也不是同一个类，他们是异构网络。 实验复现BUG1K-Fold交叉验证，参数多了一个 label[:,0]，n_folds 参数找不到（应该是 n_splits ?） 12345def __init__(self, n_splits=&#x27;warn&#x27;, shuffle=False, random_state=None): if n_splits == &#x27;warn&#x27;: warnings.warn(NSPLIT_WARNING, FutureWarning) n_splits = 3 super(StratifiedKFold, self).__init__(n_splits, shuffle, random_state) 论文 introduction识别DTI在药物发现领域很重要 药物发现已成为药物研发体系必不可少的技术之一，尤其是针对罕见病治疗药物和 神经保护药物的研发。考虑到体外实验昂贵且耗时，高效计算预测方法可以作为药物发 现的有效策略。在生物大数据的推动下，新一代基于网络分析方法的理性药物预测筛选 技术体系正在快速形成。系统地识别已知药物的分子靶点对于药物的开发和了解其意想 不到的副作用起着至关重要的作用。与传统的实验分析方法相比，预测药物-靶点相互作 用(DTI)的计算方法是非常理想的。此外，多组学技术和系统生物学方法的最新进展产 生了大规模的异质生物网络，为基于网络的已知药物新分子靶点的识别提供了意想不到 的机会。 实验预测DTI费时费力，目前有几种通过计算机辅助DTI预测的方法： 基于蛋白质结构的 基于蛋白质结构的方法通常需要蛋白质的三维结构，对于结构未知的蛋白质性能有限，然而结构未知才是大多数靶点的情况。 基于配体的 利用已知相互作用配体的常识进行预测，但是这种情况如果参考配体库中没有指明感兴趣 的化合物，这种方法就不能得到可靠的预测结果。 基于机器学习的 充分挖 掘了药物和靶点相关特征之间的潜在相关性，成为 DTI 预测的一种非常有前景的策略 除了已知的 DTI 数据外，药物和靶点的化学结构、蛋白质序列信息和其他特性也可 以通过其在生物系统中的各种功能作用来表征(例如蛋白质之间的相互作用和药物-疾病 关联)。事实上，通过整合来自不同数据源的不同信息，DTINet、MSCMF 和 HNM 等方法可以进一步提高 DTI 预测的准确性。然而，这些方法仍有一些局限性需要解决。 例如，在 MSCMF 中，给定 DTI 网络所采用的矩阵分解操作通过相应的药物和蛋白质 相似性矩阵进行正则化，这些矩阵是通过加权平均方案整合多个数据源获得的。在这种数据集成策略下，可能会发生大量信息丢失，从而导致次优解决方案。而 DTINet 首先使 用无监督的方式从异构网络数据源中自动学习药物和靶点的低维特征表示，然后应用归 纳矩阵完成法基于所学习的特征预测新的 DTI。在这样一个框架中，将特征学习与手头 的预测任务分离可能不会产生最优解，因为从无监督学习过程中学习的特征可能不是药 物或目标的最合适的表示，不适合最终的 DTI 预测任务。此外，通过限制学习模型仅采 用相对简单的形式(例如双线性或对数双线性函数)，这些方法可能不足以捕获异构网络 数据背后复杂的隐藏特征。 将传统卷积神经网络(CNN)推广到大规模图形数据的信息传递和聚合技术的最新进 展表明，与网络相关的预测任务的性能得到了显著改善。这启发我们结合更深层次的学 习模型，从一个高层次的异构网络数据源中提取复杂的信息，并发现新的 DTI。 Materials and methodsData resourceDTI information from DrugBank database、therapeutic target database、PharmGKB database. bioactivity(生物活性) data for drug–target pairs from ChEMBL、BindingDB、IUPHAR/BPS Guide to PHARMACOLOGY. chemical structure of each drug from DrugBank. DTI 需要满足以下三个条件才会被采纳： the human target is represented by a unique UniProt accession number the target is marked as ‘reviewed’ in the UniProt database 结合亲和力，包括Ki、Kd、IC50或EC50都&lt;=10 uM。我们使用低结合亲和力截止值10 lM，因为弱结合药物在治疗发展中也起着至关重要的作用 DTI网络连接了732种FDA批准的药物和1519种独特的人类靶点（蛋白质） 我们随机选择了未知药物-靶点对的匹配数（排除所有已知DTI）作为 negative samples 此外，我们还构建了九个药物网络 临床报告的药物-药物相互作用 药物-疾病联系 药物-副作用联系 化学相似性 来自解剖治疗化学分类系统的治疗相似性 靶序列衍生药物-药物相似性 基因本体生物学过程 基因本体细胞成分 基因本体分子功能 六个蛋白质网络 蛋白质-蛋白质相互作用 蛋白质-疾病联系 蛋白质序列相似性 基因本体生物学过程 基因本体细胞成分 基因本体分子功能 The detailed description for building 15 networks is provided in the SUPPLEMENTARY Methods 对于外部验证集，我们从DrugCentral数据库（Ursu et al.，2019）和ChEMBL数据库（Mendez et al.，2019）中通过排除训练集中重叠的药物-靶点对来组装最新的实验验证DTI。 分别来自DrugCentral和ChEMBL数据库的两个验证集之间存在部分重叠 训练集和两个外部验证集之间没有任何重叠的dti。 MethodsAs shown in Fig 1. AOPEDF 包括三个步骤 data preparation and benchmarking 保留任意阶相似度的网络嵌入（AROPE） 基于森林的深度DTI预测 首先整合15个网络，来组建一个复杂的异构网络，包含了各种信息、多个视角来预测新的DTI 然后我们保留每个网络的任意阶相似度去获取信息，用低维度的向量去表征药物和靶点 最后我们可以用深度森林分类器去预测潜在的DTIs AROPEDeep forest algorithm学习了药物和靶点的低维度向量表示之后，我们利用深度森林来进行预测，这为DNNs提供了一种以较低的计算代价学习超层次表示的方法。 DNNs中会使用分层处理原始特征，受DNNs影响，Deep forest 采用级联结构，每一层级收到的 feature information 都是被上一层处理过的，然后处理这些 feature information 后将 result 输出到下一层级 每一层都是决策树林的集合，例如集合的集合。多样性是集成构建的关键。 在此，我们使用 two random forests (RFs) two completely random tree forests two gradient boosting tree forests 每个 forests 包括500 trees，总共3000 trees 比如，每个森林会产生一个 class distribution (概率分布？) 的估计值，计算相关实例所在叶节点上不同类的训练实例的百分比，然后在同一林中的所有树上求平均值。 例如，每个森林将通过计算相关实例所在叶节点上不同类的训练实例的百分比，然后对同一森林中的所有树进行平均，从而产生类分布的估计 估计的类分布形成类向量，然后将其与原始特征向量串联以输入到级联的下一级（图1）。 这里，在二元分类中有两个类，六个森林中的每一个产生一个2D分类向量。总的来说，级联的下一级将接收12(2*6)个增强特征。 为了减少过度拟合的风险，每个森林产生的类向量通过k-折叠交叉验证（k1⁄45）生成。 具体而言，每个森林将用作训练 k-1 次数据，产生 k-1 个分类向量，然后将这些分类向量平均得到最终的分类向量，作为下一级级联的增强 features 在扩展到一个新的层级后，整个级联的性能将在验证集上估计，如果没有显著的性能增益，训练过程将终止，随后，自动确定层叠层数。 deepforest采用基于滑动窗口的多粒度扫描策略，通过扫描原始输入来提取局部特征，生成一系列局部低维特征向量。 然后利用这些低维向量训练一系列森林，得到输入向量的类分布。","categories":[],"tags":[]},{"title":"Vue学习1","slug":"Vue学习1","date":"2021-03-02T08:07:04.000Z","updated":"2021-03-25T08:42:18.980Z","comments":true,"path":"2021/03/02/Vue学习1/","link":"","permalink":"https://panlianghnu.github.io/2021/03/02/Vue%E5%AD%A6%E4%B9%A01/","excerpt":"","text":"VueJs声明式渲染Vue 应用会将其挂载到一个 DOM 元素(比如DIV) 上，然后对其完全控制 123&lt;div id=&quot;app&quot;&gt; &#123;&#123; message &#125;&#125;&lt;/div&gt; 123456var app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;Hello Vue!&#x27; &#125;&#125;) 结果显示 Hello Vue！ 不仅可以绑定到 DOM 的文本或 attribute，还可以绑定到 DOM 结构： 1234&lt;div id=&quot;app&quot;&gt; &lt;p v-if=&quot;seen&quot;&gt;可以看到吗&lt;/p&gt;&lt;/div&gt;&lt;button onclick=&quot;app.$data.seen=!app.$data.seen&quot;&gt;切换可见&lt;/button&gt; 123456var app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; seen: true, &#125;,&#125;) 当一个 Vue 实例被创建时，它将 data 对象中的所有的 property 加入到 Vue 的响应式系统中。当这些 property 的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。 当这些数据改变时，视图会进行重渲染。只有当 Vue 实例被创建时就已经存在于 data 中的 property 才是响应式的。也就是说如果你添加一个新的 property，比如：vm.newdata = ‘new’ ，则对 newdata 不触发渲染。如果你知道你会在晚些时候需要一个 property，但是一开始它为空或不存在，那么你仅需要设置一些初始值。data:{ newdata: ‘’ } 唯一的例外是使用 Object.freeze()，这会阻止修改现有的 property，也意味着响应系统无法再追踪变化。 Vue 实例还暴露了一些有用的实例 property 与方法，都以$开头，和用户自定义的 property 和 methods 区分： 12345678910111213var data = &#123; a: 1 &#125;var vm = new Vue(&#123; el: &#x27;#example&#x27;, data: data&#125;)vm.$data === data // =&gt; truevm.$el === document.getElementById(&#x27;example&#x27;) // =&gt; true// $watch 是一个实例方法vm.$watch(&#x27;a&#x27;, function (newValue, oldValue) &#123; // 这个回调将在 `vm.a` 改变后调用&#125;) 实例生命周期钩子(hook) 注意⚠️：钩子函数不要写成 ()=&gt;{} ，箭头函数没有 this 语法Vue.js 使用了基于 HTML 的模板语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。所有 Vue.js 的模板都是合法的 HTML，所以能被遵循规范的浏览器和 HTML 解析器解析。 在底层的实现上，Vue 将模板编译成虚拟 DOM 渲染函数。结合响应系统，Vue 能够智能地计算出最少需要重新渲染多少组件，并把 DOM 操作次数减到最少。 插值文本数据绑定最常见的形式就是使用“Mustache”语法 (双大括号) 的文本插值： 1&lt;span&gt;Message: &#123;&#123; msg &#125;&#125;&lt;/span&gt; 无论何时，绑定的数据对象上 msg property 发生了改变，插值处的内容都会更新。 原始 HTML 表达式会将 rawHtml 的值解析为文本，如果你希望它输出为 HTML，需要使用 v-html 指令： 1data:&#123;hello:&quot;&lt;p style=&quot;color:red&quot;&gt;hello&lt;/p&gt;&quot;&#125; 12&lt;span&gt;&#123;&#123;hello&#125;&#125;&lt;/span&gt;&lt;span v-html=&quot;hello&quot;&gt;&lt;/span&gt; 显示效果为: \\hello\\ hello 这个 span 的内容将会被替换成为 property 值 hello，直接作为 HTML——会忽略解析 property 值中的数据绑定。 你的站点上动态渲染的任意 HTML 可能会非常危险，因为它很容易导致 XSS 攻击。请只对可信内容使用 HTML 插值，绝不要对用户提供的内容使用插值。 AttributeMustache 语法不能作用在 HTML attribute 上，需要使用 v-bind 指令 12&lt;div v-bind:id=&quot;dynamicId&quot;&gt;&lt;/div&gt; &lt;!-- 正确 --&gt;&lt;div id=&#123;&#123;dynamicId&#125;&#125;&gt;&lt;/div&gt; &lt;!-- 错误 --&gt; 使用 JavaScript 表达式可以这样绑定 JS 的表达式 1234&#123;&#123; number + 1 &#125;&#125;&#123;&#123; ok ? &#x27;YES&#x27; : &#x27;NO&#x27; &#125;&#125; // 不要用 if()&#123;&#125;&#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;&lt;div v-bind:id=&quot;&#x27;list-&#x27; + id&quot;&gt;&lt;/div&gt; 模板表达式都被放在沙盒中，只能访问全局变量的一个白名单，如 Math 和 Date 。你不应该在模板表达式中试图访问用户定义的全局变量。 指令指令 (Directives) 是带有 v- 前缀的特殊 attribute。指令 attribute 的值预期是单个表达式，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。 比如 v-if=”seen” ，当 seen 为 false，该 DOM 对象不会显示 参数一些指令能接受一个参数，在指令名称后以冒号表示。 比如 v-bind 指令：可以响应式更新 HTML attribute 1&lt;a v-bind:href=&quot;url&quot;&gt;...&lt;/a&gt; 比如 v-on 指令：用于监听 DOM 事件 12&lt;a v-on:click=&quot;doSomething&quot;&gt;...&lt;/a&gt; // 鼠标点击会触发 vue 对象的 methods:dosomething() 动态参数 2.6.0 新增 从 2.6.0 开始，可以用方括号括起来的 JavaScript 表达式作为一个指令的参数： 1234&lt;!--注意，参数表达式的写法存在一些约束，如之后的“对动态参数表达式的约束”章节所述。--&gt;&lt;a v-bind:[attributeName]&#x3D;&quot;url&quot;&gt; ... &lt;&#x2F;a&gt; 这里的 attributeName 会被作为一个 JavaScript 表达式进行动态求值，求得的值将会作为最终的参数来使用。例如，如果你的 Vue 实例有一个 data property attributeName，其值为 &quot;href&quot;，那么这个绑定将等价于 v-bind:href。 同样地，你可以使用动态参数为一个动态的事件名绑定处理函数： 1&lt;a v-on:[eventName]&#x3D;&quot;doSomething&quot;&gt; ... &lt;&#x2F;a&gt; 在这个示例中，当 eventName 的值为 &quot;focus&quot; 时，v-on:[eventName] 将等价于 v-on:focus。 在 DOM 中使用模板时 (直接在一个 HTML 文件里撰写模板)，还需要避免使用大写字符来命名键名，因为浏览器会把 attribute 名全部强制转为小写： 12345&lt;!--在 DOM 中使用模板时这段代码会被转换为 `v-bind:[someattr]`。除非在实例中有一个名为“someattr”的 property，否则代码不会工作。--&gt;&lt;a v-bind:[someAttr]=&quot;value&quot;&gt; ... &lt;/a&gt; 修饰符缩写v- 前缀作为一种视觉提示，用来识别模板中 Vue 特定的 attribute。 Vue 为 v-bind 和 v-on 这两个最常用的指令，提供了特定简写： v-bind 缩写直接省略 v-bind。以冒号开头即可 12345678&lt;!-- 完整语法 --&gt;&lt;a v-bind:href=&quot;url&quot;&gt;...&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a :href=&quot;url&quot;&gt;...&lt;/a&gt;&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;&lt;a :[key]=&quot;url&quot;&gt; ... &lt;/a&gt; v-on 缩写直接省略 v-on。以 @ 开头即可 12345678&lt;!-- 完整语法 --&gt;&lt;a v-on:click=&quot;doSomething&quot;&gt;...&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a @click=&quot;doSomething&quot;&gt;...&lt;/a&gt;&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;&lt;a @[event]=&quot;doSomething&quot;&gt; ... &lt;/a&gt; 计算属性、但是不应该在模版内放入复杂逻辑，这时候应该在模板内放入“计算属性”，同样能达到数据变化=>计算属性变化=>重渲染 计算属性：实例化 Vue 对象时，增加 computed: {}，写入对应的“计算属性”的 function 作为该属性的 getter() 注意⚠️，computed 和 methods 是不一样的，computed 是作为 getter 函数并会响应式渲染 1234&lt;div id=&quot;example&quot;&gt; &lt;p&gt;Original message: &quot;&#123;&#123; message &#125;&#125;&quot;&lt;/p&gt; &lt;p&gt;Computed reversed message: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;&lt;/p&gt;&lt;/div&gt; 12345678910111213var vm = new Vue(&#123; el: &#x27;#example&#x27;, data: &#123; message: &#x27;Hello&#x27; &#125;, computed: &#123; // 计算属性的 getter reversedMessage: function () &#123; // `this` 指向 vm 实例 return this.message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125; &#125;&#125;) 在这个例子中，message 发生变化则会触发 reversedMessage 的变化，message 和 reversedMessage 的绑定在 Vue 对象初始化时进行。 你可以像绑定普通 property 一样在模板中绑定计算属性。Vue 知道 vm.reversedMessage 依赖于 vm.message，因此当 vm.message 发生改变时，所有依赖 vm.reversedMessage 的绑定也会更新。而且最妙的是我们已经以声明的方式创建了这种依赖关系：计算属性的 getter 函数是没有副作用 (side effect) 的，这使它更易于测试和理解。 计算属性 vs 方法12345methods: &#123; reversedMessage: function () &#123; return this.message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125; 这样做最终显示出来的结果是完全相同的。 但是性能有差别： 计算属性是有响应式缓存的，当依赖没有变化的时候，多次访问 reversedMessage 会立刻返回之前的计算结果，而不会再次执行函数。 相比之下，每当触发重新渲染时，调用方法将总会再次执行函数。 我们为什么需要缓存？假设我们有一个性能开销比较大的计算属性 A，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 A。如果没有缓存，我们将不可避免的多次执行 A 的 getter！如果你不希望有缓存，请用方法来替代。 条件渲染v-if 条件渲染元素，可以配合 v-else-if、v-else 使用 v-show 和 v-if 基本一样，都能控制元素是否显示 v-if 是真正的条件渲染，是惰性的。而 v-show 是始终渲染，只简单的 CSS 切换 display v-if 的切换开销更大，初始化开销更小 1234&lt;div id=&quot;app&quot;&gt; &lt;button v-on:click=&quot;seen=!seen&quot;&gt;切换可见&lt;/button&gt; &lt;p v-if=&quot;seen&quot;&gt;可以看到吗&lt;/p&gt;&lt;/div&gt; 123456var app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; seen: true, &#125;,&#125;) 循环渲染/事件123456&lt;div id=&quot;app&quot;&gt; &lt;ol&gt; &lt;li v-for=&quot;todo in todos&quot;&gt;&#123;&#123;todo.text&#125;&#125;&lt;/li&gt; &lt;/ol&gt; &lt;button v-on:click=&quot;reverseList&quot;&gt;反转&lt;/button&gt;&lt;/div&gt; 123456789101112131415161718var app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; todos: [ &#123; text: &#x27;学习 javascript&#x27; &#125;, &#123; text: &#x27;学习 Vue&#x27; &#125;, &#123; text: &#x27;学习前端&#x27; &#125;, ], &#125;, methods: &#123; reverseList: () =&gt; &#123; for (var str in app.todos) &#123; app.todos[str].text = app.todos[str].text.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125; &#125;, &#125;,&#125;) 在控制台可以输入 app.todos.push({ text:’hello world’ }) 可以看到渲染是实时的 反转按钮会触发 v-on:click 事件，对 List 的所有元素 reverse","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://panlianghnu.github.io/tags/Vue/"}]},{"title":"简单树形P2P网络实现","slug":"简单树形P2P网络实现","date":"2021-02-19T04:36:20.000Z","updated":"2021-03-19T15:26:36.650Z","comments":true,"path":"2021/02/19/简单树形P2P网络实现/","link":"","permalink":"https://panlianghnu.github.io/2021/02/19/%E7%AE%80%E5%8D%95%E6%A0%91%E5%BD%A2P2P%E7%BD%91%E7%BB%9C%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"树形结构： 先写一个种子文件，种子文件里是一个根节点的URL（单点故障）后面可以改成多个节点们 新的客户端接入该 P2P 网络 先读取种子文件，找到根节点 根节点给客户端分配一个（多个）节点，并给其一个ID 客户端连接上这些节点 客户端监听 http、p2p 端口 自己设置，并告诉根节点 根节点维护全局节点的信息，普通节点维护相连的节点的信息 每个节点退出时，向根节点发送退出消息，根节点维护节点列表 我写的比较简单，根节点只维护了node_ID列表，但是这样会有bug 某个节点退出时，删除了该节点的子节点而子节点并未结束程序，新的子节点到来，旧的子节点结束时又发送退出消息，这个时候根节点会错误的将新来的子节点也删除。 bug出现原因：node_ID不能唯一标识节点 解决方法：根节点不止维护node_ID，还维护每个节点的端口号，因为端口号是向操作系统随机申请的，可以认为唯一代表某个节点，或者我们可以在节点申请getPeer的时候记录时间，用时间唯一标识节点，将维护一个node_ID列表变成维护一个time列表，可以fix这个bug，但是我懒得写了… 测试 还是一样的 访问 http/ping 每个节点会把 “I am alive” 发送给相邻节点 =》根节点会收到所有节点的消息","categories":[],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://panlianghnu.github.io/tags/nodejs/"},{"name":"P2P","slug":"P2P","permalink":"https://panlianghnu.github.io/tags/P2P/"}]},{"title":"基于WebSocket的聊天室","slug":"基于WebSocket的聊天室","date":"2021-02-04T01:57:56.000Z","updated":"2021-03-14T14:59:57.520Z","comments":true,"path":"2021/02/04/基于WebSocket的聊天室/","link":"","permalink":"https://panlianghnu.github.io/2021/02/04/%E5%9F%BA%E4%BA%8EWebSocket%E7%9A%84%E8%81%8A%E5%A4%A9%E5%AE%A4/","excerpt":"","text":"源码见：github 后端使用 ‘express’ 封装 http 请求，监听7777端口，返回前端页面12345var app = require(&#x27;express&#x27;)() // 封装 http app.get(&#x27;/&#x27;,(req, res) =&gt; &#123; res.sendFile(__dirname + &#x27;/chat.html&#x27;) // 返回页面&#125;)app.listen(7777,&#x27;localhost&#x27;) 使用 nodejs-websocket 工具包处理聊天，监听8888端口123456789101112131415161718var ws = require(&#x27;nodejs-websocket&#x27;)var server = ws.createServer((socket) =&gt; &#123; // 处理聊天 var username = socket.path console.log(username + &#x27; 加入群聊&#x27;) clientList.push(socket) broadcast(username + &#x27; 加入群聊&#x27;) socket.on(&#x27;text&#x27;,(data) =&gt; &#123; console.log(username + &#x27;: &#x27;+data) broadcast(username + &#x27;: &#x27; + data) &#125;) socket.on(&#x27;close&#x27;,(err) =&gt; &#123; console.log(username + &#x27; 退出群聊&#x27;) deleteSocketFromList(socket) broadcast(username + &#x27; 退出群聊&#x27;) &#125;)&#125;).listen(8888) 客户端刚连接服务器时，服务器会用链表 clientList 保存这个 socket 连接，并进行广播 “xxx加入群聊”。 设置了两个事件 text 事件，客户端向服务器发送消息时触发 服务器向所有客户端广播该消息 close 事件，客户端失去连接时触发 服务器删除该 socket 对象，并广播给其他客户端 广播的实现遍历 socket ，调用 send 发送消息 1234567function broadcast(data)&#123; for(var i=0;i&lt;clientList.length;i++)&#123; if(clientList[i] !== null)&#123; clientList[i].send(data) &#125; &#125;&#125; 前端定义 url 和 ws 对象12var url = &quot;ws://localhost:8888/&quot;;var ws = null; 加入群聊，即初始化 websocket 对象，并绑定事件username 通过用户输入，调用 document.getElementById 得到内容 直接在连接时的 url 字符串后面拼接 username，后端识别 path 得到用户名 123456789101112131415161718192021222324function joinRoom() &#123; if (ws) &#123; alert(&quot;你已经在聊天室，不能再加入&quot;); return; &#125; var username = document.getElementById(&quot;user&quot;).value; ws = new WebSocket(url + username); //与服务端建立连接触发 ws.onopen = function () &#123; console.log(&quot;与服务器成功建立连接&quot;) &#125;; //服务端推送消息触发 ws.onmessage = function (ev) &#123; talking(ev.data); // 接收数据，刷新页面 &#125;; //发生错误触发 ws.onerror = function () &#123; console.log(&quot;连接错误&quot;) &#125;; //正常关闭触发 ws.onclose = function () &#123; console.log(&quot;连接关闭&quot;); &#125;;&#125; 发送数据123456789function sendMsg() &#123; if(!ws)&#123; alert(&quot;你已掉线，请重新加入&quot;); return; &#125; //消息发送 ws.send(document.getElementById(&quot;sendMsg&quot;).value); document.getElementById(&quot;sendMsg&quot;).value = &quot;&quot;;&#125; 先判断是否已经初始化 websocket 对象 接收数据，刷新页面1234function talking(content) &#123; document.getElementById(&quot;content&quot;).append(content + &quot;\\r\\n&quot;);&#125;content 是一个 &lt;textarea/&gt; 对象 GUI","categories":[],"tags":[{"name":"websocket","slug":"websocket","permalink":"https://panlianghnu.github.io/tags/websocket/"},{"name":"聊天室","slug":"聊天室","permalink":"https://panlianghnu.github.io/tags/%E8%81%8A%E5%A4%A9%E5%AE%A4/"}]},{"title":"ML学习笔记-1","slug":"ML学习笔记-1","date":"2021-01-03T08:45:14.000Z","updated":"2021-03-14T14:59:21.360Z","comments":true,"path":"2021/01/03/ML学习笔记-1/","link":"","permalink":"https://panlianghnu.github.io/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/","excerpt":"","text":"机器学习机器学习就是让机器自动找函数 Regression：输出数值 Classification：二分类、多类分类 Generation：生成有复杂结构的东西（如翻译，画二次元头像） 如何告诉机器，想要什么样的函数Supervised learning 有监督学习，对每个 input，给出一个标准 output，需要对资料做 label 机器就可以对生成的函数做一个评估，有一个 loss function，用来计算 function 的好坏 Reinforcement learning 强化学习，比如阿尔法狗，让机器和自己、别人下棋，然后赢了，机器会知道这样下比较好，哪几步比较好还不是很清楚 强化学习是智能体（Agent）以“试错”的方式进行学习，通过与环境进行交互获得的奖赏指导行为，目标是使智能体获得最大的奖赏，强化学习不同于连接主义学习中的监督学习，主要表现在强化信号上，强化学习中由环境提供的强化信号是对产生动作的好坏作一种评价(通常为标量信号)，而不是告诉强化学习系统RLS(reinforcement learning system)如何去产生正确的动作。由于外部环境提供的信息很少，RLS必须靠自身的经历进行学习。通过这种方式，RLS在行动-评价的环境中获得知识，改进行动方案以适应环境。 机器如何找到函数1、给定函数范围linear function network architecture RNN循环神经网络 CNN卷积神经网络 2、函数寻找方法Gradient Descent 梯度下降 Anomaly detection 能不能知道 自己不知道 meta learning 让机器学习如何学习，让机器自己设计学习的方法 Regression输出数值（Scalar） 比如无人车驾驶：input 一些sensor ，输出方向盘角度 比如推荐系统：input A和商品B，输出A购买B的可能性 比如宝可梦：输入某只宝可梦，输出他进化后的CP值 三个步骤 1、找到一个model（A set of functions）比如线性model cp_new = b + w*cp_old 2、定义 Loss function，输入一个 function，输出一个 function 评估结果 这里采用的平方 loss function ，用真实数据减去预测数值再取平方 3、找一个最好的 function 穷举所有的 w 和 b，求出最好的 w 和 b Gradient Descent，可以处理任何可以微分的 function 随机选取初始 w0，再初始w0这个位置，计算w参数对L的微分（切线斜率），若斜率为负，则右边 loss 较低，应该增加 w0，增加量为：微分值*(learning rate) 就这样不断地求 w，直到 w 到达 local optimal，但是会陷入局部最优（当然 linear set 没有局部最优） 如果有两个参数呢？ 其实算出来的就是等高线的法线方向 这种情况就会陷入局部最优，但 linear regression 没有 local optimal 求出来 b 和 w 之后，我们关心新数据和预测函数的误差，发现比较大 重新设计 model 二次式：y = b + w1Xcp + w2*(Xcp)^2 一样的用刚才的算法去求最好的 b、w1、w2 三次式：y = b + w1Xcp + w2\\(Xcp)^2 + w3*(Xcp)^3 四次式：。。。不断地拟合，loss function()的值不断变小，但是 test data 效果却更差，这波啊，这波是过拟合 如图，training data 效果特别好，但是显然不是一个合理的宝可梦CP预测的 function 越复杂的model、我们可以找到 training data 的loss function 最低的 function，但是在testing data 的结果是不一样的 testing 的结果反而变差了，拟合的并不是很好（Overfitting） overfitting model 并不是越复杂越好 当收集足够多的数据之后，发现并不是简单的和旧CP值有关 物种是有关键性影响的，重新设计 model ，将 物种（species）考虑进去 这也是一个线性拟合…为啥不分四个训练集呢。。感觉就像是把 Xcp这个 feature 分成四个 feature了，分别表示对四个种类的 cp 值 来个更复杂的 model 对 eevee 考虑的更加复杂一些，其实也不是很复杂，作业可能几百个参数。。。 然后算出来 loss 为1.4，testing data loss 102.3，显然 overfitting 了 如何避免 overfitting回到 regularization ，redesigned loss function loss function 不应该只考虑误差平方和，还应该加上 wi (wi 为各级x的系数) 的平方和，为什么？ 因为当 wi 比较小，则求出来的 function 比较平滑，输出对输入更加不敏感 更倾向于平滑的 function，因为越平滑，收到 noise 的影响越小 不断的调节 λ ，求出结果， λ 越大则考虑平滑越多 发现越平滑，考虑的err越少，则 training data 的结果越糟糕，但是 testing data 效果反而可能好一些，所以需要调节 λ 来决定 function 的平滑程度，（调节平滑不需要考虑 b） 总结：宝可梦的当前CP和物种决定几乎进化后的CP值（可能还有其他因素） 梯度下降，过度拟合和考虑平滑 error 来自哪里来自 bias 平均 来自 variance 方差 error 来自 bias，说明你没有瞄准好，导致估计值偏离真实值 error 来自 variance，说明你射的不够稳，还没有收敛/773.0 求各个模型的 f*（100组不同数据） ，发现简单的 model 是比较集中的，即 variance 比较小，不容易散开 model 比较复杂的话，function 散布就会很开，variance 比较开 为什么？ 因为 model 比较复杂，受到不同的 data 影响比较大 bias：large bias，如何评测 f* 和 f^ 的 bias 差多少？ 这里用红色表示各个 function 的结果，蓝色表示平均值，黑色表示正确答案， 可以看到，虽然这些 f 不知道飘到哪里去了，但是平均起来看，f 和 f^ 还是比较接近的，即 复杂的 model 的 bias 还是比较小的 所以，当你的 model 越来越复杂，bias 会越来越小，variance 会越来越大 如何分辨现在是 underfitting 还是 overfitting？当你的 traning data 结果比较差的时候，是 underfitting 当你的 training data 结果比较好但是 testing data 结果很差的时候，大概是 overfitting 怎么做？ error from bias：重新设计 model、或者用一个更加复杂的 model，找更多 data 也没用 error from variance： 找更多 data、或者 generate 一些假 data 哈哈哈 或者 regularization：再加一些参数，比如曲线平滑度 但是这样子得到的数据可能会伤害你的 bias bias偏移量越大，模型越垃圾。而高阶model往往会造成其bias偏移量较小（参考高数泰勒展开）。从而导致高阶model（或者说是复杂model）的模型更贴合于数据的真实分布。但是当我们用新的测试集在高阶model上进行预测时，由于高阶model的形态过分贴合训练集数据且高阶model群较为繁杂，其在新的测试集数据上的拟合优度一定不会很好。 model 选择我们希望找一个 bias 和 variance 都比较小的 model should not do： 你的 testing set 只是一个验证 training set 的 set，真实的 testing set 往往都是没有的 所以应该是这样做：用training data 选择 function，用 traning + validation 验证 model，这样才能真实反映 testing 的 bias（也就是不要提前考虑 testing data 的bias） N 折交叉验证： 把 training data 分成 n 份，选一个作为 validation","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://panlianghnu.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"简易区块链C语言实现","slug":"简易区块链C语言实现","date":"2020-12-30T04:11:39.000Z","updated":"2021-03-14T14:59:39.780Z","comments":true,"path":"2020/12/30/简易区块链C语言实现/","link":"","permalink":"https://panlianghnu.github.io/2020/12/30/%E7%AE%80%E6%98%93%E5%8C%BA%E5%9D%97%E9%93%BEC%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"简易区块链C语言实现在CSDN的第四个任务：实现一个最简单的区块链，不带区块链网络、时间戳、merkle tree等 虽然说技术上难度不大，但是想要实现它，还真是一个不小的工程。。。 除了 SHA256 的计算部分，其余的代码都是自己实现的，写的不好还望见谅 区块链数据结构： 如图所示，每个区块分为区块 head，和区块 body 区块头又分为 SHA_ALL、nonce、SHA_PREV、SHA_BLOCK &gt;&gt; SHA_BLOCK: 对区块的 body 部分进行一次 SHA256运算，保存在SHA_BLOCK SHA_PREV: 保存上一个区块整体(head+body)的 SHA256 值 nonce: 随机数，意义仅仅只是让区块头（不包含SHA_ALL的部分）+区块体一起进行SHA256运算，使得最终的结果刚好出现 n 个前导0，n 可以设置，代表出块的难度，模拟POW共识算法（比特币采用POW），我看了比特币源码，比特币源码的 nonce 是采用的 long long ，那我这里采用 unsigned long，之前龙哥和我说256位的nonce，我跑了跑发现没有必要，nonce跑到10万就需要我电脑好几秒了。。。unsigned long（8字节） 最大值有18446744073709551615，根本跑不完好吗。。。 当然比特币的 nonce 虽然只有8字节，但这里并不是说比特币的区块取值每次只需要计算2^64种情况，比特币实际挖坑时，最终的哈希值前导 0 特别长，只遍历一次 nonce 是几乎不可能的情况，矿机需要不断地改变区块体里面的 coinbase 里的无意义的值，然后不断地去遍历 nonce ，才能试探出前导0多于 n 个的情况，这将耗费巨大的算力，也是比特币POW共识策略的体现 SHA_ALL: 存放在区块头的最上面，SHA_ALL 保存整个区块（不包含头最上面的这256比特）的SHA256计算结果，必须有 n 个前导0。它的意义在于，只要你修改了这个区块的任意部分，你就需要重新计算 HASH_BLOCK、重新计算 NONCE ，使得最终的 SHA_ALL 算出来要出现 n 个前导0，当 n 比较大，区块链比较长时，想要修改某区块并使整个区块链仍合法的工作量不可估量，这是区块链“不可篡改”的重要因素之一 区块体就比较随意了，我这里只弄了一个字符串 这样就实现了一个最简单的区块链 具体代码实现如下： 123456789101112131415161718typedef union&#123; unsigned char byte[104]; struct&#123; unsigned char sha_all[32]; // 256 bit sha_all unsigned long nonce; // 64 bit nonce unsigned char sha_prev[32]; // 256 bit sha_prev unsigned char sha_block[32]; // 256 bit sha_block &#125;;&#125; block_chain_head;typedef struct&#123; char body[1000];&#125; block_chain_body;typedef struct&#123; block_chain_head head; block_chain_body body;&#125; block; 这里补充一下C语言共用体的知识： 我们知道结构体（Struct）是一种构造类型或复杂类型，它可以包含多个类型不同的成员。在C语言中，还有另外一种和结构体非常类似的语法，叫做共用体（Union），它的定义格式为： union 共用体名{ 成员列表}; 共用体有时也被称为联合或者联合体，这也是 Union 这个单词的本意。 结构体和共用体的区别在于：结构体的各个成员会占用不同的内存，互相之间没有影响；而共用体的所有成员占用同一段内存，修改一个成员会影响其余所有成员。 结构体占用的内存大于等于所有成员占用的内存的总和（成员之间可能会存在缝隙），共用体占用的内存等于最长的成员占用的内存。共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来成员的值覆盖掉。 这里采用 Union + Struct 的数据结构，是为了录入数据+读取数据都比较方便直观。当我想要录入数据时，我只需要读字节流，将104个字节赋值给 byte 数组即可，当我想访问某些数据时，我又可以用结构体的方式直接访问成员变量，代码非常的简洁，可读性也高 题外话： 之前想着是用哈希值命名文件，区块头可以少一个 sha 字段，看起来好像没啥问题，但是实际实现的时候，用哈希值来命名区块，有一个很严重的 bug 我们使用最终的哈希值有n个前导0，这样来控制难度，文件名是一个字符串，0在字符串里表现为字符 ‘\\0’ ，而这个字符被视为默认的字符串终止符，这个字符串你赋值给 const char* tmp，编译器会发现第一个字符就是字符串终止符，故而会把 tmp 这个字符串常量视为 “” 这样的空字符串保存在常量池，故而不能直接用这个哈希值来作为区块文件的文件名 同样的，但凡这个哈希值里面有 ‘\\0’ ，我们都不能将它作为文件名，所以文件名我不采用哈希值，哈希值还是选择保存在区块头中 功能实现一个简易的区块链，必须有下面几个功能： 生成创世纪块 读取文件夹下的所有区块 查找创世纪块 查找区块链的最后一个区块 在区块链的尾部追加区块 对区块的SHA计算 求SHA256: 我使用了别人实现的SHA256算法，参考：SHA256-C语言实现 这个程序有一个bug，当我将区块头和尾合并，一起作为字节数组传入时，有时候求出来的SHA256值正常，有时候值是错误的，我检查好久发现他在加密实现的过程中对传入的比特数组做了 strlen() 运算。。。这直接导致了如果传入的数据有 unsigned char 0，将被识别为字符串终结符，strlen() 函数遇到tmp直接终止计算，导致传入的字符串长度识别不正常，故而时好时坏（特别是创世纪块中有大量的 unsigned char 0，一直算出错误的SHA，还难以发现），我手动算字符串长度并作为参数传入计算，算是修了这个bug 生成创世纪块：先贴代码 1234567891011121314151617181920212223242526272829303132333435363738void init()&#123; // 创建创世纪块 block_chain_head* genesis = malloc(sizeof(block_chain_head)); block_chain_body genesis_body; strcpy(genesis_body.body,&quot;hello world&quot;); memset(genesis-&gt;byte,0,sizeof(block_chain_head)); // 先将区块字节头全部初始化为0 sha256_main(genesis_body.body,sizeof(genesis_body.body),genesis-&gt;sha_block); // 哈希body // 随机 nonce ，对(块头+块体)再次哈希 printf(&quot;开始随机nonce\\n&quot;); while (genesis-&gt;nonce &lt; 0xffffffffffffffff) &#123; // 把块头块体 读入一个 BYTE 数组 BYTE text[10200]; read_head_body(text,genesis,genesis_body); BYTE buf[SHA256_BLOCK_SIZE]; size_t size_of_text = sizeof(block_chain_head)-32 + strlen(genesis_body.body); sha256_main(text,size_of_text,buf); // 计算 sha256 有bug??? (已解决) // 当text 含有 &#x27;\\0&#x27; 时，出现bug // 所以添加变量 size_of_text (注意要减去32 sha_all) printf(&quot;当前nonce为: %lu &quot;,genesis-&gt;nonce); printf(&quot;前8bit为:%02x\\n&quot;,buf[0]); if (check_sha(buf)) &#123; // 检查是否为前导0 printf(&quot;创世纪块nonce为: %lu\\n&quot;,genesis-&gt;nonce); const char* filename = &quot;Genesis.block&quot;; FILE *fp = fopen(filename,&quot;w&quot;); int i; for (i=0;i&lt;SHA256_BLOCK_SIZE;i++) &#123; genesis-&gt;sha_all[i] = buf[i]; &#125; for (i=0;i&lt;sizeof(block_chain_head);i++) &#123; // 写入区块头 fprintf(fp,&quot;%c&quot;,genesis-&gt;byte[i]); &#125; for (i=0;i&lt;strlen(genesis_body.body);i++) &#123; // 写入区块体 fprintf(fp,&quot;%c&quot;,genesis_body.body[i]); &#125; break; &#125; genesis-&gt;nonce++; &#125;&#125; 这里就体现出联合体的优点了，直接可以通过 memset 对整个头初始化，却不影响我访问对应的结构题属性，计算 SHA256 时，我引用了别人的函数，sha256_main()，将对应的属性保存（创世纪块sha_prev = 0)，不断的计算nonce，由于采用了 unsigned long ，遍历只需要递增即可，注意每次递增 nonce，重新计算 SHA 的时候，一定要注意是从区块头的第32个字节开始往下读，一直把区块体的内容也读完，读出来的所有字节放入一个 BYTE text[SHA256_BLOCK_SIZE] 数组里，一起去求 SHA256，这样算出来的 SHA_ALL才是正确的，我这边难度设置的是前 16个 bit 为0，平均大概10秒能出一个块吧 验证 genesis 文件：使用 Mac 的二进制编辑器Hex Fiend打开查看： 可以看到，前32字节的 sha_all ，是一串乱码，是我们使用SHA256生成的整个文件的256bit 哈希值 接下来8个字节： 再接下来32字节的 sha_prev 全为0，这是我们初始化生成的0，创世纪块没有前一个块嘛 再接下来32字节是 sha_block ，这是区块体的哈希值，可以看到也是一串乱码 最后的部分就是区块 body 的内容了，创世纪块的body 内容我写的很简单，就是hello world，可以看到在右边已经把它解析出来了 读取文件夹下的所有区块：C语言标准库没有提供读取文件夹的函数，官方文档也没找到。。。 我引用了 “dirent.h” 库来读文件夹，调用 readdir(dir) 和 entry-&gt;d_name 来匹配文件名 参考C语言读取文件夹 123456789101112131415161718int read_dir_block(block block_list[],const char* filePath)&#123; // 读文件夹所有块文件 DIR *dir = NULL; struct dirent *entry; if ((dir = opendir(filePath)) == NULL) &#123; printf(&quot;open dir failed\\n&quot;); return -1; &#125; int num=0; while ((entry = readdir(dir))!=NULL) &#123; char* filename = entry-&gt;d_name; if (strstr(filename,&quot;.block&quot;)) &#123; // 匹配区块文件(以.block结尾) read_block(&amp;block_list[num],filename); num++; &#125; &#125; closedir(dir); return num;&#125; 使用 string.h 库函数 strstr() 子串查找，匹配文件名包含 .block 的文件，调用 read_block() 去读取文件 12345678910111213141516void read_block(block *blockitem,const char* filename)&#123; // 读一个块 FILE *fp = fopen(filename,&quot;r&quot;); if(!fp) &#123; perror(&quot;File opening failed&quot;); return; &#125; int c,i=0; while ((c = fgetc(fp)) != EOF) &#123; // standard C I/O file reading loop if (i&lt;sizeof(block_chain_head)) &#123; blockitem-&gt;head.byte[i] = c; &#125; else &#123; blockitem-&gt;body.body[i-sizeof(block_chain_head)] = c; &#125; i++; &#125;&#125; 遍历每个字符，这里又体现出联合体的优势了，直接载入文件的字符流，读 sizeof(block_chain_head) 个字符即可录入头部数据，文件剩余字符全部录入 body 即可 如此便可读取目录下的所有区块文件，放入 block_list 中 查找创世纪块：实现了读取目录下的所有区块之后，查找创世纪块变得尤其简单，只需要遍历所有的区块，找到某个 SHA_PREV 为全0的区块，即是创世纪块 1234567891011121314151617181920block find_first_block()&#123; block block_list[100]; const char *filePath = &quot;.&quot;; int size = read_dir_block(block_list,filePath); // 一共 size 个区块 block tmp; memset(tmp.head.byte, 0, sizeof(block_chain_head)); if (size &lt;= 0) &#123; printf(&quot;no block file\\n&quot;); return tmp; &#125; BYTE hash[SHA256_BLOCK_SIZE] = &#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00&#125;; int i; for (i=0;i&lt;size;i++) &#123; int cmp = memcmp(hash,block_list[i].head.sha_prev,SHA256_BLOCK_SIZE); if(cmp == 0)&#123; // equal， this is the first block return block_list[i]; &#125; &#125; return tmp;&#125; 我使用memcmp() 函数来比较 SHA_PREV 是否为全0，这是 memcmp 的官方文档： 可以看到，memcmp将二者解释为无符号字符数组，一个个比较，全部相等会返回0，特别方便 所以在这里我直接定义一个32字节全0的字符数组，然后调用 memcmp 比较即可 查找最后一个区块：这个算是特别常用的一个功能了 在查找文件夹下所有区块和查找创世纪块的基础之上，我们就可以去做区块的拓扑排序了 查找最后一个区块也就变成了求区块的拓扑排序，返回拓扑排序的最后一个区块即可 求拓扑序列的代码很简单我就不展示了，基本上就是一个二重循环，匹配第 j 个区块的 SHA_PREV 和当前区块的 SHA_ALL ，然后在尾部添加即可 尾部添加区块：有了查找最后一个区块，尾部添加区块也就特别简单了 只需要找到最后一个区块的 SHA_ALL ，新开一个区块，写入 SHA_PREV ，然后就和之前的生成创世纪块类似了， 12345678910111213141516171819202122232425262728293031323334353637383940414243void new_block(const char* block_name ,char* content)&#123; // 和 init 类似，在末尾添加 block last_block = find_last_block(); block_chain_head* genesis = malloc(sizeof(block_chain_head)); block_chain_body genesis_body; strcpy(genesis_body.body,content); memset(genesis-&gt;byte,0,sizeof(block_chain_head)); // 先将区块头全部初始化为0 int i; for (i=0;i&lt;SHA256_BLOCK_SIZE;i++) &#123; genesis-&gt;sha_prev[i] = last_block.head.sha_all[i]; // 写入 sha_prev &#125; sha256_main(genesis_body.body,sizeof(genesis_body.body),genesis-&gt;sha_block); // sha_block // 随机 nonce ，对(块头+块体)再次哈希 printf(&quot;开始随机nonce\\n&quot;); while (genesis-&gt;nonce &lt; 0xffffffffffffffff) &#123; // 把块头块体 读入一个 BYTE 数组 BYTE text[10200]; read_head_body(text,genesis,genesis_body); BYTE buf[SHA256_BLOCK_SIZE]; size_t size_of_text = sizeof(block_chain_head)-32 + strlen(genesis_body.body); sha256_main(text,size_of_text,buf); // 计算 sha256 有bug??? (已解决) // 当text 含有 &#x27;\\0&#x27; 时，出现bug // 所以添加变量 size_of_text (注意要减去32 sha_all) printf(&quot;当前nonce为: %lu &quot;,genesis-&gt;nonce); printf(&quot;前8bit为:%02x\\n&quot;,buf[0]); if (check_sha(buf)) &#123; // 检查是否为前导0 printf(&quot;新区块nonce为: %lu\\n&quot;,genesis-&gt;nonce); const char* filename = strcat(block_name, &quot;.block&quot;); FILE *fp = fopen(filename,&quot;w&quot;); for (i=0;i&lt;SHA256_BLOCK_SIZE;i++) &#123; genesis-&gt;sha_all[i] = buf[i]; &#125; for (i=0;i&lt;sizeof(block_chain_head);i++) &#123; // 写入区块头 fprintf(fp,&quot;%c&quot;,genesis-&gt;byte[i]); &#125; for (i=0;i&lt;strlen(genesis_body.body);i++) &#123; // 写入区块体 fprintf(fp,&quot;%c&quot;,genesis_body.body[i]); &#125; break; &#125; genesis-&gt;nonce++; &#125;&#125; 不要在意为什么新区块也叫 genesis 我懒得改了 除了区块的 filename 、SHA_PREV 、body 不一样，其他的操作完全和创世纪块一样 写新区块时，我需要给新区块后缀命名为 .block c语言不能直接使用 + 运算符对字符串进行拼接，故使用strcat，跑到一半又报错了。。原因是strcat直接在字符数组尾部添加字符，晕，数组越界了。 不得不再次感叹C语言的字符串处理真是太不方便了 可以看到 block_one 的 sha_prev 的部分，变成了 genesis 的前32字节，也就是哈希值指向 genesis 新区块的产生基本和创世纪块一样，只是调用一下 find_last_block ，找到 sha_prev 的值即可，然后自行输入 block_name 和 block_body 再看 block_two 和 block_one 相应的 sha_prev、 sha_all 字段都是一一对应起来的 解析出来的 body 也是正常的 尾部新增区块完成！ 检验区块链合法在 find_last_block() 函数的实现中，topo 序列只要能构造出来，说明sha_prev 和 sha_all 能够一一对上，该区块链是合法的，所以实现也和 find_last_block 基本一样。如果创世纪块找不到，则区块链不合法，从创世纪块后找 n个区块（n为区块总数目-1），一旦找不到区块的 sha_prev 指向当前 sha_all，则区块链不合法，具体实现在 check_block_chain() 函数里，得到拓扑序列之后，遍历这个序列，计算各个区块的 SHA_，任意区块的 SHA 计算错误则该区块链不合法 建立区块链索引find_last_block() 和 check_block_chain() 函数里都做过拓扑排序的操作，参考上面的函数即可 源码感谢能看到最后的小伙伴！代码我开源到 GitHub 了 https://github.com/panlianghnu/block_chain","categories":[],"tags":[{"name":"c语言","slug":"c语言","permalink":"https://panlianghnu.github.io/tags/c%E8%AF%AD%E8%A8%80/"},{"name":"区块链","slug":"区块链","permalink":"https://panlianghnu.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"}]},{"title":"JS 单线程","slug":"JS-单线程","date":"2020-12-22T12:44:08.000Z","updated":"2021-03-14T14:59:30.210Z","comments":true,"path":"2020/12/22/JS-单线程/","link":"","permalink":"https://panlianghnu.github.io/2020/12/22/JS-%E5%8D%95%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"JS 单线程JS执行是单线程 单线程是指Js引擎执行Js时只分了一个线程给他执行，也就是执行js时是单线程的。 那么问题来了，什么是线程？进程又是什么？ 在分析浏览器的渲染过程之前，我们先了解一下什么是进程和线程： （1）什么是进程？ 进程是CPU进行资源分配的基本单位 （2）什么是线程？ 线程是CPU调度的最小单位，是建立在进程的基础上运行的单位，共享进程的内存空间。 多进程1、浏览器是多进程 2、不同类型的标签页都会开启一个新的进程 3、相同类型的标签页是会合并到一个进程 1、浏览器进程 （1）负责管理各个标签页的创建和销毁 （2）负责浏览器的页面显示和功能（前进，后退，收藏等） （3）负责资源的管理与下载 2、第三方插件进程 （1）负责每个第三方插件的使用，每个第三方插件使用时候都会创建一个对应的进程 3、GPU进程 （1）负责3D绘制和硬件加速 4、浏览器渲染进程（咱们这回主要分析的） 1、浏览器内核，主要负责HTML，CSS，JS等文件的解析和执行 什么是浏览器内核？ 浏览器内核就是浏览器渲染进程，从接收下载文件后再到呈现整个页面的过程，由浏览器渲染进程负责，主要流程如下： 1、解析HTML文件和CSS文件，加载图片等资源文件，渲染成用户看到的页面2、执行解析js文件脚本代码 这里主要讲浏览器页面渲染过程，在该过程中浏览器渲染进程会开启多个线程协作完成，主要的线程以及作用如下： 1、GUI渲染线程2、JS引擎线程3、事件触发线程4、定时器出发线程5、异步HTTP请求线程 JS引擎1、JS内核，也称JS引擎（例如V8引擎），负责处理执行javascript脚本程序，2、由于js是单线程（一个Tab页内中无论什么时候都只有一个JS线程在运行JS程序），依靠任务队列来进行js代码的执行，所以js引擎会一直等待着任务队列中任务的到来，然后加以处理。 注意，JavaScript 只在一个线程上运行，不代表 JavaScript 引擎只有一个线程。事实上，JavaScript 引擎有多个线程，单个脚本只能在一个线程上运行（称为主线程），其他线程都是在后台配合 为了利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作 DOM。所以，这个新标准并没有改变 JavaScript 单线程的本质。 V8引擎的内部结构1、V8是一个非常复杂的项目，使用cloc统计可知，它竟然有超过100万行C++代码。2、V8由许多子模块构成，其中这4个模块是最重要的： Parser：负责将JavaScript源码转换为Abstract Syntax Tree (AST) Ignition：interpreter，即解释器，负责将AST转换为Bytecode，解释执行Bytecode；同时收集3. TurboFan优化编译所需的信息，比如函数参数的类型； TurboFan：compiler，即编译器，利用Ignitio所收集的类型信息，将Bytecode转换为优化的汇编代码； Orinoco：garbage collector，垃圾回收模块，负责将程序不再需要的内存空间回收； 再次强调：单线程是指Js引擎执行Js时只分了一个线程给他执行，也就是执行js时是单线程的。 既然JS是单线程的，那怎么实现异步的呢？ 单线程意味着什么：JavaScript 同时只能执行一个任务，其他任务都必须在后面排队等待。也就是说代码只能同步执行，必须执行上一行才能执行下一行。 123456console.log(&#x27;1&#x27;)setTimeout(() =&gt; &#123; console.log(&#x27;2&#x27;)&#125;, 0);console.log(&#x27;3&#x27;)12345 然而并不是，还有异步！！！ 程序里面所有的任务，可以分成两类：同步任务（synchronous）和异步任务（asynchronous）。 同步任务是那些没有被引擎挂起、在主线程上排队执行的任务。只有前一个任务执行完毕，才能执行后一个任务。 异步任务是那些被引擎放在一边，不进入主线程、而进入任务队列的任务。只有引擎认为某个异步任务可以执行了（比如 Ajax 操作从服务器得到了结果），该任务（采用回调函数的形式）才会进入主线程执行。排在异步任务后面的代码，不用等待异步任务结束会马上运行，也就是说，异步任务不具有“堵塞”效应。 举例来说，Ajax 操作可以当作同步任务处理，也可以当作异步任务处理，由开发者决定。如果是同步任务，主线程就等着 Ajax 操作返回结果，再往下执行；如果是异步任务，主线程在发出 Ajax 请求以后，就直接往下执行，等到 Ajax 操作有了结果，主线程再执行对应的回调函数。 任务队列和事件循环 （实现异步）JavaScript 运行时，除了一个正在运行的主线程，引擎还提供一个任务队列（task queue），里面是各种需要当前程序处理的异步任务。（实际上，根据异步任务的类型，存在多个任务队列。为了方便理解，这里假设只存在一个队列。） 首先，主线程会去执行所有的同步任务。等到同步任务全部执行完，就会去看任务队列里面的异步任务。如果满足条件，那么异步任务就重新进入主线程开始执行，这时它就变成同步任务了。等到执行完，下一个异步任务再进入主线程开始执行。一旦任务队列清空，程序就结束执行。 异步任务的写法通常是回调函数。一旦异步任务重新进入主线程，就会执行对应的回调函数。如果一个异步任务没有回调函数，就不会进入任务队列，也就是说，不会重新进入主线程，因为没有用回调函数指定下一步的操作。 JavaScript 引擎怎么知道异步任务有没有结果，能不能进入主线程呢？答案就是引擎在不停地检查，一遍又一遍，只要同步任务执行完了，引擎就会去检查那些挂起来的异步任务，是不是可以进入主线程了。这种循环检查的机制，就叫做事件循环（Event Loop）。维基百科的定义是：“事件循环是一个程序结构，用于等待和发送消息和事件（a programming construct that waits for and dispatches events or messages in a program）”。 代码是如何执行的？ 宏任务(macro-task)、微任务(micro-task) 除了广义的同步任务和异步任务，JavaScript 单线程中的任务可以细分为宏任务和微任务。 macro-task包括：script(整体代码), setTimeout, setInterval, setImmediate, I/O, UI rendering。micro-task包括：process.nextTick, Promises, Object.observe, MutationObserver。 有了宏任务和微任务的概念后，那 JS 的执行顺序是怎样的？是宏任务先还是微任务先？ 第一次事件循环中，JavaScript 引擎会把整个 script 代码当成一个宏任务执行，执行完成之后，再检测本次循环中是否寻在微任务，存在的话就依次从微任务的任务队列中读取执行完所有的微任务，再读取宏任务的任务队列中的任务执行，再执行所有的微任务，如此循环。JS 的执行顺序就是每次事件循环中的宏任务-微任务。 页面刷新率？ 每次微任务执行之后宏任务执行之前如果有UI操作页面会重新渲染，一般页面刷新率60HZ/秒，一帧是16.6毫秒，所以可以理解为事件循环每次轮询的时间大概是16.6毫秒 每一帧浏览器需要做什么？ 我们所看到的网页，都是浏览器一帧一帧绘制出来的，通常认为FPS为60的时候是比较流畅的，而FPS为个位数的时候就属于用户可以感知到的卡顿了，那么在一帧里面浏览器都要做哪些事情呢 渲染帧的流程渲染帧是指浏览器一次完整绘制过程，帧之间的时间间隔是 DOM 视图更新的最小间隔。 由于主流的屏幕刷新率都在 60Hz，那么渲染一帧的时间就必须控制在 16ms 才能保证不掉帧。 也就是说每一次渲染都要在 16ms 内页面才够流畅不会有卡顿感。 这段时间内浏览器需要完成如下事情： 脚本执行（JavaScript）：脚本造成了需要重绘的改动，比如增删 DOM、请求动画等 样式计算（CSS Object Model）：级联地生成每个节点的生效样式。 布局（Layout）：计算布局，执行渲染算法 重绘（Paint）：各层分别进行绘制（比如 3D 动画） 合成（Composite）：合成各层的渲染结果 最初 Webkit 使用定时器进行渲染间隔控制， 2014 年时开始 使用显示器的 vsync 信号控制渲染（其实直接控制的是合成这一步）。 这意味着 16ms 内多次 commit 的 DOM 改动会合并为一次渲染。 耗时 JS 会造成丢帧JavaScript 在并发编程上一个重要特点是“Run To Completion”。在事件循环的一次 Tick 中， 如果要执行的逻辑太多会一直阻塞下一个 Tick，所有异步过程都会被阻塞。 一个流畅的页面中，JavaScript 引擎中的执行队列可能是这样的： 1执行 JS -&gt; 空闲 -&gt; 绘制（16ms）-&gt; 执行 JS -&gt; 空闲 -&gt; 绘制（32ms）-&gt; ... 如果在某个时刻有太多 JavaScript 要执行，就会丢掉一次帧的绘制： 1执行很多 JS...（20ms）-&gt; 空闲 -&gt; 绘制（32ms）-&gt; ... 例如下面的脚本在保持 JavaScript 忙的状态（持续 5s）下每隔 1s 新增一行 DOM 内容。 1234567891011121314151617&lt;div id&#x3D;&quot;message&quot;&gt;&lt;&#x2F;div&gt;&lt;script&gt;var then &#x3D; Date.now()var i &#x3D; 0var el &#x3D; document.getElementById(&#39;message&#39;)while (true) &#123; var now &#x3D; Date.now() if (now - then &gt; 1000) &#123; if (i++ &gt;&#x3D; 5) &#123; break; &#125; el.innerText +&#x3D; &#39;hello!\\n&#39; console.log(i) then &#x3D; now &#125;&#125;&lt;&#x2F;script&gt; 可以观察到虽然每秒都会写一次 DOM，但在 5s 结束后才会全部渲染出来，明显耗时脚本阻塞了渲染。","categories":[],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://panlianghnu.github.io/tags/nodejs/"}]},{"title":"python 文字版RPG小游戏","slug":"python-文字版RPG小游戏","date":"2020-12-17T07:44:24.000Z","updated":"2021-03-14T15:00:24.030Z","comments":true,"path":"2020/12/17/python-文字版RPG小游戏/","link":"","permalink":"https://panlianghnu.github.io/2020/12/17/python-%E6%96%87%E5%AD%97%E7%89%88RPG%E5%B0%8F%E6%B8%B8%E6%88%8F/","excerpt":"","text":"之前龙哥给我们布置了两个任务 语言快速上手-学习任务 这是第一个 基本就是实现一个文字版本的RPG小游戏，刚好我今天在bilibili看到一个互动视频觉得很有意思，就想着把这个视频用文字的形式复现出来 视频链接：【互动视频】卢本伟越狱记 这种互动视频有很多选项，每个选项都会影响之后的剧情，所以我使用一个栈来保存之前的选择，也方便每次互动时，玩家选错选项来有机会反悔回到上一步 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196stack = []stack.append(0)while len(stack)&gt;0: case = stack[-1] # 读最后一个case if case == 0: # case0:等待开始游戏 print(&#x27;卢本伟越狱记&#x27;) print(&#x27;卢本伟开挂被抓了，你能帮助卢本伟成功越狱吗？（你需要扮演卢本伟完成越狱）&#x27;) start = input(&quot;输入&#x27;start&#x27;开始游戏，输入其他结束\\n&quot;) if start != &#x27;start&#x27;: print(&quot;你输入了：&quot;,start,&quot; 游戏结束...&quot;) break else: # 游戏开始 stack.append(1) continue if case == 1: # case1:开始游戏 print(&quot;卢本伟被关在牢房，这时来了俩警察&quot;) print(&#x27;警察1:“you are free guy now...骗你的哈哈哈”&#x27;) print(&#x27;警察1:“你有个朋友给你寄了一个包裹，但是你不要想着轻举妄动，我们已经检查过里面了，是吧？”&#x27;) print(&#x27;警察2:“（心虚）是啊是啊，我当然检查过了，这是我的工作嘛”&#x27;) print(&#x27;两个警察把包裹留下就走了&#x27;) print(&#x27;卢本伟打开了包裹，发现一个生日蛋糕，生日蛋糕里面居然藏了东西，你会选择？&#x27;) tmp = input(&#x27;A.锉刀 B.钻机 C.返回上一步 其他.结束游戏\\n&#x27;) if tmp == &quot;A&quot; : stack.append(2) # case2: 选择锉刀 continue if tmp == &quot;B&quot; : stack.append(3) # case3: 选择钻机 continue if tmp == &quot;C&quot; : del stack[-1] continue else : break if case == 2: # case2：选择锉刀 print(&#x27;你选择了锉刀，卢本伟切割了监狱门，并打倒了守卫，这时有人追了过来&#x27;) print(&#x27;卢本伟灵机一动，躲进了一个小房间，但是这不是长久之计，必须找到方法越狱&#x27;) print(&#x27;卢本伟发现房间里有：A.手雷 B.椅子&#x27;) tmp = input(&#x27;聪明的你会选择：A.手雷 B.椅子 C.返回上一步 其他.结束游戏\\n&#x27;) if tmp == &quot;A&quot; : stack.append(4) # case4: 选择手雷 continue if tmp == &quot;B&quot; : stack.append(5) # case5: 选择椅子 continue if tmp == &quot;C&quot; : del stack[-1] continue else : break if case == 4: # case4: 选择手雷 print(&#x27;情急之下，卢本伟拿起了地上的手雷，准备和追来的警察拼死一搏&#x27;) print(&#x27;两个警察追过俩把门堵上，卢本伟失手把自己炸死了&#x27;) print(&#x27;game over&#x27;) tmp = input(&#x27;输入A重开游戏，输入B返回上一步，输入其他结束游戏\\n&#x27;) if tmp == &quot;A&quot;: stack = [] stack.append(0) continue if tmp == &quot;B&quot;: del stack[-1] continue else : break if case == 5: # case5: 选择椅子 print(&#x27;聪明的卢本伟发现通过椅子可以钻进天花板的通风管道&#x27;) print(&#x27;这个时候问题来了，通风管道只能向左或向右&#x27;) tmp = input(&#x27;你会选择？ A.向右 B.向左 C.返回上一步 其他.结束游戏\\n&#x27;) if tmp == &quot;A&quot; : stack.append(6) # case6: 选择向右 continue if tmp == &quot;B&quot; : stack.append(7) # case7: 选择向左 continue if tmp == &quot;C&quot; : del stack[-1] continue else : break if case == 6: # 选择向右 print(&#x27;卢本伟顺着通风管道爬到了天台&#x27;) print(&#x27;在天台，卢本伟发现了 A.喷气背包 B.马桶塞&#x27;) print(&#x27;你会选择什么装备逃生？&#x27;) tmp = input(&#x27;A.喷气背包 B.马桶塞 C.返回上一步 其他.结束游戏\\n&#x27;) if tmp == &quot;A&quot; : stack.append(8) # case8: 选择喷气背包 continue if tmp == &quot;B&quot; : stack.append(9) # case9: 选择马桶塞 continue if tmp == &quot;C&quot; : del stack[-1] continue else : break if case == 7: # 选择向左 print(&#x27;警察们在会议室开会，而卢本伟不小心掉进了会议室，game over&#x27;) tmp = input(&#x27;输入A重开游戏，输入B返回上一步，输入其他结束游戏\\n&#x27;) if tmp == &quot;A&quot;: stack = [] stack.append(0) continue if tmp == &quot;B&quot;: del stack[-1] continue else : break if case == 8: # case8: 选择喷气背包 print(&#x27;伞兵一号卢本伟准备就绪！！！&#x27;) print(&#x27;Oh这是个坏的喷气背包，卢本伟摔死了&#x27;) tmp = input(&#x27;输入A重开游戏，输入B返回上一步，输入其他结束游戏\\n&#x27;) if tmp == &quot;A&quot;: stack = [] stack.append(0) continue if tmp == &quot;B&quot;: del stack[-1] continue else : break if case == 9: # case9: 选择马桶塞 print(&#x27;卢本伟左手一个马桶塞，右手一个马桶塞&#x27;) print(&#x27;凭借强大的臂力和马桶塞的吸力，卢本伟成功的飞檐走壁逃出监狱！！&#x27;) tmp = input(&#x27;输入A重开游戏，输入B返回上一步，输入其他结束游戏\\n&#x27;) if tmp == &quot;A&quot;: stack = [] stack.append(0) continue if tmp == &quot;B&quot;: del stack[-1] continue else : break if case == 3: # case3: 选择钻机 print(&#x27;你选择了钻机，卢本伟使用钻机钻地，发现地下还有个房间&#x27;) print(&#x27;卢本伟想都没想直接跳进了下面的房间，环顾四周&#x27;) print(&#x27;房间里有一个井盖好像可以撬开，还有一个传送器上面写着“你会变得透明并可以穿墙”&#x27;) tmp = input(&#x27;你会选择？ A.传送器 B.撬棍 C.返回上一步 其他.结束游戏\\n&#x27;) if tmp == &quot;A&quot; : stack.append(10) # case10: 选择传送器 continue if tmp == &quot;B&quot; : stack.append(11) # case11: 选择撬棍 continue if tmp == &quot;C&quot; : del stack[-1] continue else : break if case == 10: print(&#x27;你选择了传送器&#x27;) print(&#x27;卢本伟按下了传送器，他开始变得透明，墙无法阻挡他，但是地面也无法支撑他，卢本伟直接沉到了地心，死了&#x27;) tmp = input(&#x27;输入A重开游戏，输入B返回上一步，输入其他结束游戏\\n&#x27;) if tmp == &quot;A&quot;: stack = [] stack.append(0) continue if tmp == &quot;B&quot;: del stack[-1] continue else : break if case == 11: print(&#x27;你选择了撬棍&#x27;) print(&#x27;卢本伟撬开了井盖，钻进井盖发现掉到了一楼大厅走廊上&#x27;) print(&#x27;卢本伟被两个警察发现，警察们追着他跑&#x27;) tmp = input(&#x27;这时你会？ A.往左跑 B.往右跑 C.返回上一步 其他.结束游戏\\n&#x27;) if tmp == &quot;A&quot;: stack.append(12) # case12: 往左跑 continue if tmp == &quot;B&quot;: stack.append(13) # case13: 往右跑 continue if tmp == &quot;C&quot;: del stack[-1] continue else : break if case == 12: print(&#x27;你选择向左逃跑&#x27;) print(&#x27;那两个警察追不上卢本伟，但是追的人越来越多&#x27;) print(&#x27;现在卢本伟被五个带枪的警察包围&#x27;) print(&#x27;但是凭借卢本伟的走位，他们一枪没中，甚至射死了自己人&#x27;) print(&#x27;卢本赶紧趁乱跑到门口抢了一辆警车跑了&#x27;) print(&#x27;越狱成功，game over...&#x27;) tmp = input(&#x27;输入A重开游戏，输入B返回上一步，输入其他结束游戏\\n&#x27;) if tmp == &quot;A&quot;: stack = [] stack.append(0) continue if tmp == &quot;B&quot;: del stack[-1] continue else : break if case == 13: print(&#x27;卢本伟边走位边逃跑的时候还就那个不小心一头簪死在柱子上&#x27;) print(&#x27;无敌的卢本伟倒下了&#x27;) print(&#x27;game over...&#x27;) tmp = input(&#x27;输入A重开游戏，输入B返回上一步，输入其他结束游戏\\n&#x27;) if tmp == &quot;A&quot;: stack = [] stack.append(0) continue if tmp == &quot;B&quot;: del stack[-1] continue else : break 下面是剧情介绍（建议去上面的视频链接，更加清晰）： &gt;&gt; 卢本伟越狱记 卢本伟开外挂被抓了，你能帮助卢本伟成功越狱吗？（你需要扮演卢本伟完成越狱） 卢本伟被关在监狱，来了俩警察 警察1:“you are free guy，骗你的” 警察1:“你有个朋友给你寄了一个包裹，但是你不要想着轻举妄动，我们已经检查过里面了，是吧？” 警察2:“（心虚）是啊是啊，我当然检查过了，这是我的工作嘛” 卢本伟打开了包裹，发现一个生日蛋糕，生日蛋糕里面居然藏了东西，你会选择？A.锉刀 B.钻机 A.锉刀：你选择了锉刀，卢本伟切割了监狱门，并打倒了守卫，这时有人追了过来 ​ 你躲进了一个小房间，房间里有：A.手雷 B.椅子 ​ A.手雷：两个人来抓你，你把自己炸死了 ​ B.椅子：你通过椅子，爬进了通风管道，向左向右？ ​ A.右 你爬到了天台，天台上有：A.喷气背包 B.马桶塞 ​ A.伞兵一号卢本伟准备就绪，Oh，这是个坏的喷气背包，你摔死了 ​ B.你成功的通过马桶塞一步一步吸住墙壁越狱成功！ ​ B.左 警察们在会议室开会，你不小心掉进了会议室，game over B.钻机：你选择了钻机，使用钻机钻地，你发现地下还有个房间， ​ 房间里有一个井盖好像可以撬开，还有一个传送器上面写着“你会变得透明并可以穿墙” ​ A.传送器 B.撬棍 ​ A.你按下了传送器，墙无法阻挡你，地面也无法支撑你，你直接沉到了地球核心，死了 ​ B.你撬开了井盖，掉到了走廊，两个警察追着你跑 ​ A.往左 你被五个人围住，但是凭借着走位，他们一枪没中，你抢了一辆警车跑路了 ​ B.往右 你撞上了柱子，无敌的你倒下了 游戏装备介绍： 传送器： 马桶塞： 步骤：","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://panlianghnu.github.io/tags/python/"}]},{"title":"Python快速入门","slug":"Python快速入门","date":"2020-12-15T02:49:20.000Z","updated":"2021-03-14T15:00:19.740Z","comments":true,"path":"2020/12/15/Python快速入门/","link":"","permalink":"https://panlianghnu.github.io/2020/12/15/Python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/","excerpt":"","text":"Python快速入门函数定义一个函数123def functionname( parameters ): function_suite return [expression] 参数传递python里一切都是对象，参数都是对象的引用 不可变类型：如整数、浮点数、字符串、元组() 可变类型：如列表、字典、自定义对象 不可变类型作为参数传入时，对参数的修改其实是修改另一个复制的对象 可变类型作为参数传入时，函数内的修改会影响到函数外 关键字参数传参数时，要么按照要求（参数顺序，数量）严格传入参数，要么使用关键字参数 12print(climbStairs(climbStairs,5)) # 斐波那契print(climbStairs(n=5,self=climbStairs)) # 斐波那契 使用关键字参数，就可以不严格按照顺序来传参，并且代码可读性更好 注意⚠️：关键字参数不能和普通传参混用，一个参数是关键字参数，其他也要是 默认参数123def printHello(arg=&quot;hello&quot;): print(arg) return 这个函数可以不输入参数，也可以输入一个参数来替换默认的”hello” 不定长参数1234567def printAll(arg1, *vartuple): # *vartuple 表示不定长参数，0~n个都可以 # 而 arg1 保证至少有一个参数传进来，该函数不至于输出空 print(arg1) for var in vartuple: print(var) return 匿名函数（lambda）python 使用 lambda 来创建匿名函数 123456# lambda arg1,arg2,arg3... : expressionpow = lambda arg1,arg2 : arg1 ** arg2 # pow变量指向 lambda 这个匿名函数# lambda只是一个表达式，函数体比def简单很多，仅仅能在lambda表达式中封装有限的逻辑进去# 不能访问自有参数列表之外或全局命名空间里的参数！！# 不等同于C或C++的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率 变量作用域全局变量 定义在函数外，可以在整个程序范围内访问 局部变量 定义在函数内，只能在函数内访问 变量变量没有类型，变量是任意对象的引用，变量的赋值不需要声明，python是动态类型+强类型的语言 标准数据类型python 提供了6个标准数据类型 注意⚠️：没有提供数组类型，建议用列表替代 a = [ 0 for i in range(1000) ] Numbers 不可变 Strings 不可变 序列 Tuple (元组) 不可变 序列 （虽然元组的元素不可改变，但是元组可以包含可变对象） List [列表] 序列 Dictionary {字典} Set 集合 Numbers : int （有符号整数） Long (python2.2 之后被移除，int 溢出会自动变为 long) float （浮点数） complex（复数） Strings : 字符串取值： 从左到右 str[0] ~ str[len-1] 从右到左 str[-1] ~ str[-len] 截取字符串：[头下表 : 尾下标] 这将返回一个新的对象 Python列表截取还要第三个参数（步长） 列表： 列表可以完成大多数集合类的数据结构实现 最常用的类型 它支持字符，数字，字符串甚至可以包含列表（即嵌套） 用 + 连接列表， 用 * 表示重复操作 1234a = &#x27;12345&#x27;b = a[2:] + a[4:]print(b * 2)输出：34553455 列表内置方法很多 12append clear copy count extendindex pop remove reverse sort 列表的元素是可以删除的： del a[2] 适用于列表的方法： cmp(list1, list2) , 列表类型不同则没啥意义，类型相同则 哪个列表短哪个列表就小，返回1或-1 一样长则元素小列表就小，返回1或-1 所有元素相同则返回0 len(list)，获得列表长度 max(list)，返回列表元素最大值 min(list)，返回列表元素最小值 list(seq)，将元组转换为列表 元组： 可以理解为只读列表，不能二次赋值 元组用 () 标识 删除元组只能删除整个元组 del tup 字典： 字典(dictionary)是除列表以外python之中最灵活的内置数据结构类型 字典用 {} 标识 通过 dict[key] 来访问 value 字典的key 必须是不可变对象 可以删除 key-value 也能显示删除整个字典 : del dict[‘key’] 、 del dict 字典包括以下内置方法： 12345678910clear get has_key(key)copy(浅复制) items # 以列表返回可以遍历的 key-value 元组fromkeys(seq[,val]) # 返回一个列表，keys为这个序列的值，val为默认值keys(返回所有key)values（返回所有值）upadte(dict2) # 把dict2的键值对更新到dict里pop(key)popitem() # 返回并删除字典中最后一对 key-value 数据类型转换 函数 描述 int(x [,base]) 将x转换为一个整数 long(x [,base]) 将x转换为一个长整数 float(x) 将x转换到一个浮点数 complex(real [,imag]) 创建一个复数 str(x) 将对象 x 转换为字符串 repr(x) 将对象 x 转换为表达式字符串 eval(str) 用来计算在字符串中的有效Python表达式,并返回一个对象 tuple(s) 将序列 s 转换为一个元组 list(s) 将序列 s 转换为一个列表 set(s) 转换为可变集合 dict(d) 创建一个字典。d 必须是一个序列 (key,value)元组。 frozenset(s) 转换为不可变集合 chr(x) 将一个整数转换为一个字符 unichr(x) 将一个整数转换为Unicode字符 ord(x) 将一个字符转换为它的整数值 hex(x) 将一个整数转换为一个十六进制字符串 oct(x) 将一个整数转换为一个八进制字符串 元组包含可变对象时直接上代码 12345678910111213a = [1,2]b = 4c = (a,b) # c为包含可变对象的元组print(c)a.append(3)print(c)a = [5,6,7]print(c)打印结果：([1, 2], 4)([1, 2, 3], 4)([1, 2, 3], 4) 可以看到，当 a.append(3)后，c[0]变化了。当 a = [5,6,7] 时，c[0]没变 所以，元组的元素不可变应该这样理解，生成元组时，元组里的所有元素都会被保存在数据区 a = [5,6,7]，是像字符串赋值那样重新开辟了内存空间，让a指向新的内存，但是元组内的值还是指向原来的内存，所以这个情况元组的值是不会变化的 a.append(3)，a本身是没有变化的，但是a指向的内存里的值发生了变化，所以元组也”变化”了 再来看一个情况 这个情况也是 a.append()。为什么c没有变化呢？ list底层是数组实现的，添加这么多元素后，a 指向的内存地址发生了变化，而元组内的值指向的内存地址是不会发生变化的，所以这个时候，a和元组内的”a” 不是一个a了 所谓元组的不可变指的是元组所指向的内存中的内容不可变 运算符算数运算： + - * / % **(返回x的y次幂) //（返回商的整数部分，python里整数除以整数也会转换成浮点数） 比较运算： == 比较对象是否相等 (字符串可以用这个比较) != 比较对象是否不等 &lt; &gt;= &lt;= 位运算： &amp; 按位与 | 按位或 ^ 按位异或 ~ 按位取反 &lt;&lt; 左移 （不会溢出，自动变成long） >&gt; 右移 （它是算数右移，-4右移变成-2） 逻辑运算： and or not 成员运算： in：如果在指定的序列中找到值返回 True，否则返回 False。 not in： 如果在指定的序列中没有找到值返回 True，否则返回 False。 身份运算： 用于判断变量是否指向同一个对象 is （和==不一样，==是判断值，is 判断对象） is not 12345678910a = student(name=&quot;panliang&quot;,age=4)b = student(name=&quot;panliang&quot;,age=4)if a == b: print(&quot;a == b&quot;)else: print(&quot;a != b&quot;)if a is b: print(&quot;a is b&quot;)else: print(&quot;a is not b&quot;) 打印结果： 可以看到，自定义对象不能用 == 比较（python字符串可以），就算他们的内容相同 循环while循环12while (condition): statements contidion 可以是任何表达式，任何非零、或非空（null）的值均为true。 for循环12for i in sequence: statements 遍历序列所有的元素 注意⚠️：给列表赋值时，这样写是不行的 for i in seq 返回的是新的对象 for 循环经常和 range 函数配合使用 12for i in range(n): statements range(n)会返回一个列表，i 会从0遍历到n-1 range也支持多个参数，比如反向遍历 range(n,0,-1)，遍历从n到1（不会到0） python3的range()函数返回的是一个可迭代对象（类型是对象），而不是列表（为了性能），所以打印range不会输出列表 循环的else123456789for num in range(10,20): # 迭代 10 到 20 之间的数字 for i in range(2,num): # 根据因子迭代 if num%i == 0: # 确定第一个因子 j=num/i # 计算第二个因子 print &#x27;%d 等于 %d * %d&#x27; % (num,i,j) break # 跳出当前循环 else: # 循环的 else 部分 print num, &#x27;是一个质数&#x27;# 当循环没有通过break跳出来时， 会执行 else while循环也类似 模块、输入和输出命令行参数1234import sysfor i in sys.argv: print(i)print(&#x27;\\nPython路径为：&#x27;,sys.path,&#x27;\\n&#x27;) 代码回输出所有通过命令行传入的参数 sys.path 包含了一个 Python 解释器自动查找所需模块的路径的列表（相当于环境变量） import时，会自动执行被导入的包里的程序 12345如果希望自己的程序不在被import时执行，需要把自己的程序代码写在if __name__==&#x27;__main__&#x27;: print(&#x27;我自己在运行&#x27;)else: print(&#x27;我来自另一模块&#x27;) 包包是一种管理 Python 模块命名空间的形式，采用 package.module 就不会让不同包的模块混淆以及不同模块之间的全局变量互相影响 在导入一个包的时候，Python 会根据 sys.path 中的目录来寻找这个包中包含的子目录 目录只有包含一个叫做 __init__.py 的文件才会被认作是一个包，主要是为了避免一些滥俗的名字 123456789101112131415161718192021222324可能的包结构sound/ 顶层包 __init__.py 初始化 sound 包 formats/ 文件格式转换子包 __init__.py wavread.py wavwrite.py aiffread.py aiffwrite.py auread.py auwrite.py ... effects/ 声音效果子包 __init__.py echo.py surround.py reverse.py ... filters/ filters 子包 __init__.py equalizer.py vocoder.py karaoke.py ... 可以 imort sound.formats.auwrite 来导入 auwrite 模块 但是调用函数时，也需要sound.formats.auwrite.function 所以不妨这样 from sound.formats import auwrite 调用函数时，只需要 auwrite.function , 无需冗长前缀 甚至可以只导入一个函数或者变量： from sound.effects.echo import echofilter 这种方法会导入子模块: echo，并且可以直接使用他的 echofilter() 函数 当使用 from package import item 时， import 语法会首先把 item 当作一个包定义的名称，如果没找到，再试图按照一个模块去导入。最后按照函数、类、变量这样去找。 如果还没找到，抛出一个 :exc:ImportError 异常。 反之，如果使用形如 import item.subitem.subsubitem 这种导入形式，除了最后一项，都必须是包，而最后一项则可以是模块或者是包，但是不可以是类，函数或者变量的名字。 从包里导入*，会找到目录下所有的子模块，都导入，但是在windows这类大小写不分的平台上工作很不好，需要包作者在 __init__.py 里的一个 all 列表变量写入导入的包名 输入和输出标准输入输出Python提供了 input() 内置函数从标准输入读入一行文本 12str = input(&quot;请输入:&quot;)print(str) 读写文件123txt = open(&#x27;addTowNum.py&#x27;,&#x27;r&#x27;)str = txt.read()print(str) open有两个参数，一个是filename， 一个是文件打开模式（可以不写，默认模式为 r ） file.read()有一个参数size，表示读取的数据数量（可以不写，默认读文件所有字符） file.readline() 读文件一行 file.write(str) 将str写入文件，返回写入的字符数 模式 描述 r 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。 rb 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。 r+ 打开一个文件用于读写。文件指针将会放在文件的开头。 rb+ 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。 w 打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 wb 以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 w+ 打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 wb+ 以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 a 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 ab 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 a+ 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。 ab+ 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。 file.close() 关闭文件 1234with open(&#x27;/tmp/foo.txt&#x27;, &#x27;r&#x27;) as f: read_data = f.read()f.closed使用with 比 try finally 简单 日期和时间import time 时间戳time.time() 用于获取当前时间戳（是一个浮点数，表示从1970年1月1日午夜，经过了多少秒） 无法表示1970年之后的、Unix和Windows只支持到2038年 非常适合用于计算时间差 时间元组很多python函数用包含9个元素的元组来处理时间： struct_time 元组 序号 属性 值 0 tm_year 2008 1 tm_mon 1 到 12 2 tm_mday 1 到 31 3 tm_hour 0 到 23 4 tm_min 0 到 59 5 tm_sec 0 到 61 (60或61 是闰秒) 6 tm_wday 0到6 (0是周一) 7 tm_yday 1 到 366(儒略历) 8 tm_isdst -1, 0, 1, -1是决定是否为夏令时的旗帜 时间戳转换为时间元组只需要将浮点数传递给如 localtime 之类的函数 12345import timelocaltime = time.localtime(time.time())print(&quot;本地时间为：&quot;,localtime)本地时间为：time.struct_time(tm_year=2020, tm_mon=12, tm_mday=15, tm_hour=17, tm_min=11, tm_sec=52, tm_wday=1, tm_yday=350, tm_isdst=0) 获取格式化时间你可以获取时间元组，然后自定义输出 但是有一个函数可以很方便得将时间元组转换成字符串 123456import timelocaltime = time.localtime(time.time())asctime = time.asctime(localtime)print(asctime)Tue Dec 15 17:20:16 2020","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://panlianghnu.github.io/tags/python/"}]},{"title":"Anaconda安装","slug":"Anaconda安装","date":"2020-12-14T09:58:36.000Z","updated":"2021-03-14T15:00:57.680Z","comments":true,"path":"2020/12/14/Anaconda安装/","link":"","permalink":"https://panlianghnu.github.io/2020/12/14/Anaconda%E5%AE%89%E8%A3%85/","excerpt":"","text":"Anaconda 是Mac电脑上的一个开源的Python发行版本。Conda是一个开源的包、环境管理器，可以用于在同一个机器上安装不同版本的软件包及其依赖，并能够在不同的环境之间切换。Anaconda包括Conda、Python以及一大堆安装好的工具包，比如：numpy、pandas等。 conda软件包 搜索我们基于云的资源库，查找并安装超过7500个数据科学和机器学习包。使用conda-install命令，您可以开始使用成千上万的开源Conda、R、Python和其他许多软件包。 管理环境 个人版是一个开源、灵活的解决方案，它提供了跨平台方式构建、分发、安装、更新和管理软件的实用工具。Conda可以轻松管理多个数据环境，这些环境可以单独维护和运行，互不干扰。 一、下载安装包 Anaconda安装包下载 官网可能速度比较慢，我在http://www.pc6.com/mac/842752.html下的 二、开始安装 一直下一步就行了 三、安装成功，设置conda环境变量我这边不用配环境，默认配好了 查看验证 conda list conda常用操作命令1、查看环境管理的全部命令帮助：123conda env -h 或者conda 2、查看当前系统下的环境：123conda info -e或者conda-env list 3、创建环境：1conda create env_name 【注】 (env_name)是环境名称,这条命令创建一个新的环境，存储位置在安装文件的隐藏文件/.conda文件夹里面 创建指定python版本的环境： 1conda create env_name python&#x3D;3.6 4、激活进入某个环境1activate env_name 5、退出某个环境：1deactivate env_name 6、复制某个环境：1conda create new_env_name old_env_name 7、删除某个环境：1conda remove env_name 8、安装包：12conda install xxxpip install xxx 9、指定的安装环境：1conda install -n env_name 包名 10、查看已安装的包：1conda list 11、查看指定环境下的包：1conda list -n 环境名 12、查找包：1conda search 包名 13、更新包：1conda update xxx 14、安装anaconda发行版中所有的包:1conda install anaconda 15、卸载包：1conda remove xxx 三、管理conda1、检查conda版本：1conda -V # 大写V 2、升级当前版本的conda：1conda update conda","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://panlianghnu.github.io/tags/python/"},{"name":"Anaconda","slug":"Anaconda","permalink":"https://panlianghnu.github.io/tags/Anaconda/"}]},{"title":"python简史","slug":"python简史","date":"2020-12-14T09:35:24.000Z","updated":"2021-03-14T15:00:12.220Z","comments":true,"path":"2020/12/14/python简史/","link":"","permalink":"https://panlianghnu.github.io/2020/12/14/python%E7%AE%80%E5%8F%B2/","excerpt":"","text":"本文作者：Vamei 出处：http://www.cnblogs.com/vamei Python是我喜欢的语言，简洁，优美，容易使用。前两天，我很激昂的向朋友宣传Python的好处。 听过之后，朋友问我：好吧，我承认Python不错，但它为什么叫Python呢？ 我不是很确定：呃，似乎是一个电视剧的名字。 朋友又问：那你说的Guido是美国人么？ (Guido von Rossum，Python的作者) 我再次不是很确定：他从google换到Dropbox工作，但他的名字像是荷兰人的 (有一个von在中间)。 所以，后面我花了些时间调查Python的历史。这是很好的学习。我看到了Python中许多功能的来源和Python的设计理念，比如哪些功能是历史遗留，哪些功能是重复，如何增加功能…… 而且，Python也是开源(open source)运动的一个成功案例。从Python的历史中，我们可以一窥开源开发的理念和成就。 Python的起源Python的作者，Guido von Rossum，确实是荷兰人。1982年，Guido从阿姆斯特丹大学(University of Amsterdam)获得了数学和计算机硕士学位。然而，尽管他算得上是一位数学家，但他更加享受计算机带来的乐趣。用他的话说，尽管拥有数学和计算机双料资质，他总趋向于做计算机相关的工作，并热衷于做任何和编程相关的活儿。 在那个时候，他接触并使用过诸如Pascal、C、 Fortran等语言。这些语言的基本设计原则是让机器能更快运行。在80年代，虽然IBM和苹果已经掀起了个人电脑浪潮，但这些个人电脑的配置很低 (在今天看来)。比如早期的Macintosh，只有8MHz的CPU主频和128KB的RAM，一个大的数组就能占满内存。所有的编译器的核心是做优化，以便让程序能够运行。为了增进效率，语言也迫使程序员像计算机一样思考，以便能写出更符合机器口味的程序。在那个时代，程序员恨不得用手榨取计算机每一寸的能力。有人甚至认为C语言的指针是在浪费内存。至于动态类型，内存自动管理，面向对象…… 别想了，那会让你的电脑陷入瘫痪。 然而，这种思考方式让Guido感到苦恼。Guido知道如何用C语言写出一个功能，但整个编写过程需要耗费大量的时间 (即使他已经准确的知道了如何实现)。他的另一个选择是shell。Bourne Shell作为UNIX系统的解释器(interpreter)已经长期存在。UNIX的管理员们常常用shell去写一些简单的脚本，以进行一些系统维护的工作，比如定期备份、文件系统管理等等。shell可以像胶水一样，将UNIX下的许多功能连接在一起。许多C语言下上百行的程序，在shell下只用几行就可以完成。然而，shell的本质是调用命令。它并不是一个真正的语言。比如说，shell没有数值型的数据类型，加法运算都很复杂。总之，shell不能全面的调动计算机的功能。 (关于shell，你可以参考Linux架构和Linux命令行与命令) Guido希望有一种语言，这种语言能够像C语言那样，能够全面调用计算机的功能接口，又可以像shell那样，可以轻松的编程。ABC语言让Guido看到希望。ABC是由荷兰的CWI (Centrum Wiskunde &amp; Informatica, 数学和计算机研究所)开发的。Guido在CWI工作，并参与到ABC语言的开发。ABC语言以教学为目的。与当时的大部分语言不同，ABC语言的目标是“让用户感觉更好”。ABC语言希望让语言变得容易阅读，容易使用，容易记忆，容易学习，并以此来激发人们学习编程的兴趣。比如下面是一段来自Wikipedia的ABC程序，这个程序用于统计文本中出现的词(word)的总数： 1234567HOW TO RETURN words document: PUT &#123;&#125; IN collection FOR line IN document: FOR word IN split line: IF word not.in collection: INSERT word IN collection RETURN collection HOW TO用于定义一个函数。一个Python程序员应该很容易理解这段程序。ABC语言使用冒号(:)和缩进来表示程序块(C语言使用{}来表示程序块)。行尾没有分号。for和if结构中也没有括号()。如果将HOW TO改为def，将PUT行改为collection = []，将INSERT行改为collection.append(word)，这就几乎是一个标准的Python函数。上面的函数读起来就像一段自然的文字。 尽管已经具备了良好的可读性和易用性，ABC语言最终没有流行起来。在当时，ABC语言编译器需要比较高配置的电脑才能运行。而这些电脑的使用者通常精通计算机，他们更多考虑程序的效率，而非它的学习难度。除了硬件上的困难外，ABC语言的设计也存在一些致命的问题： 可拓展性差。ABC语言不是模块化语言。如果想在ABC语言中增加功能，比如对图形化的支持，就必须改动很多地方。 不能直接进行IO。ABC语言不能直接操作文件系统。尽管你可以通过诸如文本流的方式导入数据，但ABC无法直接读写文件。输入输出的困难对于计算机语言来说是致命的。你能想像一个打不开车门的跑车么？ 过度革新。ABC用自然语言的方式来表达程序的意义，比如上面程序中的HOW TO (如何)。然而对于程序员来说，他们更习惯用function或者define来定义一个函数。同样，程序员也习惯了用等号(=)来分配变量。这尽管让ABC语言显得特别，但实际上增加了程序员的学习难度 (程序员大都掌握不止一种语言)。 传播困难。ABC编译器很大，必须被保存在磁带(tape)上。当时Guido在访问的时候，就必须有一个大磁带来给别人安装ABC编译器。 这样，ABC语言就很难快速传播。 1989年，为了打发圣诞节假期，Guido开始写Python语言的编译/解释器。Python来自Guido所挚爱的电视剧Monty Python’s Flying Circus (BBC1960-1970年代播放的室内情景幽默剧，以当时的英国生活为素材)。他希望这个新的叫做Python的语言，能实现他的理念(一种C和shell之间，功能全面，易学易用，可拓展的语言)。Guido作为一个语言设计爱好者，已经有过设计语言的(不很成功)的尝试。这一次，也不过是一次纯粹的hacking行为。 Python的诞生1991年，第一个Python编译器(同时也是解释器)诞生。它是用C语言实现的，并能够调用C库(.so文件)。从一出生，Python已经具有了：类(class)，函数(function)，异常处理(exception)，包括表(list)和词典(dictionary)在内的核心数据类型，以及模块(module)为基础的拓展系统。 最初的Python logo: 由Guido的兄弟Just von Rossum设计 Python语法很多来自C，但又受到ABC语言的强烈影响。来自ABC语言的一些规定直到今天还富有争议，比如强制缩进。但这些语法规定让Python容易读。另一方面，Python聪明的选择服从一些惯例(特别是C语言的惯例)。比如使用等号赋值，使用def来定义函数。Guido认为，如果“常识”上确立的东西，没有必要过度纠结。 Python从一开始就特别在意可拓展性(extensibility)。Python可以在多个层次上拓展。从高层上，你可以引入.py文件。在底层，你可以引用C语言的库。Python程序员可以快速的使用Python写.py文件作为拓展模块。但当性能是考虑的重要因素时，Python程序员可以深入底层，写C程序，编译为.so文件引入到Python中使用。Python就好像是使用钢构建房一样，先规定好大的框架。而程序员可以在此框架下相当自由的拓展或更改。 最初的Python完全由Guido本人开发。Python得到Guido同事的欢迎。他们迅速的反馈使用意见，并参与到Python的改进。Guido和一些同事构成Python的核心团队。他们将自己大部分的业余时间用于hack Python (也包括工作时间，因为他们将Python用于工作)。随后，Python拓展到CWI之外。Python将许多机器层面上的细节隐藏，交给编译器处理，并凸显出逻辑层面的编程思考。Python程序员可以花更多的时间用于思考程序的逻辑，而不是具体的实现细节 (Guido有一件T恤，写着：人生苦短，我用Python)。这一特征吸引了广大的程序员。Python开始流行。 我们不得不暂停我们的Python时间，转而看一看这时的计算机概况。1990年代初，个人计算机开始进入普通家庭。Intel发布了486处理器，windows发布window 3.0开始的一系列视窗系统。计算机的性能大大提高。程序员开始关注计算机的易用性 (比如图形化界面)。 Windows 3.0 由于计算机性能的提高，软件的世界也开始随之改变。硬件足以满足许多个人电脑的需要。硬件厂商甚至渴望高需求软件的出现，以带动硬件的更新换代。C++和Java相继流行。C++和Java提供了面向对象的编程范式，以及丰富的对象库。在牺牲了一定的性能的代价下，C++和Java大大提高了程序的产量。语言的易用性被提到一个新的高度。我们还记得，ABC失败的一个重要原因是硬件的性能限制。从这方面说，Python要比ABC幸运许多。 另一个悄然发生的改变是Internet。1990年代还是个人电脑的时代，windows和Intel挟PC以令天下，盛极一时。尽管Internet为主体的信息革命尚未到来，但许多程序员以及资深计算机用户已经在频繁使用Internet进行交流 (包括email和newsgroup)。Internet让信息交流成本大大下降。一种新的软件开发模式开始流行：开源 (open source)。程序员利用业余时间进行软件开发，并开放源代码。1991年，Linus在comp.os.minix新闻组上发布了Linux内核源代码，吸引大批hacker的加入。Linux和GNU相互合作，最终构成了一个充满活力的开源平台。 硬件性能不是瓶颈，Python又容易使用，所以许多人开始转向Python。Guido维护了一个maillist，Python用户就通过邮件进行交流。Python用户来自许多领域，有不同的背景，对Python也有不同的需求。Python相当的开放，又容易拓展，所以当用户不满足于现有功能，很容易对Python进行拓展或改造。随后，这些用户将改动发给Guido，并由Guido决定是否将新的特征加入到Python或者标准库中。如果代码能被纳入Python自身或者标准库，这将极大的荣誉。Python自身也因此变得更好。 (Guido不得不作出许多决定，这也是他被称为Benevolent Dictator For Life的原因) Python被称为“Battery Included”，是说它以及其标准库的功能强大。这些是整个社区的贡献。Python的开发者来自不同领域，他们将不同领域的优点带给Python。比如Python标准库中的正则表达(regular expression)是参考Perl，而lambda, map, filter, reduce函数参考Lisp。Python本身的一些功能以及大部分的标准库来自于社区。Python的社区不断扩大，进而拥有了自己的newsgroup，网站(python.org)，以及基金 (Python Software Foundation)。从Python 2.0开始，Python也从maillist的开发方式，转为完全开源的开发方式。社区气氛已经形成，工作被整个社区分担，Python也获得了更加高速的发展。 (由于Guido享有绝对的仲裁权，所以在Python早期maillist的开发时代，不少爱好者相当担心Guido的生命。他们甚至作出假设：如果Guido挂了的话，Python会怎样。见If Guido was hit by a bus) 到今天，Python的框架已经确立。Python语言以对象为核心组织代码(Everything is object)，支持多种编程范式(multi-paradigm)，采用动态类型(dynamic typing)，自动进行内存回收(garbage collection)。Python支持解释运行(interpret)，并能调用C库进行拓展。Python有强大的标准库 (battery included)。由于标准库的体系已经稳定，所以Python的生态系统开始拓展到第三方包。这些包，如Django, web.py, wxpython, numpy, matplotlib,PIL，将Python升级成了物种丰富的热带雨林。 今天Python已经进入到3.0的时代。由于Python 3.0向后不兼容，所以从2.0到3.0的过渡并不容易。另一方面，Python的性能依然值得改进，Python的运算性能低于C++和Java(见Google的讨论)。Python依然是一个在发展中的语言。我期待看到Python的未来。 Python启示录Python崇尚优美、清晰、简单，是一个优秀并广泛使用的语言 (TIOBE语言排行第八，Google的第三大开发语言，Dropbox的基础语言，豆瓣的服务器语言)。这个世界并不缺乏优秀的语言，但Python的发展史作为一个代表，带给我许多启示。 在Python的开发过程中，社区起到了重要的作用。Guido自认为自己不是全能型的程序员，所以他只负责制订框架。如果问题太复杂，他会选择绕过去，也就是cut the corner。这些问题最终由社区中的其他人解决。社区中的人才是异常丰富的，就连创建网站，筹集基金这样与开发稍远的事情，也有人乐意于处理。如今的项目开发越来越复杂，越来越庞大，合作以及开放的心态成为项目最终成功的关键。 Python从其他语言中学到了很多，无论是已经进入历史的ABC，还是依然在使用的C和Perl，以及许多没有列出的其他语言。可以说，Python的成功代表了它所有借鉴的语言的成功。同样，Ruby借鉴了Python，它的成功也代表了Python某些方面的成功。每个语言都是混合体，都有它优秀的地方，但也有各种各样的缺陷。同时，一个语言“好与不好”的评判，往往受制于平台、硬件、时代等等外部原因。程序员经历过许多语言之争。我想，为什么不以开放的心态和客观的分析，去区分一下每个语言的具体优点缺点，去区分内部和外部的因素。说不定哪一天发现，我不喜欢的某个语言中，正包含了我所需要的东西。 无论Python未来的命运如何，Python的历史已经是本很有趣的小说。","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://panlianghnu.github.io/tags/python/"},{"name":"转载","slug":"转载","permalink":"https://panlianghnu.github.io/tags/%E8%BD%AC%E8%BD%BD/"}]},{"title":"MacOS安装python3并设置默认","slug":"MacOS安装python3并设置默认","date":"2020-12-14T09:17:12.000Z","updated":"2020-12-14T09:18:30.000Z","comments":true,"path":"2020/12/14/MacOS安装python3并设置默认/","link":"","permalink":"https://panlianghnu.github.io/2020/12/14/MacOS%E5%AE%89%E8%A3%85python3%E5%B9%B6%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4/","excerpt":"","text":"MacOS 安装Python3.8并设置为默认版本1、安装Python版本管理工具1brew install pyenv 2、添加环境变量（使用bash则添加环境变量到.bashrc 或.profile 或.bash_profile）1echo &#x27;export PATH=&quot;$(pyenv root)/shims:$PATH&quot;&#x27; &gt;&gt; ~/.zshrc 1source ~/.zshrc 3、安装Python版本1pyenv install 3.8.5 4、设置默认版本（以后切换也用这个）1pyenv global 3.8.5 5、检查Python版本1python -V","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://panlianghnu.github.io/tags/python/"},{"name":"MacOS","slug":"MacOS","permalink":"https://panlianghnu.github.io/tags/MacOS/"}]},{"title":"Coder - 语言快速上手","slug":"Coder-语言快速上手","date":"2020-12-14T03:29:44.000Z","updated":"2021-03-14T15:00:45.660Z","comments":true,"path":"2020/12/14/Coder-语言快速上手/","link":"","permalink":"https://panlianghnu.github.io/2020/12/14/Coder-%E8%AF%AD%E8%A8%80%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/","excerpt":"","text":"Coder - 语言快速上手图灵完备： 有的语言不是图灵完备的：比如 windows 的 bat 批处理语言、Linux 的 shell、html。只能处理一些自动化的东西 图灵完备的语言： 能控制数据、有输入输出、有逻辑处理等。所有图灵机能做的事情、都能用这个语言实现。图灵完备的语言可以互相替代，但是不一样的语言有不一样的优势 快速学习一门语言： 先了解这个语言的来历、原因、特点、开发环境 程序逻辑：变量定义、程序员的约定（驼峰等）、顺序语句、循环分支（看懂其他、自己会写一种就行）、try catch 变量加深理解 强类型弱类型 c弱类型（比如打印时需要指定%d、正确使用类型靠程序员自己） python强类型（通过 var a = ‘a’，编程语言就知道它是一个字符） 动态类型 （声明变量时不用指定类型）比如python、go、swift 静态类型 （声明变量时需要指定类型） 值类型 （基本类型） 在栈里面直接定义变量（C/C++几乎全是值类型） 引用类型 （封装类型） 有的语言所有的变量都是引用（python和js几乎都是引用类型） 值类型和引用类型（影响 == ），但是有的引用类型语言处理了== 时间和日期（如何处理、保存、计算、格式、方法） 字符串： 理解内存 可变不可变 java有字符串常量池（有时候string a == b 是可以的） 正则表达式（匹配模式） 容器类型：各种方法、遍历、删除、复制（深浅）、容器序列化（xml、） 可以上项目 编程语言的抽象方法、类（继承封装多态）、接口、函数 可以写设计模式 函数式编程的特性 熟练度、生态、包管理工具（pip等） 语言的高级功能：比如 java 的高性能并发、网络支持、磁盘管理、携程等 professional 训练任务：完成一个支持消息循环的交互程序： 运行后不结束 标准输入输出 单线程就行 不需要UI 文字版RPG小游戏、需要6步以上的剧情 第二个编程语言： 精细控制 对二进制位进行操作 凯撒密码对数据加密 输入加密的移位 输入加密字符串 生成加密的字符串（支持重定向） 还能解密 做一个解密程序（破解凯撒密码、不知道加密的移位）。需要自己判断正确的字符串","categories":[],"tags":[{"name":"Language","slug":"Language","permalink":"https://panlianghnu.github.io/tags/Language/"}]},{"title":"Git 学习笔记","slug":"Git-学习笔记","date":"2020-12-13T12:58:37.000Z","updated":"2021-03-14T15:00:37.660Z","comments":true,"path":"2020/12/13/Git-学习笔记/","link":"","permalink":"https://panlianghnu.github.io/2020/12/13/Git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"Git 学习以往的 version control 是记录补丁（RCS），记录新文件和上一个文件的变化（比如新增了一行aaa、删除了一行bbbb），从而保证版本控制，可以回退，但是这样的 version control 只能管理文本，不能管理多媒体等其他文件 Git 不一样，每一次提交的文件，都是保存完整的文件，Git 版本库拥有每个版本文件的快照（SNAP），切换速度非常快，除了管理代码外，还可以管理多媒体等文件 集中化的版本控制 让不同系统上的开发者协同工作 有一个单一的集中管理的服务器，保存所有文件的修订版本，大家从这台服务器拉取文件，或者提交更新 好处： 大家都能在一定程度上看到别人在做什么 管理一个CVCS比每个客户端都维护一个本地数据库来得容易 坏处： 单点故障 分布式版本控制 客户端不止提取最新版本的文件快照，而是把代码仓库完整地镜像下来，包括完整的历史记录 每一次的克隆，其实都是对代码仓库的完整备份 避免了单点故障，也不需要维护一个中央服务器 可以在同一项目中和不同的工作小组的人协作 Git 是一个分布式的版本管理系统 Git 特点 直接记录快照，而非差异比较（每当提交更新或者保存项目状态时，就会对当时的全部文件创建一个快照，并保存这个快照的索引。为了效率，没有修改的文件不会重新存储，而是保留一个链接指向之前存储的文件） 近乎所有操作都是本地执行（快！）没有网络延迟 保证完整性，类似区块链，所有数据保存时都计算哈希，并且以哈希来引用！（SHA-1） 几乎只有添加数据，（删除其实也是提交一个快照，所以我之前的阿里云密钥现在还在给我发段信！！！） 三种状态：committed、modified、staged committed：表示数据已经保存在本地数据库中 modified：表示数据已经修改、但还没有保存到数据库中 staged：表示对一个已修改的文件的当前版本作了标记，使之包含在下次提交的快照中（类似暂存吧） 三个阶段：工作区、暂存区、Git 目录 工作区是项目的某个版本的内容，提取出来放在磁盘上供你修改 暂存区是一个文件，保存下次将要提交的文件列表信息，一般在.git里面 Git 仓库目录：.git 文件夹，保存Git 的元数据和对象数据库，克隆就是克隆这个 Git 基本工作流程1、在工作区中修改文件 2、将想下次提交的更改选择性地暂存（别把配置文件提交！！！） 3、提交更新，将快照永久性地存储到 Git 目录 建立Git 仓库 git init git clone ( git clone 会复制所有的版本，然后将最新版本的文件放在工作区) Git add没有被 add 的文件，Git 会忽略它 所有被 Git add 的文件都会有副本 git add 是一个多功能命令 没有被追踪的文件，使用 git add 会让 git 将这个文件加入管理范畴 已经追踪的文件，使用 git add 会将该文件放到暂存区 合并时，使用 git add 可以把有冲突的文件标记为已解决 可以理解为将内容添加到下一次提交中 当你修改了文件并且 git add 后，保存在暂存区，之后又修改了这个文件 再次查看 git status 可以看到这个文件同时出现在 to be committed 和 not staged 所以，git add 并不是添加这个文件，而是添加的 SNAP （当时的文件） git add 之后的修改并没有添加到暂存区 Git ignore我们想要忽略一些编译文件、日志文件等，又不想让他总提示我没追踪，就要git忽略它 编写一个文件 .gitignore 文件 .gitignore 的格式规范如下：所有空行或者以 # 开头的行都会被 Git 忽略。可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中。匹配模式可以以（/）开头防止递归。匹配模式可以以（/）结尾指定目录。要忽略指定模式以外的文件或目录，可以在模式前加上叹号（!）取反。 所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。 星号（*）匹配零个或多个任意字符；[abc] 匹配任何一个列在方括号中的字符 （这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）； 问号（?）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符， 表示所有在这两个字符范围内的都可以匹配（比如 [0-9] 表示匹配所有 0 到 9 的数字）。 使用两个星号（）表示匹配任意中间目录，比如 a//z 可以匹配 a/z 、 a/b/z 或 a/b/c/z 等。 一个仓库可能只根目录下有一个 .gitignore 文件。 然而，子目录下也可以有额外的 .gitignore 文件。子目录中的 .gitignore 文件中的规则只作用于它所在的目录中。 Git diffgit status 只能看到文件当前的状态 使用 git diff 查看： 当前做的哪些更新尚未暂存？ 有哪些更新已暂存并准备好下次提交？ 只是使用文件补丁的格式给你展示，并不是底层使用文件补丁实现 git diff 不加参数，比较的是工作目录中当前文件和暂存区快照的差异 git diff —staged ，比较的是暂存区快照和最后一次提交的文件的差异 经常 git add 之后 git diff 没有信息就是这个原因 Git commit只会提交已经 add 的文件作为快照 git commit -a ：将所有已经跟踪的文件一并提交（跳过 add 过程） 这很方便，但是很有可能会提交一些你不想提交的文件（比如说配置文件） git commit —amend : 上次提交漏掉了几个文件（马上git add）、或者提交信息写错了，用这个命令 123git commit -m &quot;asd&quot;git add forgotten_filegit commit --amend 最终只会有一个提交 移除文件从 Git 中移除某个文件，就需要将它移出跟踪文件清单（也是从暂存区移出） git rm ： 连带着在工作区也删除了（因为工作区只是 .git 的一个版本快照） 如果只是在工作目录删除文件，那只会作为一次操作记录，会出现 Changes not staged for commit 如果要删除之前修改过、已经放到暂存区的文件，需要使用 git rm -f ， 这样的数据不能被 Git 恢复 删除 git 暂存区的文件 而保留在磁盘： git rm —cached README 移动文件 （不重要）git mv file_from file_to git mv 相当于下面三个命令： mv file1 file2 git rm file1 git add file2 查看提交历史（重要）git log ： -n 显示最近 n 次提交 -p 按照补丁格式显示统计信息 –stat 显示简略统计信息 –pretty(很有用)，比如 git log —pretty=oneline ， 将信息展示为一行 –pretty=format 还有很多种参数 撤销操作（重要）一、取消暂存的文件： 不同的版本不一样，git status 会提示你，怎么取消暂存，我这边是 git restore —staged 二、撤销对文件对修改： 不同的版本不一样，git status 会提示你，怎么取消修改，我这边是 git restore file 12“这是一个危险的命令。 你对那个文件在本地的任何修改都会消失Git 会用最近提交的版本覆盖掉它。 除非你确实清楚不想要对那个文件的本地修改了，否则请不要使用这个命令。” Git 中任何 已提交 的东西几乎总是可以恢复 远程仓库使用（重要）并不一定是 github 或者 gittee 才是远程仓库，任何不在本地的 git 仓库都是远程仓库 12git remote &#x2F;&#x2F; 查看已经配置的远程仓库git remote -v &#x2F;&#x2F; 查看简写以及URL，会全部列出 查看远程仓库 1git remote show &lt;remote&gt; (常用) 可以看到远程有两个分支、一个main一个master 添加远程仓库 1git remote add &quot;shortname&quot; &quot;url&quot; fetch 和 pull（重要）git fetch remote 会访问远程仓库，拉取所有你还没有的数据。拉取完后，会拥有所有分支的引用 如果 clone 了一个仓库，会自动添加远程仓库，默认为 origin git fetch origin 会抓上一次抓取后新的推送的所有工作 fetch 只会将数据下载到本地仓库，而不会自动合并 pull 在抓取数据后会尝试直接合并分支 ，git pull 会从最初克隆的服务器上抓取数据并自动尝试合并 git pull 相当于三条命令 1234git pull&#x2F;fetch &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; (常用)git fetch origin master:tmp &#x2F;&#x2F; 从远程拉一个分支到tmp分支git merge tmp &#x2F;&#x2F; 尝试合并当前分支和tmp分支git branch -d tmp &#x2F;&#x2F; 删除tmp分支 pull 自带的merge 不是很好用（有时候会发生错误），建议还是 git fetch origin master:tmp push1git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt; 如果省略远程分支名，则表示将本地分支推送与之存在”追踪关系”的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。 1git push origin master push 前一定要先抓取、消除冲突，再 push。开始工作前也 fetch 一下，在最新的版本上开发 git taggit tag 命令查看所有标签 也可以 git tag -l “v1.8*” 列出所有版本号为1.8开头的版本 git 有两种标签： 轻量标签：只是某个特定 commit 的引用 git tag v1.4 附注标签：是Git 数据库中的一个完整对象，是可以被校验的，包含打标签的人的名字、邮箱、日期、还可以签名验证 、 创建附注标签很简单 git tag -a v1.4 -m ”my version 1.4“ 标签要另外push才会到远程 1git push origin v1.1 注意⚠️：tag 是和某个 commit 直接绑定的，而非 branch 所以你切换分支了，还是可以看到这个 tag（ git show v1.2 ) 所以你推到远程去， 不需要指定分支 而是直接 push origin v1.2 版本回滚（重要）首先通过 git log 或者 git tag 查看 xxx git reset —hard xxx ( xxx为某个 commit 的hash 或者某个 tag ) 回滚后看不到 git log 了怎么办？( tag还是能看见 ) git reflog git 分支（重要）将每个commit 理解为链表的节点、就很容易理解分支了 HEAD 指针，指向当前所在的本地分支，HEAD指向master，你就在master分支上 其实所有的 HEAD、master、dev、都是一个指向commit 的指针，只是不同的分支向不同的方向延续 git switch 切换分支、会改变你的工作目录 这种情况如果修改了同一个文件，merge会冲突，这个时候需要手动解决冲突，再 add 、 commit git branch 查看（新建）分支（基本命令） git branch -d 删除分支 稳定分支的指针总是在提交历史中落后一大截，而前沿分支的指针往往比较靠前。 删除远程分支： 12git push origin --delete serverfixTo https:&#x2F;&#x2F;github.com&#x2F;schacon&#x2F;simplegit 变基整合分支最容易的就是 merge 命令，会将两个分支的最新快照、以及二者的最近共同祖先，三者合并，生成新的 commit 还有一种合并的方法： 变基： git switch c4 \\ git rebase c5 将 C4 的修改 按顺序应用到 C5 提取C4的补丁和修改、在C3的基础上再应用一次 结果都是一样，但是变基使得提交历史更加整洁 变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起 变基的风险： 如果提交存在于你的仓库之外，而别人可能基于这些提交进行开发，那么不要执行变基 大厂实际工作中 Git 流程master 永远是正常稳定可用的主干分支拉出一个 dev 分支，check out from master （master镜像）、类似防火墙 dev 是所有开发小组的一个共用分支 但是如果开发人员都向dev 提交，会频繁发生冲突 所以开发人员各再拉分支 开发人员要提交到dev之前，小组内先合一下 测试人员一般从 dev 拉代码测试、没问题了之后，运维把 dev 合并到 master 从 master 拉一些 Tag 、 Release 发布小更新 、 feature（加一些新的东西、不想影响原来的东西） git 5、6成的时间都在解决冲突 大厂还有专门的 CMO ：配置管理员：解决各种冲突","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://panlianghnu.github.io/tags/git/"}]},{"title":"操作系统原理与程序逻辑训练","slug":"操作系统原理与程序逻辑训练","date":"2020-12-13T12:57:34.000Z","updated":"2021-03-14T14:59:51.480Z","comments":true,"path":"2020/12/13/操作系统原理与程序逻辑训练/","link":"","permalink":"https://panlianghnu.github.io/2020/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E7%A8%8B%E5%BA%8F%E9%80%BB%E8%BE%91%E8%AE%AD%E7%BB%83/","excerpt":"","text":"C语言和操作系统的交互C语言的main函数其实就是和操作系统的交互之一，执行程序前，操作系统将程序的二进制可执行代码加载到内存的代码段，同时会把函数名为main的函数作为程序的入口 Linux 的终端里： 命令1 &amp;&amp; 命令2 表示先执行命令1，成功了再执行命令2，如果命令1执行错误则不会执行命令2 小技巧：可以用 echo $? 查看上一个命令执行的返回值 而C语言的 int main() 需要有一个int 类型的返回值，这也涉及到和Linux 操作系统的交互 return 0 不是乱写，而是代表执行成功，程序正常退出，操作系统可以获得main 函数的返回值，通过 echo $? 打印到终端，通过main 函数的返回值，操作系统可以执行不同的逻辑 C语言的int main(int argv,char * argc[]) ，参数从终端读参数， argv代表参数个数，argc代表参数列表 这些是操作系统和C语言的交互 经典程序 1234567#include &lt;stdio.h&gt;int main(int argc,char* argv [])&#123; int i; for(i=0;i&lt;argc;i++) printf(&quot;argc[%d] is %s\\n&quot;,i,argv[i]); return 0;&#125; 这个程序可以很直观的看到Linux 在调用C语言程序时，传入的各个参数 Linux 标准输入输出流、错误流stdin stdout stderr stdin : 默认是键盘输入，可以通过流的重定向改变输入流 stdout：默认是显示器输出，也可以重定向到网卡、打印机等 stderr：错误流 echo $? 命令可以打印出当前程序的返回值 流在Linux 系统里被抽象成一个个文件，比如我要往打印机写东西，我就会打开“打印机”这个文件，往里面写东西 每启动一个包含的程序，Linux会默认打开 stdin\\ stdout\\ stderr这三个文件 比如 : printf(“hello”) = fprintf(stdout,“hello”) scanf(“%d”,&amp;a) = fscanf(stdin,”%d”,&amp;a) fprintf(stderr, “the value must &gt; 0”) 输出到 stderr 默认也是显示器，我以前在DevC++里输出到stderr， 是输出红色字体，ubuntu的终端好像没有对这个stderr进行特殊标记，只能通过重定向或者 echo $? 来知道确实是发生了错误 Linux 流的重定向0 是标准输入流 1 是标准输出流 2 是标准错误流 ./a.out 1&gt;&gt; a.txt 代表对a.out 这个程序的 标准输出流 重定向 到 a.txt （1可以默认不写） 12345#include &lt;stdio.h&gt;int main()&#123; printf(&quot;hello world&quot;); return 0;&#125; 可以看到 ls -l 的信息被输出到了文件 b.txt 其实双箭头和单箭头都可以作为流的重定向，他们有小小的区别 双箭头不会覆盖文件，会在文件末尾写值 单箭头则会覆盖文件 ./a.out &gt; a.txt &lt; 是标准输入流的重定向这三个重定向是可以组合使用的 Linux 管道| 表示管道 比如： ls /etc/ | grep ab 表示，将 ls 产生的标准输出流，通过管道，传递给 grep（文本搜索的小程序）的标准输入流 看看实际操作： 这就是grep 搜索 ls 的结果，找出结果里包含ab的行，输出到标准输出流 这就是grep 搜索 ps 的结果，找出结果里包含ssh的进程，输出到标准输出流 Linux 管道实战两个程序，一个输出sum和count，一个通过sum和count求平均值这两个程序可以直接通过管道相连，让第一个程序的输出进入下一个程序的标准输入这次直接输出来的是平均数 很简单的将两个独立小工具变成更加复杂的工具使用 Make 学习在代码目录下 编写Makefile 文件 # 代表注释 hello.out: max.o hello.c #这行代表hello.out 需要max.o 和 hello.c 两个文件 gcc max.o hello.c -o hello.out # 这行必须以table开头，表示实际的gcc命令 max.o: max.c gcc -c max.c可以看到我的Makefile 里定义了main.out 和 compute.o 的编译方式，为了调试方便我加了 -g 现在make 试一下 可以看到运行make 后，生成了 main.out compute.o 运行也是没有问题的 为什么使用make？使用make ，可以让大型程序在小部分代码改动时，不至于全部重新编写 make 会在Makefile文件中查询需要的文件是否已经有了，如果某部分文件已经存在则会跳过 make可以大大的节省编译时间（已经编译了不需要重新编译的文件 make 会帮我们跳过），并且Makefile写好各文件的依赖规则，每次编译都能方便程序员直接调用（大型项目自己写gcc不可想象） GDB 调试先编译时加 -g 参数 执行 gdb ./main.out b 12 标记断点 l 输出源代码 n 下一步 s 单步进入 p 打印参数数据、地址、函数等 bt 打印堆栈 f 进入栈帧 函数指针指向函数的指针变量。 因此“函数指针”本身首先应是指针变量，只不过该指针变量指向函数。这正如用指针变量可指向整型变量、字符型、数组一样，这里是指向函数。C在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。有了指向函数的指针变量后，可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样。 函数指针有两个用途：调用函数和做函数的参数 &amp;a 是 得到a的地址 p 打印一个 x/3d 打印三个整数 x/3cb 打印三个字符，b是一个个打印 回调函数： 在调用一个函数（A函数）时，传入一个函数指针（B函数）作为参数，在A函数运行期间，调用了B函数，那么这就是一个回调。回调函数可以帮助我们实现很多功能 比如 C语言标准库就为我们实现了快速排序，但是标准库的快速排序它并不知道你要排序的数据是整数、还是字符，甚至是自己定义的结构体，如果是基本类型还好说，但如果是你要对自己定义的结构体排序的话，它并不知道你的结构体是如何进行排序的，这个时候你需要把排序的定义告诉它，即你需要实现一个比较大小的函数，将这个函数作为参数传递给这个标准库函数。这时就可以调用快速排序为你的结构体排序了。 可以看到有了回调，我们就不需要关心快速排序实现的细节，只需要将我们定义的比较函数传给排序函数，就可以帮助我们实现快速排序。 操作系统内存管理 如图所示：操作系统内核使用的是高地址段，代码段是最低的地址段 系统内核是不允许被其他进程修改的 代码段用于保存运行的各个程序的二进制代码 代码段上面是数据段，用来存储一些全局变量、常量、字符串等 堆 数据段上面是堆内存空间，是程序动态申请的内存空间，堆内存比较大，所以程序如果要申请一个大数组什么的，需要调用malloc来申请一片堆内存，堆内存是需要自己去释放的（C语言），Java、go等语言有垃圾回收，不需要程序员来手动回收 栈 栈内存用于维护程序运行时环境，每调用一个函数，即会开辟一个新的栈帧（所以在递归调用时，如果递归深度太高会产生巨大的空间复杂度，甚至会出现段错误，核心转储 每个栈帧都有两个寄存器，一个栈指针寄存器（ESP寄存器，指向栈顶），一个栈的基地址（EBP，指向栈的底部），当然栈是往下长的，EBP的地址会大一些 每次调用函数即会在栈帧底部保存一个返回值（EBP的值），然后向下新开辟一个栈帧（让EBP往下指，ESP=EBP - 栈大小），(push ebp) (mov ebp, esp) 然后栈内存记录函数里新定义的各个变量 函数执行完，返回的时候，mov esp,ebp， 让esp = ebp，再pop ebp，栈顶弹出之前保存的返回值给ebp，这样就回到了上一个栈帧，返回值一般是eax寄存器传递 程序调用时内存变化 当操作系统调用执行一个程序时 将二进制代码（text）放入代码段 将二进制程序的常量、字符串、全局变量等 放入数据段 根据代码段，新开辟栈帧用于维护运行时环境，然后cpu根据PC寄存器取指令，执行指令 终端执行一个 ./main.out 时，函数的调用流程： 用户在终端敲击回车时，会触发CPU的中断，CPU会保存当前程序的各种寄存器的值，保存栈帧的信息等，放入进程结构体中（内存），操作系统陷入内核态，根据中断向量表和中断编号，找到对应的中断处理函数，发现现在要调用一个程序，于是操作系统将程序二进制可执行代码载入内存的代码段，常量、字符串等载入内存的数据段，为该程序申请时间片，把程序的状态修改为就绪状态，当程序执行时，新开辟（或者从进程结构体中读取之前的）栈帧，执行代码段段二进制代码 抽象昨天写了一些简单程序设计，打印正方形、空心正方形、等腰三角形、空心菱形、“回”字等 很久没写过这种程序了。。。刚开始写正方形、三角形都还好，基本上写一遍就过了，不会一直调试，反复测试才能过。后面到了复杂的菱形、“回”字，就需要大量的调试，不断的设计 i、j 的值。让 i、j、num这三个变量组成一个线性函数，设计一个二维的矩形 但是龙哥让我们把一些重复劳动抽象出来 比如写一个 printChar(char ch, int n) ; 打印 n 个字符，这个简单的函数就大大地提升了我们的开发效率，让我们不需要将注意力集中在打印几个字符上，我们只需要关注这个图形的规律，第几行先打印几个空格，再打印几个字符即可 程序设计确实应该是一个不断抽象的过程，如果main 函数里的每一行代码都设计到最后的结果，那以后再来看这份代码又看不懂了。开发的时候应该逻辑更清晰一些，哪几行代码干了什么事，什么函数负责干什么，main 函数里只负责很宏观的事情，实现细节应该抽象出来","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https://panlianghnu.github.io/tags/linux/"},{"name":"c语言","slug":"c语言","permalink":"https://panlianghnu.github.io/tags/c%E8%AF%AD%E8%A8%80/"}]},{"title":"2020-12-4-学习笔记","slug":"2020-12-4-学习笔记","date":"2020-12-13T12:57:04.000Z","updated":"2021-03-14T14:59:36.440Z","comments":true,"path":"2020/12/13/2020-12-4-学习笔记/","link":"","permalink":"https://panlianghnu.github.io/2020/12/13/2020-12-4-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"处理器的架构不断变化X86架构是通用指令集，X86的芯片也是通用芯片 即这个芯片可以完成各种其他架构芯片的任务，比如作为鼠标芯片、路由器芯片、交换机芯片等 ARM架构是精简指令集、功耗低、速度快、手机上和苹果M1芯片是ARM架构 磁盘阵列磁盘阵列就是把几个盘组合起来，操作系统读出来是一个盘，但底层是好几个盘 RAID0: 操作系统对磁盘的读写在两个盘同时进行，数据被分片在两个盘分开存储，读写速度几乎翻倍，容量不变（还是两个盘的大小） RAID1:操作系统对磁盘的读写会被镜像一次，相当于另一个盘作为实时备份，这样两个盘变成一个盘，速度不变，容量减半（两个盘读出来只有一个盘的大小），大大的增加了系统的可靠性，数据损坏可以实时恢复，甚至一个盘坏了还能换一个新盘用 RAID10（不是十）：四个盘变成一个盘，把RAID0和RAID1结合起来 负载均衡 集群（今天是简单集群，不是分布式集群）服务器对外提供服务时，服务器承受的压力随着用户的增加而增加，对服务器的性能要求也会不断上升，提升服务器性能的方式有两种，一种垂直扩容，一种平行扩容 垂直扩容升级CPU、内存等 好处：简单、最稳定，源代码不需要修改可以直接获得性能提升 坏处：花钱多，性能提升一倍、业务负载并不能提升一倍（OS对硬件管理开销增加、散热问题等） 同时服务器也不可能无限升级 平行扩容比较麻烦，需要负载均衡 很多种负载均衡： 轮询（默认） 比如：DNS服务器的域名轮询解析 （dns port 缓存用户的session id，让他每次访问统一服务器，就会话维持），但是数据库不能轮询， F5负载均衡器，类似NAT一样接一端外网，一端接很多服务器，可用性高，安全性也高，服务器不会被直接攻击，以前比较贵，现在比较便宜了 LVS负载均衡，linux服务器作为负载均衡 nginx反向代理（实验），中小企业最常用，C语言实现，可以承载比tomcat 多10几倍的并发请求 今天先不写了，晚安","categories":[],"tags":[{"name":"分布式","slug":"分布式","permalink":"https://panlianghnu.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"nginx","slug":"nginx","permalink":"https://panlianghnu.github.io/tags/nginx/"}]},{"title":"Linux 安装时的一些坑","slug":"Linux-安装时的一些坑","date":"2020-12-13T12:56:08.000Z","updated":"2021-03-14T14:59:32.910Z","comments":true,"path":"2020/12/13/Linux-安装时的一些坑/","link":"","permalink":"https://panlianghnu.github.io/2020/12/13/Linux-%E5%AE%89%E8%A3%85%E6%97%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/","excerpt":"","text":"Linux 安装时分区的挂载问题Linux 单独挂载 /boot。可以单独更新内核，不怕更新内核丢失数据 Linux 单独挂载/swap。 Swap分区会在内存不够时，作为虚拟内存使用（但速度很慢），现在内存一般都够了，这个分区是否单独挂载就无所谓了。 有的古老的应用可能对内存小的机器有优化，有的变量内存需求比较高或者不常用，因而故意取一个很大的地址（让操作系统分配不了这么大的内存地址，从而分配一个虚拟内存），这样的软件如果没有挂载swap分区是有可能跑不起来的 Linux 单独挂载/var 。 默认tomcat、navicat等应用的日志文件放在这里，单独挂载可以在日志快满时换一个盘来，不至于丢失用户日志数据，并且可以热插拔 Linux单独挂载/opt 。 可以建议自己写的程序放在/opt，非必须 Linux单独挂载/usr 。 方便备份软件 Linux单独挂载/user 。 方便备份用户数据 BIOS、EFI的区别主板使用BIOS还是EFI，对Linux 启动盘的制作有很大影响！ BIOS 是简单输入输出系统 是固化到计算机主板上一个ROM上的程序 当计算机启动时，CPU会加载ROM上的程序 BIOS 完成机器的自检后，会扫描硬盘，读取硬盘特定位置的操作系统引导程序（操作系统自举程序），引导程序启动操作系统的各程序 BIOS的功能非常简单，对于操作系统来说，如果主板使用的是BIOS，那么操作系统就必须面对所有的硬件，大到主板显卡，小到鼠标键盘，每次重装系统或者系统升级，都必须手动安装新的驱动 BIOS 主板的系统，虽然攻击者不知道系统盘中操作系统的密码进不了系统，但是可以通过插入一个U盘进入系统，如果其他磁盘没有其他加密手段的话，攻击者可以轻易窃取其他磁盘的数据 UEFI全称Unified Extensible Firmware Interface，即“统一的可扩展固件接口” UEFI是一个微内核系统，具有操控所有硬件资源的能力 可以在里面进行各种设置，比如安全设置，用户用U盘启动系统，只能查看自己U盘里的数据，不能对别的盘进行操作 用户可以进入一个类似shell 的环境，调入执行任何UEFI 程序，可以是自检程序、可以是操作系统引导软件等 Mac 的UEFI 甚至可以在里面驱动网卡、连接投影仪，在UEFI里的各种操作可以直接投影出去 UEFI 的u盘启动盘一般可以兼容BIOS，即使主板只有BIOS，也可以 UEFI 引导进系统，但是当你u盘拔了，可能又进不了系统了 ， 所以制作启动盘的时候一定要注意主板型号（大部分服务器主板较老还是用的bios）","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https://panlianghnu.github.io/tags/linux/"},{"name":"操作系统","slug":"操作系统","permalink":"https://panlianghnu.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"bios","slug":"bios","permalink":"https://panlianghnu.github.io/tags/bios/"}]},{"title":"Linux常用命令","slug":"Linux常用命令","date":"2020-12-13T12:55:30.000Z","updated":"2021-03-14T14:59:26.800Z","comments":true,"path":"2020/12/13/Linux常用命令/","link":"","permalink":"https://panlianghnu.github.io/2020/12/13/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"Linux 常用命令Linux 命令太多，很多命令又有很多参数，不常用的命令是很容易忘记的，做一个备忘参考的博客链接 显示目录和文件的命令 Ls：用于查看所有文件夹的命令。 ls -l，显示详细信息（常用） Tree： 以树状图列出目录内容（需要apt install tree) Du：显示目录或文件大小 ，查看磁盘信息 修改目录，文件权限和属主及数组命令 Chmod：用于改变指定目录或文件的权限命令。 Chown：用于改变文件拥有属性的命令。 Chgrp：用于改变文件群组的命令。 Chattr：用于设置文件具有不可删除和修改权限。 Lsattr：用于显示文件或目录的隐藏属性。 创建和删除目录的命令 Mkdir：用于创建目录 Rm -f：用于删除目录 创建和删除，重命名，复制文件的命令 Touch：创建一个新的文件 Vi:创建一个新的文件 Rm：删除文件或目录 Mv：重命名或移动文件的命令 Cp：复制命令 Scp：用于将本地的文件或目录复制到远程服务器 Wget：用于下载ftp或http服务器文件到本地。 ##显示文件内容的命令 Cat：用于显示指定文件的全部内容 More：用分页的形式显示指定文件的内容 Less：用分页的形式显示指定文件的内容，区别是more和less翻页使用的操作键不同。 Head：用于显示文件的前n行内容。 Tail：用于显示文件的后n行内容。 Tail -f：用于自动刷新的显示文件后n行数据内容。 查找命令Find：查找指定目录或文件的命令。 Whereis：查找指定的文件源和二进制文件和手册等 Which：用于查询命令或别名的位置。 Locate：快速查找系统数据库中指定的内容。 Grep：在指定的文件或标准输出，标准输入内，查找满足条件的内容。 关机和重启计算机的命令 Shutdown：-r 关机后立即重启（reboot now 也行） 123-k 并不真正的关机，而只是发出警告信息给所有用户 -h 关机后不重新启动 Poweroff：用于关机和关闭电源 Init：改变系统运行级别 123456789101112130级用于关闭系统1 级用于单一使用者模式2级用来进行多用户使用模式（但不带网络功能）3级用来进行多用户使用模式（带网络全功能）4级用来进行用户自定义使用模式5级表示进入x windows时的模式6级用来重启系统 Reboot： 用于计算机重启 Halt：用于关闭计算机系统 压缩和打包命令Tar：用于多个文件或目录进行打包，但不压缩，同时也用命令进行解包 123456789101112131415-A 新增压缩文件到已存在的压缩-c 建立新的压缩文件-d 记录文件的差别-r 添加文件到已经压缩的文件-u 添加改变了和现有的文件到已经存在的压缩文件-x 从压缩的文件中提取文件-t 显示压缩文件的内容-z 支持gzip解压文件-j 支持bzip2解压文件-Z 支持compress解压文件-v 显示操作过程-l 文件系统边界设置-k 保留原有文件不覆盖-m 保留文件不被覆盖-W 确认压缩文件的正确性 用户操作命令Linux用户在操作系统可以进行日常管理和维护，涉及到的相关配置文件保存在 /etc/ Su：切换用户命令 Sudo：一系统管理员的身份执行命令 Passwd：用于修改用户的密码 adduser：用于创建新用户，同时会创建该用户的组，默认用户a属于主组a，还会创建用户的默认home目录等信息 deluser：用于删除用户，删除用户后home目录并不会主动删除，需要手动再删除 三个change chmod ， 修改文件权限：rwxrwxrwx，比如 chmod 777 a.txt 打开a的所有权限 chgrp ， 修改文件或文件夹所属的组。 比如chgrp group1 a .txt 让a属于group1 chown， 修改文件或文件夹的所有者。 比如chown user1 a.txt 让a属于user1 改变目录和查看当前目录命令Cd：进入工作目录 Cd …：会退到上一级命令 Pwd：显示当前用户所在工作目录位置 文件连接命令Ln：为源文件创建一个连接，并不将源文件复制一份，即占用的空间很小。 123可以分为软件连接和硬链接。软连接：也称为符号连接，即为文件或目录创建一个快捷方式。 硬链接：给一个文件取多于一个名字，放在不同目录中，方便用户使用。 Ln命令参数如下： 12345678910111213-f：在创建连接时，先将与目的对象同名的文件或目录删除。-d：允许系统管理者硬链接自己的目录。-i：在删除与目的对象同名文件或目录时先询问用户。-n：在创建软连接时，将目的对象视为一般的文件。-s：创建软连接，即符号连接。-v：在连接之前显示文件或目录名。-b：将在连接时会被覆盖或删除的文件进行备份。 其他命令Ps：显示瞬间进程的动态 Date：显示或设定系统的日期与时间。 Kill： 杀死一些特定的进程 Logout：退出系统 Clear：清屏 Passwd：设置用户密码 vi编辑器首先用vi命令打开一个文件 末行模式命令： :n,m w path/filename 保存指定范围文档（ n表开始行，m表结束行） :q! 对文件做过修改后，强制退出 :q 没有对文件做过修改退出 Wq或x 保存退出 dd 删除光标所在行 : set number 显示行号 : n 跳转到n行 : s 替换字符串 : s/test/test2/g /g全局替换 /也可以用%代替 / 查找字符串 网络通信常用的命令Arp：网络地址显示及控制 ftp：文件传输 Lftp：文件传输 Mail：发送/接收电子邮件 Mesg：允许或拒绝其他用户向自己所用的终端发送信息 Mutt E-mail 管理程序 Ncftp ：文件传输 Netstat：显示网络连接.路由表和网络接口信息 Pine：收发电子邮件，浏览新闻组 Ping：用于查看网络是否连接通畅 Ssh：安全模式下远程登陆 Telnet：远程登录 Traceroute：显示到达某一主机所经由的路径及所使用的时间。 Wget：从网路上自动下载文件 SSH 注意事项 确保配置好了SSH登陆、再关闭密码登陆，否则有登不上服务器的风险 员工离职了直接deluser、再删除他的home，他就无法再登陆服务器了 SSH端口最好配置一下端口，默认的22端口可能会被恶意扫描","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https://panlianghnu.github.io/tags/linux/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://panlianghnu.github.io/tags/ubuntu/"},{"name":"转载","slug":"转载","permalink":"https://panlianghnu.github.io/tags/%E8%BD%AC%E8%BD%BD/"}]},{"title":"安装Ubuntu","slug":"安装Ubuntu","date":"2020-12-13T12:52:33.000Z","updated":"2021-03-14T14:59:54.780Z","comments":true,"path":"2020/12/13/安装Ubuntu/","link":"","permalink":"https://panlianghnu.github.io/2020/12/13/%E5%AE%89%E8%A3%85Ubuntu/","excerpt":"","text":"前言以前我会写一些学习笔记.md，但没有发博客的习惯，现在参加了线下脱产的CSDN技术训练营，要求每个人定期的发自己的学习心得，刚好让我养成发博客的习惯。 安装Ubuntu既然要学习Linux 和C语言编程，那么第一件事当然是装一个Linux系统。我这里选择的是Ubuntu 20.04LTS版本，Ubuntu 的安装有全图形界面、驱动也比较好装（比如对英特尔显卡支持就比很多Linux发行版好），用的是Debian系的软件包管理，软件资源丰富。Ubuntu用的人很多，找各种教程也比较方便。下面是安装Ubuntu的步骤了，安装之前先要空出一个磁盘来，或者分一个盘出来，如果经常用建议50GB往上，我主要就做做实验就只分了20GB 一、下载镜像 二、下载启动盘制作工具Rufus 可以方便地制作一个启动盘因为我之前做过kubuntu的启动盘所以我的u盘名字叫Kubuntu…听说要装ubuntu20.04LTS，我又把kubuntu格了… 三、制作启动盘导入之前下好的Ubuntu镜像文件，系统类型选择UEFI（后面会介绍EFI和BIOS区别），文件系统选默认的FAT32就好（FAT32可以同时被Windows和MacOS识别，兼容性不错，其他的默认就好 四、重启电脑插入U盘，重启电脑，按住F2进入BIOS 五、进入bios直接在Exit里选择UEFI 回车即可从U盘启动 六、加载启动盘系统在检查U盘里的数据 七、选择安装路径请原谅我的手机拍电脑屏幕…我直接将根目录/ 挂载到我之前分出来的20GB新盘里去了，格式化选择EXT4文件系统（现在Linux一般都用EXT4）我是图省事，只挂载了根目录/ ，其他目录都是默认的，后面会介绍各个目录分别挂载的好处，我只是图方便，大家看看就好，没必要照着我的弄 这一步完了之后都是自动化安装了 八、安装成功uname -a 查看ubuntu的版本信息 九、切换国内源在使用Ubuntu的时候，我们会经常用到 apt-get install 命令，这个命令就是从你的源地址下载互联网软件包到本机并安装，Ubuntu官方的源速度很慢，经常有一个软件包下几小时的情况，所以我们得换个源 Ubuntu20.04自带了换源GUI 打开软件和更新，进入设置-Ubuntu软件-下载自这里可以选择下载服务器，我选择的阿里云的源，确定后会自动让你更新源，相当于执行apt-get update，输密码即可 十、驱动N卡Ubuntu 默认是用核显的，我们想要使用独显还得装一下驱动ubuntu 对n卡支持很好，直接在软件和更新-附加驱动上点两下就装好了deepin还要加油，装个n卡驱动死活装不上 终端执行nvidia-smi 查看n卡信息：可以看到n卡被正确驱动了 安装deepin-wineLinux 的软件生态对比Windows 还是差了点比如QQ for Linux 还是09年的界面，微信、钉钉就压根没有官方的Linux 支持版本（QQ微信的Web端还经常不让你用），但是2020年了，谁能摆脱这几个软件呢，想在Linux 里跑Windows 软件，我们需要装一个deepin-winewget -O- https://deepin-wine.i-m.dev/setup.sh | shsudo apt-get install deepin.com.wechatsudo apt-get install deepin.com.qq.im可惜，ubuntu对wine支持不好，最小化有bug，没有deepin支持得好","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https://panlianghnu.github.io/tags/linux/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://panlianghnu.github.io/tags/ubuntu/"}]},{"title":"修复不显示图片","slug":"修复不显示图片","date":"2020-12-13T11:56:16.000Z","updated":"2021-03-14T15:00:03.650Z","comments":true,"path":"2020/12/13/修复不显示图片/","link":"","permalink":"https://panlianghnu.github.io/2020/12/13/%E4%BF%AE%E5%A4%8D%E4%B8%8D%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87/","excerpt":"","text":"hexo 图片显示问题及使用typora设置图片路径使用hexo生成静态资源后,由于url的问题会出现图片加载的问题,现在网上的文章及官方的解决方案大概分为三种: 将图片放入source/images目录下,每次generate都会生成图片,在使用相对或绝对路径进行引用 配置hexo的_config.yml文件, 将 post_asset_folder 设置为true, 这样每次new 生成一个文章时都会同步生成一个同名的文件夹,然后设置相对或绝对路径. 使用hexo官方的解决方案,使用模版变量, &#123;% asset_img slug [title] %&#125; 但是在配置过程中发现这三种方式都多多少少存在一些问题,前两中首页跟内容页会有一个加载失败的问题,而第三种则失去了markdown的意义. 解决方法： 1234设置post_asset_folder 为 true, 安装插件 asset-imagenpm install https:&#x2F;&#x2F;github.com&#x2F;CodeFalling&#x2F;hexo-asset-image设置图片为相对路径hexo clean &amp;&amp; hexo generate &amp;&amp; hexo s 运行查看 Nice！","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://panlianghnu.github.io/tags/hexo/"}]},{"title":"first blog","slug":"first-blog","date":"2020-12-12T08:19:55.000Z","updated":"2020-12-12T08:21:49.000Z","comments":true,"path":"2020/12/12/first-blog/","link":"","permalink":"https://panlianghnu.github.io/2020/12/12/first-blog/","excerpt":"","text":"这是我的第一个博客😁 😄 😂","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://panlianghnu.github.io/tags/python/"},{"name":"Flask","slug":"Flask","permalink":"https://panlianghnu.github.io/tags/Flask/"},{"name":"Vue","slug":"Vue","permalink":"https://panlianghnu.github.io/tags/Vue/"},{"name":"JWT","slug":"JWT","permalink":"https://panlianghnu.github.io/tags/JWT/"},{"name":"机器学习","slug":"机器学习","permalink":"https://panlianghnu.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"nodejs","slug":"nodejs","permalink":"https://panlianghnu.github.io/tags/nodejs/"},{"name":"P2P","slug":"P2P","permalink":"https://panlianghnu.github.io/tags/P2P/"},{"name":"websocket","slug":"websocket","permalink":"https://panlianghnu.github.io/tags/websocket/"},{"name":"聊天室","slug":"聊天室","permalink":"https://panlianghnu.github.io/tags/%E8%81%8A%E5%A4%A9%E5%AE%A4/"},{"name":"c语言","slug":"c语言","permalink":"https://panlianghnu.github.io/tags/c%E8%AF%AD%E8%A8%80/"},{"name":"区块链","slug":"区块链","permalink":"https://panlianghnu.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"Anaconda","slug":"Anaconda","permalink":"https://panlianghnu.github.io/tags/Anaconda/"},{"name":"转载","slug":"转载","permalink":"https://panlianghnu.github.io/tags/%E8%BD%AC%E8%BD%BD/"},{"name":"MacOS","slug":"MacOS","permalink":"https://panlianghnu.github.io/tags/MacOS/"},{"name":"Language","slug":"Language","permalink":"https://panlianghnu.github.io/tags/Language/"},{"name":"git","slug":"git","permalink":"https://panlianghnu.github.io/tags/git/"},{"name":"linux","slug":"linux","permalink":"https://panlianghnu.github.io/tags/linux/"},{"name":"分布式","slug":"分布式","permalink":"https://panlianghnu.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"nginx","slug":"nginx","permalink":"https://panlianghnu.github.io/tags/nginx/"},{"name":"操作系统","slug":"操作系统","permalink":"https://panlianghnu.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"bios","slug":"bios","permalink":"https://panlianghnu.github.io/tags/bios/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://panlianghnu.github.io/tags/ubuntu/"},{"name":"hexo","slug":"hexo","permalink":"https://panlianghnu.github.io/tags/hexo/"}]}