<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>PanLiang&#39;s blog</title>
  
  
  <link href="https://panlianghnu.github.io/atom.xml" rel="self"/>
  
  <link href="https://panlianghnu.github.io/"/>
  <updated>2021-06-30T02:15:20.867Z</updated>
  <id>https://panlianghnu.github.io/</id>
  
  <author>
    <name>Pan Liang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>小程序框架选择</title>
    <link href="https://panlianghnu.github.io/2021/06/29/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6%E9%80%89%E6%8B%A9/"/>
    <id>https://panlianghnu.github.io/2021/06/29/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6%E9%80%89%E6%8B%A9/</id>
    <published>2021-06-29T08:51:33.000Z</published>
    <updated>2021-06-30T02:15:20.867Z</updated>
    
    <content type="html"><![CDATA[<h1 id="小程序框架选择"><a href="#小程序框架选择" class="headerlink" title="小程序框架选择"></a>小程序框架选择</h1><h2 id="微信小程序主流框架"><a href="#微信小程序主流框架" class="headerlink" title="微信小程序主流框架"></a>微信小程序主流框架</h2><p>微信小程序开发目前有三种主流的框架</p><ul><li><a href="https://wepyjs.gitee.io/wepy-docs/">WEPY</a></li><li><a href="http://mpvue.com/mpvue/#-html">MpVue</a></li><li><a href="https://taro.aotu.io/">Taro</a></li></ul><p>1 WEPY<img src="/2021/06/29/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6%E9%80%89%E6%8B%A9/image-20210629171047624.png" alt="image-20210629171047624"></p><p>WEPY是腾讯团队开源的一款类vue语法规范的小程序框架</p><blockquote><p>WEPY借鉴了Vue的语法风格和功能特性,支持了Vue的诸多特征，比如父子组件、组件之间的通信、computed属性计算、wathcer监听器、props传值、slot槽分发，还有很多高级的特征支持：Mixin混合、拦截器等;WePY发布的第一个版本是2016年12月份，也就是小程序刚刚推出的时候，到目前为止，WePY最新版本为2.1.0;</p></blockquote><p>2 MpVue<img src="/2021/06/29/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6%E9%80%89%E6%8B%A9/image-20210629171015984.png" alt="image-20210629171015984"></p><p>MpVue是美团团队开源的一款使用 Vue.js 开发微信小程序的前端框架</p><blockquote><p>使用此框架，开发者将得到完整的 Vue.js 开发体验，同时为 H5 和小程序提供了代码复用的能力。mpvue在发布后的几天间获得2.7k的star,上升速度飞起,截至目前为止已经有20.3k的star;</p></blockquote><p>3<img src="/2021/06/29/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6%E9%80%89%E6%8B%A9/image-20210629172707808.png" alt="image-20210629172707808"></p><p>Taro是京东凹凸实验室开源的一款使用 React.js 开发微信小程序的前端框架，Github上Star达到了29.1k，最高</p><blockquote><p>京东凹凸实验室开源的一款使用 React.js 开发微信小程序的前端框架。它采用与 React 一致的组件化思想，组件生命周期与 React 保持一致，同时支持使用 JSX 语法，让代码具有更丰富的表现力，使用 Taro 进行开发可以获得和 React 一致的开发体验。同时因为使用了react的原因所以除了能编译h5, 小程序外还可以编译为ReactNative;</p></blockquote><p>注：现在Taro支持React的同时也支持Vue，并且UI组件多，解决方案多，推荐使用Taro进行开发</p><p>详细的性能评测参考：<a href="https://ask.dcloud.net.cn/article/35867">跨端框架深度评测：微信原生、wepy、mpvue、taro</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;小程序框架选择&quot;&gt;&lt;a href=&quot;#小程序框架选择&quot; class=&quot;headerlink&quot; title=&quot;小程序框架选择&quot;&gt;&lt;/a&gt;小程序框架选择&lt;/h1&gt;&lt;h2 id=&quot;微信小程序主流框架&quot;&gt;&lt;a href=&quot;#微信小程序主流框架&quot; class=&quot;header</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>CNN</title>
    <link href="https://panlianghnu.github.io/2021/04/19/CNN/"/>
    <id>https://panlianghnu.github.io/2021/04/19/CNN/</id>
    <published>2021-04-19T07:55:50.000Z</published>
    <updated>2021-04-20T03:09:15.095Z</updated>
    
    <content type="html"><![CDATA[<p>CNN is sub of deep learning</p><p>why CNN for image？</p><ul><li>有些图案比整个图像小得多（Convolution）</li><li>相同的特征图案出现在不同的位置（Convolution）</li><li>对图片进行降维几乎不会影响图像识别（Max pooling）</li></ul><p><img src="/2021/04/19/CNN/image-20210419155608178.png" alt="image-20210419155608178"></p><p>Convolution 卷积</p><p>有很多 Filter，对应做内积，可以发现是否有 斜对角111 的出现，发现两个三，就找到了两个斜线</p><p><img src="/2021/04/19/CNN/image-20210420101330574.png" alt="image-20210420101330574"></p><p>在一个 Convolution 里面有很多的 Filter，去找到对应的特征，把 6x6 的 image 变成了 4x4的 Feature Map</p><p>for 彩色图片，Filter 变成立体的</p><p><img src="/2021/04/19/CNN/image-20210420101801859.png" alt="image-20210420101801859"></p><p>CNN 和 Fully connected 的关系</p><p>Convolution 其实就是一个 Fully Connected 拿掉一些 weight</p><p><img src="/2021/04/19/CNN/image-20210420102206583.png" alt="image-20210420102206583"></p><p>某个神经元只连接到9个input，并非全连接。而且神经元会共用 weight，Shared weights。</p><p>Max pooling ，选出4x4的Feature Map的最大值，就变成了 4x4 的image是比较小的 image，可以不断的卷积+MaxPooling</p><p><img src="/2021/04/19/CNN/image-20210420105001668.png" alt="image-20210420105001668"></p><p><img src="/2021/04/19/CNN/image-20210420105010293.png" alt="image-20210420105010293"></p><p>1x28x28(黑白，28x28) 25x26x26(25个Filter, 卷积让长宽减2)</p><p>Max Pooling 则4个合起来选一个做代表，让长宽都减半，不断重复</p><p>最后 call model2.add(Flatten()) 把matrix拉直，丢进一个 fully connected network</p><h2 id="CNN-学到了什么"><a href="#CNN-学到了什么" class="headerlink" title="CNN 学到了什么"></a>CNN 学到了什么</h2><p><img src="/2021/04/19/CNN/image-20210420110226656.png" alt="image-20210420110226656"></p><p>第K层，是侦测一些特征，比如第三个Filter侦测一些斜的重复条纹</p><p><img src="/2021/04/19/CNN/image-20210420110853028.png" alt="image-20210420110853028"></p><p>可能学到黑白电视也能识别为数字。。。机器的认知和人还是有区别</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;CNN is sub of deep learning&lt;/p&gt;
&lt;p&gt;why CNN for image？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有些图案比整个图像小得多（Convolution）&lt;/li&gt;
&lt;li&gt;相同的特征图案出现在不同的位置（Convolution）&lt;/li&gt;
&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Deep-Forest</title>
    <link href="https://panlianghnu.github.io/2021/04/11/Deep-Forest/"/>
    <id>https://panlianghnu.github.io/2021/04/11/Deep-Forest/</id>
    <published>2021-04-11T05:36:50.000Z</published>
    <updated>2021-04-26T02:51:39.280Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Deep-Forest"><a href="#Deep-Forest" class="headerlink" title="Deep Forest"></a>Deep Forest</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>现如今大部分的深度学习模型都是基于神经网络（即：多层参数化、可微分、非线形模型，通过反向传播训练）</p><p>在本文中，探索了一种基于不可微分的深度学习模型的可能性。</p><p>我们推测，深层神经网络成功背后的奥秘主要归功于三个特征：</p><ol><li>一层一层地处理</li><li>模型内的特征变换</li><li>足够的模型复杂性</li></ol><p>本文提出了 gcForest 方法，生成 deep forest 来保持这三个特征。</p><p>这是一种决策树集成方法，比起深度神经网络需要更少的<code>超参数</code>，它的模型复杂度可以由<code>数据依赖</code>自动决定。</p><p>实验结果表明它的性能对于超参数的设置有很强的鲁棒性，在大多数情况下，甚至跨不同领域的不同数据，它都能够通过使用相同的默认配置得到很好的性能。这个研究打开了基于不可微分模型的深度学习领域的大门，并展示了不使用反向传播构建深层模型的可能性。</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>深度学习在很多领域都很火热。那么，什么是深度学习？大家都回答大概就像这样“深度学习是机器学习的子领域，使用深度神经网络”。实际上，深度神经网络（DNNs）在视觉和语音识别的成功，导致了深度学习的兴起。几乎所有当前的深度学习应用都是基于深度神经网络模型，或者更加专业一点地说，多层<code>参数化、可微分、非线形</code>模型，通过反向传播进行训练。</p><p>尽管深度神经网络很强大，仍然有很多不足之处。</p><blockquote><p>的确，尽管有些作者都使用卷积神经网络，实际上由于许多原因（比如卷积层结构）他们在使用的是不同的学习模型。</p></blockquote><p>First，DNNs有太多的超参数，学习性能严重依赖于仔细的参数调整。这一事实不仅使得训练非常地棘手，让深度学习更像一种 art 而非 science/engineering，还让DNNs的理论分析变得非常困难，因为干扰因素太多，几乎是无限的构型组合，有点不讲道理的意思。</p><p>Second，我们都知道DNNs的训练需要大量的训练数据，因此，当只有少部分训练数据时，DNNs就几乎不能被应用了，当数据规模不大不小时，有时甚至训练失败。注意到，在大数据领域，许多真实的训练任务缺乏足够多的<code>labeled data</code>，导致DNNs在这些任务中的性能较差。</p><p>Moreover，我们都知道神经网络是一个<code>black-box</code>，它的 decision process 通常难以理解，学习行为也很难以进行理论分析。</p><p>Furthermore，神经网络架构需要在训练之前确定好。因此，模型复杂度也是提前确定好的。我们推测深度模型通常比实际需要的要复杂得多，通过观察，最近有很多关于DNNs通过<code>add shortcut connection</code>来提高性能的报道得到了证实。因为这些操作简化了原始网络，实际上降低了模型的复杂性。所以如果能够让模型的复杂度由数据依赖自动地决定，应该可以大大改善性能。</p><p>同样值得注意的是，尽管DNNs已经得到了很好的发展，但仍有许多任务DNNs并不优越，有时甚至不足，比如，Random Forest、XGBoost 仍然在许多 Kaggle competition task 里获胜。</p><p>我们相信，为了处理复杂的学习任务，学习模型可能必须 go deep。然而当前的深度模型，总是基于神经网络。综上所述，有充分的理由来探索一个 non-NN(不基于神经网络) 的深度模型，in other words，考虑是否可以与其他模块一起实现深度学习，因为它们有自己的优势，如果能够深入，可能会显示出巨大的潜力。</p><p>特别是，不是所有的世界上的 properties 都是可微分的（或者建模为可微分的），这篇文章将解决这个基本问题：</p><p>“Can deep learning be realized with non-differentiable modules?”</p><p>这个问题的答案可以帮助我们理解很多重要问题，比如</p><ol><li>deep models ?=DNNs（或者，深层模型只能用可微模来构造？）</li><li>不使用反向传播可以训练深度模型吗？</li><li>可以让深度模型战胜其他模型吗比如 Random Forest、XGBoost</li></ol><p>实际上，机器学习社区以及开发了许多的机器学习模型，其中许多是不可微分的。理解<code>是否可以基于不可微分模型构建一个深度学习模型</code>将阐明这个问题（这些模块是否可以在深度学习中加以利用）</p><p>在这篇论文里，我们提出了一种 non-NN style deep model。</p><ul><li>这是一种新的决策树集成，具有级联结构，能够通过森林进行表示学习。</li><li>它的表征学习能力可以通过多粒度扫描进一步增强，从而使gcForest具有上下文或结构感知能力。</li><li>级联level 可以自动确定，这样模型的复杂性就可以通过依赖于数据的方式来确定，而不是在训练前手动设计；这使得gcForest即使在小规模数据上也能很好地工作，并且使用户能够根据可用的计算资源来控制训练成本。</li><li>比起DNNs有更少的超参数</li><li>它的性能对超参数设置有很强的鲁棒性，使用 default setting 可以在大部分情况得到很好的性能，尽管跨不同领域不同数据</li></ul><p>剩下的部分是这样：Section2 分析为什么深度学习很牛，解释设计灵感；Section3 提出方法；Section4 展示实验报告；Section5 提出一些相关工作；Section6 提出一些问题和未来方向；Section7 结束语。</p><h2 id="Inspiration"><a href="#Inspiration" class="headerlink" title="Inspiration"></a>Inspiration</h2><h3 id="灵感-from-DNNs"><a href="#灵感-from-DNNs" class="headerlink" title="灵感 from DNNs"></a>灵感 from DNNs</h3><p>众所周知，<code>表征学习</code>能力是深度学习成功的关键。那么什么是表征学习的关键呢？我们认为是 layer-by-layer processing. Fig1. 当抽象层从底层向上时，更高层次的特征就会显现出来。</p><p><img src="/2021/04/11/Deep-Forest/image-20210411155508192.png" alt="image-20210411155508192"></p><p>考虑到如果其他问题得到解决，更大的模型复杂性（或者更准确地说，模型容量）通常会导致更强大的学习能力，将DNNs的成功归因于巨大的模型复杂性听起来是合理的。</p><p>然而，无法解释为什么浅层网络不如深层网络成功，因为人们可以通过增加几乎无限多个隐藏单元来增加浅层网络的复杂性。</p><p>因此，我们认为仅仅只有模型复杂性无法解释 DNNs 的成功。相反，我们猜想层层处理才是DNNs背后最重要的因素。因为扁平的网络（比如，单一隐藏层的网络）不管多么复杂，也无法保留层层处理的特征（the characteristics of layer-by-layer processing）。尽管我们没有严格的理由，但是这一猜想对森林的设计具有重要的启示。</p><p>有人可能会质疑，有些学习模型，例如决策树和Boosting机器，也进行逐层处理，为什么它们没有DNNs那么成功？</p><p>我们认为最重要的区别是：与如图1所示生成新特征的DNNs不同，决策树和Boosting机器总是在原始特征表示上工作，而不在学习过程中创建新特征，或者换句话说，没有模型内特征转换（in-model feature transformation），而且，与具有任意高的模型复杂度的DNNs不同，决策树和Boosting机只能具有有限的模型复杂度。虽然模型的复杂性本身并不一定能解释DNNs的成功，但它仍然很重要，因为开发大的训练数据需要大的模型容量。</p><p>总的来说，我们推测DNNs的奥秘背后有三个关键特征，即逐层处理、模型特征转换和足够的模型复杂性。我们将尝试将这些特性赋予我们的非NN风格的深度模型。</p><h3 id="灵感-from-集成学习"><a href="#灵感-from-集成学习" class="headerlink" title="灵感 from 集成学习"></a>灵感 from 集成学习</h3><p>集成学习(ensemble learning)可以说是现在非常火爆的机器学习方法了。它本身不是一个单独的机器学习算法，而是通过构建并结合多个机器学习器来完成学习任务。也就是我们常说的“博采众长”。集成学习一般可以获得比单一学习者更好的泛化性能。</p><p>为了组合一个好的集成，各个 learners 应该准确、多样。仅仅结合准确的 learners 往往不如结合一些准确的学习者和一些相对较弱的 learners，因为互补性比纯粹的准确更重要。</p><h4 id="误差-分歧分解-Error-ambiguity-decomposition"><a href="#误差-分歧分解-Error-ambiguity-decomposition" class="headerlink" title="误差-分歧分解 Error-ambiguity decomposition"></a>误差-分歧分解 Error-ambiguity decomposition</h4><p><strong>误差-分歧分解</strong>指将集成后的泛化误差分解开的过程，可以用下式表示：</p><script type="math/tex; mode=display">{E= \overline {E}- \overline {A}}</script><p>该式中左边 E 表示集成后的泛化误差，右侧 E 是 个体学习器的平均泛化误差， A 表示个体学习器的集成分歧，从该式可以得出结论：个体学习器的准确性越高、多样性越大，集成效果越好。然而，这个公式并不能作为一个优化目标函数，因为分歧项是在推导中用数学方法定义的，不能直接操作。后来，集合社区设计了许多多样性度量，但没有一个被公认为是多样性的正确定义。</p><p>在实践中，多样性增强的基本策略是在训练过程中引入基于启发式的随机性。粗略地说，有四种机制：</p><ol><li>用不同的数据样本来训练各个 learners，比如Bagging[2]利用了bootstrap抽样[12]，而AdaBoost采用了序贯重要性抽样</li><li>第二种是输入特征操作，通过生成不同的特征子空间来训练各个 learners，比如随机子空间方法[24]为每个学习者随机挑选特征子集</li><li>使用不同参数设置的基础学习算法生成不同的 learners，比如不同的初始权重可用于单个神经网络[28]，而不同的分割选择可用于单个决策树[37]</li><li>使用不同的输出表征产生不同的 learners，比如ECOC方法[10]采用纠错输出码，而翻转输出方法[4]随机改变一些训练实例的标签</li></ol><p>不同的方法可以组合起来使用，但是这些方法也总是有效，比如数据样本操作对稳定的学习者不起作用，而稳定的学习者的表现不会因训练数据的轻微修改而发生显著变化。</p><p>gcForest，它可以被视为一种决策树集成方法，利用几乎所有种类的机制来增强多样性。</p><h2 id="The-gcForest-Approach"><a href="#The-gcForest-Approach" class="headerlink" title="The gcForest Approach"></a>The gcForest Approach</h2><p>这一段会先介绍<code>级联森林结构</code>，然后介绍多粒度扫描，然后对总体架构和超参数进行说明。</p><h3 id="Cascade-Forest-Structure"><a href="#Cascade-Forest-Structure" class="headerlink" title="Cascade Forest Structure"></a>Cascade Forest Structure</h3><p>深层神经网络中的表征学习主要依赖于原始特征的逐层处理。受这个影响，gcForest利用级联结构，如图2，每一个 level of cascade 接受上一层的处理过的 feature information，然后输出处理结果到下一层。</p><p><img src="/2021/04/11/Deep-Forest/image-20210411171510374.png" alt="image-20210411171510374"></p><p>Fig 2. 层叠森林结构示意图。假设级联的每一级由两个随机森林（黑色）和两个完全随机的树林（蓝色）组成。假设预测结果是三种 classes，因此，每个森林将输出一个三维分类向量，然后连接起来重新表示原始输入。</p><p>每个 level 都是决策树森林的集合。然而，我们包括不同类型的森林以鼓励多样性，因为多样性对于整体建设至关重要[63]。为简单起见，假设我们使用两个<strong>完全随机</strong>的森林和两个<strong>随机</strong>森林[5]。</p><p>每个完全随机树林包含500个完全随机树[37]，<code>通过在树的每个节点上随机选择一个特征进行拆分</code>，并将树生长到纯叶，即每个叶节点仅包含相同的 class。</p><p>同样的，每个随机森林包括500个树，通过随机选取 根号d 个特征作为候选特征（d是输入特征的个数），选择基尼值最佳的特征进行分割。每个森林中的树木个数是一个超参数，将在第3.3节中讨论。</p><p>给一个实例，每个森林都产生一个类分布的估计值，by 计算相关实例所在叶节点上不同类的训练实例的百分比，然后对同一林中的所有树进行平均。图三中，红色高亮显示实例遍历到叶节点的路径。</p><p><img src="/2021/04/11/Deep-Forest/image-20210425113457144.png" alt="image-20210425113457144"></p><p>图3，分类向量生成，叶节上不同的标记意味着不同的类。</p><p>使用 K-fold 交叉验证来减少 overfitting risk</p><p>每个实例都将作为训练数据使用 k-1 次，产生 k-1 个分类向量，然后对其进行平均以产生最终分类向量，作为下一级的增强特征。扩展一个新的层次后，可以在验证集上估计整个级联的性能，如果没有显著的性能增益，训练过程将终止；因此，级联的层次数目是自动确定的。注意，当训练成本较高或可用计算资源有限时，也可以使用训练误差而不是交叉验证误差来控制级联增长。与大多数模型复杂度固定的深层神经网络不同，gcForest通过在适当的时候终止训练来自适应地确定其模型复杂度。这使得它能够适用于不同规模的训练数据，而不限于大规模的训练数据。</p><h3 id="多粒度扫描"><a href="#多粒度扫描" class="headerlink" title="多粒度扫描"></a>多粒度扫描</h3><p>深层神经网络在处理特征关系方面很强大，卷积神经网络对原始像素之间的空间关系非常重要的图像数据非常有效；递归神经网络对顺序关系很重要的序列化数据很有效。受这些影响，我们提出多粒度扫描来增强级联森林。</p><p><img src="/2021/04/11/Deep-Forest/image-20210425161546986.png" alt="image-20210425161546986"></p><p>图4，feature re-representation。假设有三个分类，原始 feature 是一个400维的序列，采用100维的滑动窗口对输入特征进行处理。</p><p>对于序列数据，每滑动一个特征的窗口，将生成一个100维的特征向量，总共产生301个 feature vector。如果原始 feature 有特殊关系，比如它是一个 20*20 的pixel，那么会生成 10*10的 window，产生11*11=121个 feature vector</p><p>所有的从正/负训练样本中提取的 feature vector 被视为正/负 instances，将用来生成分类向量：instances 将用来 train 完全随机森林 和 随机森林，然后生成 class vector 然后连接为变换特征</p><p>在图4中， 假定有3个class、100维的 window，然后，每个森林会生成 301 个三维 class vector，得到一个1806维的变换特征向量，对应于原始的400维原始特征向量。</p><p>对于每个滑动窗口生成的 instance，我们简单的用原始训练数据的标记来标记它。在这里，一些标签分配本身就是不正确的。比如，假设原始的 training example 是一个 positive image about “car”，显然从 car 提取的 instance 没有包含一个 car，因此，它们被标记为 positive 是不正确的。这实际上与 Flipping Output method[4]有关，集合分集增强的一种典型输出表示方法?</p><p>图4只显示了一种尺寸的滑动窗口。通过使用多种大小的滑动窗口，将生成不同粒度的特征向量，如图5所示。</p><p><img src="/2021/04/11/Deep-Forest/image-20210425170826060.png" alt="image-20210425170826060"></p><p>Fig.5 gcForest的整个过程。假设有三个类要预测，原始特征是400维，使用三种尺寸的滑动窗口。</p><p>第一步：使用多粒度扫描对输入特征进行预处理。以使用三个尺寸的滑动窗为例，分别为100-dim，200-dim和300-dim。输入数据为400-dim的序列特征，使用100-dim滑动窗会得到301个100-dim向量，然后输入到一个completely-random tree forest和一个random forest中，两个森林会分别得到的301个3-dim向量（3分类），将两个森林得到的特征向量进行拼接，会得到1806-dim的特征向量。同理，使用200-dim和300-dim滑动窗会分别得到1206-dim和606-dim特征向量。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Deep-Forest&quot;&gt;&lt;a href=&quot;#Deep-Forest&quot; class=&quot;headerlink&quot; title=&quot;Deep Forest&quot;&gt;&lt;/a&gt;Deep Forest&lt;/h1&gt;&lt;h2 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>药物-靶点相互作用网络重建的细节</title>
    <link href="https://panlianghnu.github.io/2021/04/10/%E8%8D%AF%E7%89%A9-%E9%9D%B6%E7%82%B9%E7%9B%B8%E4%BA%92%E4%BD%9C%E7%94%A8%E7%BD%91%E7%BB%9C%E9%87%8D%E5%BB%BA%E7%9A%84%E7%BB%86%E8%8A%82/"/>
    <id>https://panlianghnu.github.io/2021/04/10/%E8%8D%AF%E7%89%A9-%E9%9D%B6%E7%82%B9%E7%9B%B8%E4%BA%92%E4%BD%9C%E7%94%A8%E7%BD%91%E7%BB%9C%E9%87%8D%E5%BB%BA%E7%9A%84%E7%BB%86%E8%8A%82/</id>
    <published>2021-04-10T03:32:35.000Z</published>
    <updated>2021-04-10T09:15:17.220Z</updated>
    
    <content type="html"><![CDATA[<p>我们从6个常用数据源收集了FDA批准的药物的高质量物理药物-靶向相互作用，并使用已报道的结合亲和性数据定义了物理药物-靶向相互作用：抑制常数/效价(Ki)，离解常数(Kd)，中位有效浓度(EC50)，中位抑制浓度(IC50) &lt;= 10 uM.</p><p>从DrugBank数据库获取药物与靶点的相互作用.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们从6个常用数据源收集了FDA批准的药物的高质量物理药物-靶向相互作用，并使用已报道的结合亲和性数据定义了物理药物-靶向相互作用：抑制常数/效价(Ki)，离解常数(Kd)，中位有效浓度(EC50)，中位抑制浓度(IC50) &amp;lt;= 10 uM.&lt;/p&gt;
&lt;p&gt;从Dru</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>异构网络表示学习综述</title>
    <link href="https://panlianghnu.github.io/2021/04/06/%E5%BC%82%E6%9E%84%E7%BD%91%E7%BB%9C%E8%A1%A8%E7%A4%BA%E5%AD%A6%E4%B9%A0%E7%BB%BC%E8%BF%B0/"/>
    <id>https://panlianghnu.github.io/2021/04/06/%E5%BC%82%E6%9E%84%E7%BD%91%E7%BB%9C%E8%A1%A8%E7%A4%BA%E5%AD%A6%E4%B9%A0%E7%BB%BC%E8%BF%B0/</id>
    <published>2021-04-06T02:40:23.000Z</published>
    <updated>2021-04-13T05:48:08.056Z</updated>
    
    <content type="html"><![CDATA[<h1 id="异构网络表示学习"><a href="#异构网络表示学习" class="headerlink" title="异构网络表示学习"></a>异构网络表示学习</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="表征学习为何重要："><a href="#表征学习为何重要：" class="headerlink" title="表征学习为何重要："></a>表征学习为何重要：</h3><p>210用6除是非常直截了当的，但是如果用罗马字符 CCX，会一下想到用 VI 除吗，可以看到阿拉伯数字相比于罗马数字更加的让人容易处理除法。</p><p>机器学习算法的成功与否不仅仅取决于算法本身，也取决于数据的表示。数据的不同表示可能会导致有效信息的隐藏或是曝露，这也决定了算法是不是能直截了当地解决问题。表征学习的目的是对复杂的原始数据化繁为简，把原始数据的无效信息剔除，把有效信息更有效地进行提炼，形成特征，这也应和了机器学习的一大任务——可解释性。 也正是因为特征的有效提取，使得今后的机器学习任务简单并且精确许多。在我们接触机器学习、深度学习之初，我们就知道有一类任务也是提炼数据的，那就是特征工程。与表征学习不同的是，特征工程是人为地处理数据，也是我们常听的“洗数据”。 而表示学习是借助算法让机器自动地学习有用的数据和其特征。 不过这两个思路都在尝试解决机器学习的一个主要问题——如何更合理高效地将特征表示出来。</p><h3 id="什么因素决定了一种表示比另一种表示好呢："><a href="#什么因素决定了一种表示比另一种表示好呢：" class="headerlink" title="什么因素决定了一种表示比另一种表示好呢："></a>什么因素决定了一种表示比另一种表示好呢：</h3><ol><li><p>提供Disentangling of Causal Factors的线索</p><blockquote><p>One hypothesis is that an ideal representation is one in which the features within the representation correspond to the under- lying causes of the observed data, with separate features or directions in feature space corresponding to different causes, so that the representation disentangles the causes from one another. This hypothesis motivates approaches in which we first seek a good representation for p(x). Such a representation may also be a good representation for computing p(y | x) if y is among the most salient causes of x. </p></blockquote><p>一个假设：理想表示法是这样一种表示法，即表示法中的特征对应于观测数据的潜在原因，而特征空间中的独立特征或方向对应于不同的原因，这样表示法就可以将原因相互分离开来。</p><p>这一假设激发了我们首先寻找p（x）的良好表示的方法。如果y是x的最显著原因之一，那么这种表示也可以是计算p（y | x）的良好表示。</p><p><img src="/2021/04/06/%E5%BC%82%E6%9E%84%E7%BD%91%E7%BB%9C%E8%A1%A8%E7%A4%BA%E5%AD%A6%E4%B9%A0%E7%BB%BC%E8%BF%B0/image-20210408153000630.png" alt="image-20210408153000630"></p><p>这是一个混合高斯分布，学习到好的p(x)，对y的预估会变得更容易，但如果p(x)是一个均匀分布，则对y的预估就一点用的没有。</p></li><li><p>distribution representation的优势，分布表征</p><p><img src="/2021/04/06/%E5%BC%82%E6%9E%84%E7%BD%91%E7%BB%9C%E8%A1%A8%E7%A4%BA%E5%AD%A6%E4%B9%A0%E7%BB%BC%E8%BF%B0/v2-d3234b9cb508901a365d1c35c7ea64ea_720w.jpg" alt="img"></p><p><img src="/2021/04/06/%E5%BC%82%E6%9E%84%E7%BD%91%E7%BB%9C%E8%A1%A8%E7%A4%BA%E5%AD%A6%E4%B9%A0%E7%BB%BC%E8%BF%B0/v2-adc59d82ab5231a8702c0d6e0eb7e4cd_720w-20210408153111068.jpg" alt="img"></p><p>对于上面两个图，分别表示distribution representation和one hot representation对空间的分割，明显可以看到，distribution的版本，可以用更少的线分割出更多的区域，即在统计上更有效（statistics effective）</p></li><li><p>Deep带来的Exponential级别的增益</p><p>我们有了解过神经网络的universal approximators理论，Deep的模型比shallow的模型能用更少的weight，描述更复杂的function，在representation里面，也适用。</p><blockquote><p>事实证明，在许多不同的情况下，通过许多非线性的组合和重用特征的层次结构来组织计算，可以在使用分布式表示的指数提升的基础上，给统计效率带来指数提升。</p></blockquote></li></ol><h3 id="why-and-when-pretrain-work"><a href="#why-and-when-pretrain-work" class="headerlink" title="why and when pretrain work:"></a>why and when pretrain work:</h3><blockquote><p>无监督的预训练结合了两种不同的想法。首先，它利用了这样一种思想，即深度神经网络初始参数的选择可以对模型产生显著的正则化效果（并且在较小程度上可以改善优化）。其次，它利用了一个更一般的思想，即了解输入分布有助于了解从输入到输出的映射。</p></blockquote><p>目前更多的信息表明，deep模型，local mini不是严重的问题，而pretrain可能能帮助我们找到更好的路径绕开变态Hessian matrix的区域。</p><blockquote><p>其基本思想是，一些对无监督学习任务有用的特征也可能对有监督学习任务有用。例如，如果我们训练汽车和摩托车图像的生成模型，它需要知道车轮，以及图像中应该有多少个车轮。所以当unsupervised学习到的表达对supervised的帮助不大时，即共同性没有那么强时，效果就不理想了。</p></blockquote><p>另外由于pretrain把模型训练分为了两个stage，不是end2end，无论是调参反馈还是参数量上，都更慢或更多，随着supervised能用的样本越来越多，pretrain开始退出历史舞台。</p><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>异构网络表示学习的目标，就是将输入异构<code>网络中的顶点嵌入到一个潜在的嵌入空间</code>中，使得网络的结构和关系属性都能被编码和保持。嵌入生成的向量就可以作为机器学习的 features</p><p>表达性嵌入学习，目前主要分为两类：</p><ul><li>浅层嵌入学习</li><li>图神经网络</li></ul><p>文章确定了几个最尚未解决的挑战，建立了异构网络图的 benchmark</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>​    现实世界的复杂系统通常是多个对象多个关系构成的。比如 science enterprise，它利用五种对象（论文、作者、研究所、地点、领域），其他在社会学、生物学、经济学等各个领域都能看到。通常，这些复杂系统能够被有效地抽象为<strong>异构网络</strong>（不同类型的顶点在唯一关系下连接【Sun and Han,2012】）</p><p>​    异构网络的定义：有向图 G = (V,E)，每个顶点 v 属于 V，每个边 e 属于 E，顶点和边通过 type mapping function 联系起来</p><script type="math/tex; mode=display">τ(v): V \rightarrow T_V \space\space and \space\space φ(e):E \rightarrow T_E</script><p>Tv 和 Te 分别代表顶点和边的各个类型</p><script type="math/tex; mode=display">| \space T_V \space | + | \space T_E \space | > 2</script><p> 如果两个边有相同的关系，有相同的顶点类型 (source v -&gt; target v) ，如果 |TV |=1 and |TE|=1,这是一个具有相同类型顶点和边的异构网络，其实就是普通的有向图</p><p>对异构网络分析的过程，一般由提取类型化结构化的 features 开始，它们被进一步输入到下游图形任务的机器学习模型中，通常这会涉及到以下几个概念：</p><blockquote><p>Meta Relation（元关系）：异构网络中的每个边和它的元关系相关联</p><script type="math/tex; mode=display">For \space an \space edge \space e = (s,t) \space ,its \space meta \space relation \space is \space denoted \space as \space ⟨τ (s), φ(e), τ (t)⟩.</script><p>Network Schema（网络架构）：给定一个异构网络G，它的网络架构定义为</p><script type="math/tex; mode=display">T_G = (T_V,T_E)</script><p>网络架构包含G中所有的元关系，G的顶点类型 Tv，G的边类型Te</p><p>Meta Path（元路径）：一个G中元关系组成的序列，比如一个OAG中一个说明性的元路径是这样的：”author-paper-venue-paper-author”表示在同一地点发布的两个作者的语义</p></blockquote><p>比如，Figure 1 说明了OAG的网络架构和元路径：</p><p><img src="/2021/04/06/%E5%BC%82%E6%9E%84%E7%BD%91%E7%BB%9C%E8%A1%A8%E7%A4%BA%E5%AD%A6%E4%B9%A0%E7%BB%BC%E8%BF%B0/image-20210406154241665.png" alt="image-20210406154241665"></p><p>基于这些概念和工具，各种异构网络挖掘方法被提出并应用于各种与图形相关的应用，如顶点分类、在线推荐、链接预测、社区检测、异常检测等。</p><p>近年来，异构网络挖掘的研究范式逐渐转向基于表征学习的技术。</p><p>网络表征学习的目标是<code>自动化的学习潜在的低纬度网络对象的嵌入表示</code></p><p>应用前提是输入网络固有的结构和语义特性可以被编码到潜在的嵌入向量中，从而有利于异构网络上的应用和任务。比如，user 和 items 的网络嵌入向量可以作为在线推荐系统的特征输入。</p><h2 id="异构网络挖掘"><a href="#异构网络挖掘" class="headerlink" title="异构网络挖掘"></a>异构网络挖掘</h2><h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><p>异构网络的形式化可以追溯到对异构信息网络的研究，其中作者提出利用不同类型顶点之间的链接来生成簇。更重要的是，作者认为“多类型对象之间的相互作用在揭示网络所承载的丰富语义方面起着关键作用”。</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>除聚类外，图的非均匀性在其他图挖掘任务中的重要性也得到了证明，包括顶点分类、排序、相似搜索、链路预测、异常检测等。</p><h3 id="传统的挖掘模式"><a href="#传统的挖掘模式" class="headerlink" title="传统的挖掘模式"></a>传统的挖掘模式</h3><p>挖掘异构网络的传统工作流程是首先在网络模式上定义元路径或其变体，如元图或元结构，然后将其作为特征来开发机器学习模型</p><p>以学术网络中的链接预测任务为例，我们可以定义“作者-论文-作者”元]路径来提取异构结构特征，并利用这些特征来推断每对作者之间是否存在协作关系</p><h3 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h3><p>异构网络挖掘的主要挑战在于元路径的设计。通常，为了解决输入网络的特定图形问题，我们必须人工定制特定于任务和数据的元路径，这需要相关的领域知识和经验。</p><p>此外，元路径的传统用法仅限于离散空间。如果图中的两个顶点没有结构上的连接，基于元路径的技术就无法捕捉它们之间的关系。例如，假设一位学者发表的论文都是 NeurIPS，而另一位学者的所有论文都发在 ICML，根据”author-paper-venue-paper-author”元路径，这两个学者之间的相关性是0，然而 NeurIPS 和 ICML 有很强的相关性。</p><p>这种由离散结构引起的挑战可以通过在连续空间中使用潜在的表示来自然地解决。</p><h2 id="异构网络表征"><a href="#异构网络表征" class="headerlink" title="异构网络表征"></a>异构网络表征</h2><p>近年来，利用<strong>神经网络</strong>学习物体潜在嵌入的神经表征学习在计算机视觉、自然语言处理和语音识别等领域取得了革命性的成果。受此启发，有人尝试将表征学习应用到网络中。网络表示学习的前提是不需要手工构造结构特征，而是能够将网络结构自动嵌入到潜在空间中，然后用于现有的网络挖掘任务。</p><p>神经网络表示学习的主要障碍是非欧几里德图结构到欧几里德嵌入空间的转换，因为图数据和神经网络之间存在差距。最近，弥补这一差距的主要进展是借鉴图论的思想。例如，一个方向的尝试是利用<code>random walks</code>将图结构转换为序列，这可以被基于序列的嵌入学习算法（比如DeepWalk 和 node2vec模型）来调用。</p><p>异质网络的表征学习技术大多是在同质网络表征学习的基础上发展起来的。核心问题是如何将不同类型的顶点和边之间的结构转换为潜在空间，从而编码和保持异构网络的结构和语义特性。</p><h3 id="异构网络嵌入"><a href="#异构网络嵌入" class="headerlink" title="异构网络嵌入"></a>异构网络嵌入</h3><p>我们回顾了基于浅层学习的异构网络嵌入方法。</p><p>“浅层”方法的特点是嵌入查找表，即它们直接将每个顶点编码为一个向量，而这个嵌入表是要优化的参数。沿着这条线，方法可以根据它们所建立的假设进行分类。</p><ol><li><p>基于分布假设的方法</p><p>Skip-gram 是一种浅层嵌入学习算法，最初是为了捕捉自然语言中单词的语义相似性而提出的。它基于分布假设，该假设指出<code>出现在同一上下文中的词往往具有相似的含义</code></p><p>随后，该假设被扩展到网络：<code>共享相同结构上下文的顶点在嵌入空间中趋于接近</code>为了解决这一问题，人们提出了几种基于skip-gram的同质网络嵌入方法，如DeepWalk和node2vec以及NetMF</p><p>PTE：为了对异质网络中的分布假设进行建模，PTE模型首先将输入的异质网络投影到几个同质/二部网络中，假定：<code>具有相似邻域的顶点彼此相似，因此应该在低维空间中紧密地表示</code>在这种假设下，PTE在每个网络上应用skip-gram框架，并联合优化所有嵌入表</p><p>metapath2vec：为了更好地捕捉图的异质性，提出了 metapath2vec 模型：它的主要思想是扩大随机游走策略，这些策略最初用于收集节点上下文，以模拟同质网络中的分布假设。具体地说，它引入了基于元路径的随机游走策略，其中游走者被限制在特定类型的顶点之间的转换。与PTE相比，该策略能更好地统一描述不同类型顶点之间的结构依赖关系。对于嵌入学习，metapath2vec直接利用带负采样的skip-gram学习异构网络中所有类型顶点的嵌入。此外，它的增强版进一步提出了基于类型的skip-gram负采样，有效地建模了异构网络中的结构依赖和语义依赖</p><p>后来，各种解决方案利用元路径来构建异构上下文，以便为不同的下游任务学习表示。例如，与word2vec的phrase2vec扩展类似，HIN2vec<code>直接将元路径作为对象/上下文</code>来学习顶点和元路径的嵌入。GATNE将该框架扩展到多个异构网络，TapEm进一步将顶点对嵌入和元路径嵌入结合起来。HeteSpaceyWalk通过在元路径、图和模式的指导下提出异构个性化spacey随机行走算法，进一步推进了基于元路径的随机行走。更重要的是，这种随机游走策略与顶点之间的收敛平稳分布有关</p></li><li><p>其他方法</p><p>除了基于skip-gram的方法外，其他异构网络嵌入技术还包括基于标签传播、因子分解和生成对抗网络的方法。此外，大多数这些技术都是特定于任务的，需要监督信息。</p><p>LSHM：2014年，最初尝试异构网络表征学习的方法是基于标签传播的LSHM模型，LSHM借用了同构网络中标签传播的平滑性假设——<code>两个连接的节点往往具有相同的标签</code>，用于异构网络。它的思想是通过使用顶点类型特定的分类来强制（不同类型的）顶点具有相似的表示。该方法是在标签传播框架下进行顶点分类的。在此基础上，针对异构链路预测问题，提出了一种类似的任务和结构损失联合优化方法。它的 structure loss 是基于在异构网络中<code>为特定任务手工设计的元路径</code>来构造的。总之，这些方法是（半）监督的，作者认为不同类型之间的结构依赖和标签依赖可以建模。</p><p>HERec：与PTE类似，HERec模型还根据定制的元路径将输入异构网络投影到多个维度。然后在每个投影中使用metapath2vec框架学习顶点嵌入，所有顶点嵌入都通过基于因子分解的融合模型与来自推荐任务的监督信息进行融合。不同的是，HueRec方法认为不同元路径之间存在相互关系，因此它将它们统一为异构网络中推荐任务的端到端框架。</p><p>大多数基于skip-gram的嵌入方法都与负采样相结合，以实现可伸缩的快速学习。更广泛地说，该技术属于噪声对比估计（NCE）领域，APE模型在此基础上有效地学习了不同顶点类型与“上下文相关”噪声分布之间的交互概率，而无需考虑大数据空间。此外，最近的一项研究提出了基于生成性对抗网络（GAN）的框架HeGAN来实现这一点。HeGAN的目标不是直接采样，而是生成潜在的顶点分布，从而生成具有异质结构的更好的负样本。</p></li><li><p>总结</p><p>在浅嵌入的背景下，对于异构网络有无监督和有监督两种学习框架。大多数无监督方法都是建立在分布假设应用于异构网络的基础上，如基于 skip-gram 的模型。对于（半）监督框架，学习目标通常是异构结构建模和特定任务优化的组合。</p><p>然而，在这两种学习环境下，大多数方法都依赖于人工探索异构结构，即选择元路径或变体来获取结构和语义依赖。</p></li></ol><h3 id="异构图神经网络"><a href="#异构图神经网络" class="headerlink" title="异构图神经网络"></a>异构图神经网络</h3><p>最近几年，图神经网络（GNN）在构造和关系数据建模方面显示出了有希望的结果。和基于浅层学习的异构网络嵌入方法不一样，GNN通常由更复杂的编码器授权，通常是一个深层的神经网络，支持结构和顶点属性的自然建模。这一部分，会总结最近的GNNs对网络表征学习的进展。</p><p>我们首先介绍了关系数据的通用GNN框架。一种方法是将其视为神经信息传递框架，其中输入图的结构用作传播（顶点或边）信息的主干，以形成表达性表示。或者，我们可以将其视为特征聚合过程，其中对于每个顶点，其邻域被视为接收场，从中递归地聚合信息。</p><p>在形式上，这个聚合过程可以抽象成公式：</p><script type="math/tex; mode=display">H^{(l+1)} = \sigma (\widehat{A}    H^{(l)} W^{(l)})</script><ul><li><p>H(l) W(l) 是第l层的（隐藏）节点表示和参数矩阵</p></li><li><p>A^ 表示从某种形式的图结构导出的滤波器，比如，在GCN中，它是对称的归一化邻接矩阵</p></li><li><p>σ 通常是一个非线形的 function</p></li></ul><p>在这个框架下，有人提出了一系列的研究来更好地学习网络表示。接下来，我们总结异构图神经网络的最新发展</p><ol><li><p>Relational GCN. 关系图卷积网络</p><p>使用GNN对多关系图建模的最早尝试之一是关系图卷积网络（RGCN）</p><p>它为每种边类型保留不同的线性投影权重，为了处理具有大量关系的图，RGCN还将特定关系的参数分解为若干基矩阵的线性组合。</p><p>另一个值得注意的工作是 Decagon model，它在以蛋白质、药物、多药副作用为顶点的多模态图中，对每种类型的关系应用特定的图卷积滤波器。请注意，Decagon model 中特定于关系的参数对于不同的顶点是共享的。</p></li><li><p>Heterogeneous GNNs.异构神经网络</p><p>为了处理异构图结构和节点属性，异构图神经网络（HetGNN）使用类型特定的RNN对每种类型的相邻顶点的特征进行编码，然后使用另一个RNN来聚合不同类型的编码的相邻表示。</p></li><li><p>Heterogeneous Graph Attention.异构图注意</p><p>为了将 Attention 融入到异构GNN设计中，GEM方法对每个关系使用不同的聚合器，并学习用于建模不同类型顶点重要性的注意系数。</p><p>后来，异质图注意网络（HAN）[Wang et al.，2019a]使用元路径作为边来评价图，并为每个元路径定义的边保持不同的权重矩阵。它还利用高级语义注意来区分和聚合来自不同元路径的信息。</p></li><li><p>Heterogeneous Graph Transformer.异构图转换器</p><p>所有以前的工作都是单独使用节点顶点或边类型来确定GNN权重矩阵，然而，对于那些不明显的关系，很难学习精确的关系特定权重。Heterogeneous Graph Transformer 使用每条边的Meta Relation（元关系）来参数化这个 Transformer-like self-attention 架构，以便通过使用更少的参数来捕获不同关系的共同模式和特定模式。</p><p>此外，与大多数现有的需要手工设计元路径的工作不同，HGT可以通过多层GNN的特性<code>自动学习隐式元路径的重要性</code>，以融入高阶异构邻居信息。</p><p>它还学习了边类型和复合关系的软选择，以生成有用的多跳元路径来扩充输入图形。然后，对增广图采用 vanilla GCN层，得到上下文化的顶点嵌入。</p></li><li><p>Summary.</p><p>图神经网络的性质保证了上述所有方法都能得到任何不可见顶点或图的归纳嵌入，而不是像浅嵌入方法那样为图中的每个顶点保持一个大的查找表。此外，它们还可以通过神经网络编码器自然地利用丰富的顶点属性。</p><p>为了适应异构环境，所有现有模型对每种关系类型采用不同的权重矩阵。他们中的大多数利用人类设计的元路径来扩充图，而最近的一些工作利用自我注意机制来自动学习“软”元路径。</p></li></ol><h3 id="知识图-amp-属性网络"><a href="#知识图-amp-属性网络" class="headerlink" title="知识图 &amp; 属性网络"></a>知识图 &amp; 属性网络</h3><p>异构网络与 知识图&amp;属性网络 非常接近，在这个简短的 survey 里，我们没有深入挖掘他们之间的差异和联系</p><p>一般来说，知识图嵌入是一种完成知识图三元组的技术。其主要解决方案可分为两类：</p><ul><li>神经嵌入</li><li>tensor factorization</li></ul><p>属性网络嵌入与图神经网络具有相似的输入</p><p>值得注意的是，提出了ANE和DANE模型来模拟网络结构和属性之间的内在关联，并将其扩展到动态环境。最近，Cen等人将属性化的多重异构网络的表示学习问题形式化。为了解决属性化、多重性和异质性的挑战，他们提出了GATNE框架，并从理论上证明了它的表达优势</p><h3 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h3><p>由于异构网络能够对现实世界中的复杂系统进行抽象和建模，因此异构网络的表示学习在相似性搜索、知识图推理、问答和推荐等方面有着广泛的应用。例如，metapath2vec方法已经部署在 Microsoft Academic 中用于相似性搜索。另一个得益于异构网络嵌入的行业系统是电子商务中的在线推荐模块</p><h2 id="挑战、方向、Open-Data"><a href="#挑战、方向、Open-Data" class="headerlink" title="挑战、方向、Open Data"></a>挑战、方向、Open Data</h2><p>在其发展过程中，表征学习为挖掘（异构）网络提供了一种范式转换。特别明显的是，图神经网络能够显著地重构异构网络表示学习，从而有利于异构网络数据的所有可能应用。因此，我们将重点讨论基于GNN的技术，讨论仍然存在的挑战和未来的发展方向。</p><h3 id="Future-Directions"><a href="#Future-Directions" class="headerlink" title="Future Directions"></a>Future Directions</h3><ol><li><p>避免元路径设计</p><p>表征学习的大前提是，避免涉及手动工作和领域专业知识的特征工程。</p><p>如上所述，大多数异构表示学习方法都需要手动定制元路径或其变体（例如，元图），以便模型捕获给定异构结构下的语义。</p><p>例如，metapath2ve、HetGNN和HAN必须将预定义的元路径作为输入来处理指定的任务。基本上，它们的表示能力仅限于特定数据上的特定任务。</p><p>避免元路径设计的一个很有希望的尝试是最近的HGT模型[Hu et al.，2020b]，在该模型中，通过GNNs跨多个层的特征传播自然解决了该问题。因此，为了充分发挥表示学习的威力，有必要在不进行元路径预设计的情况下自动学习异构网络表示，即避免对网络结构和语义进行预探索</p></li><li><p>多感官表征</p><p>迄今为止，大多数嵌入都是从复杂的、多类型的异构网络中学习的。以分布假设为例，结构语境之间没有区别。具体来说，如果我们以学者“贾维汉”为例，我们可以为他说出几个不同的意义。在科学协作意识下，与他最为相似的学者是他的博士生“简培”和“阎锡峰”。或者，在场地出版物的意义上，“菲利普·S·余”和“克里斯托斯·法鲁索斯”与他最为相似。或者，在数据挖掘的科学影响下，他更像数据库中的“Rakesh Agrawal”和IR中的“Bruce Croft”。从这个例子中，我们可以清楚地看到异质网络中存在着多意义表示。如何定义、学习和使用它们在很大程度上仍然是开放和未探索的。</p></li><li><p>（异构）GNNs的预训练</p><p>如前一节所述，现有的（异构的）GNN是在（半）监督的环境中进行端到端训练的。换句话说，我们需要每个数据集上每个任务的专用标签数据。这在现实世界中通常是很昂贵的，特别是对于Web规模的异构图。为了解决标签稀缺的问题，已经采用了预先训练的神经模型，并显著促进了各种人工智能的发展，例如自然语言处理领域的BERT[Devlin et al.，2019]。</p><p>预训练模型的好处包括</p><ul><li>大多数情况下，它是以无监督（或自我监督）的方式训练的，不需要特定于任务和数据的标签信息；</li><li>它可以用于对不同的下游任务进行微调，甚至可以推广到各种数据。</li></ul><p>在这里，我们设想了两种类型的（异质）GNN预训练方向，以供将来的研究</p><p>首先，0</p><p>然后，我们在一组网络（不同类型）上预先训练GNN模型，目的是捕捉这些网络的内在结构特性，从而促进不同（看不见的）网络上的下游任务。</p><p>当然，异构GNNs的预训练也面临着图形异构性的挑战，使得它不同于现有的同质文本/图像/语音数据预训练技术，并且比现有的预训练技术更具挑战性。</p></li><li><p>多任务学习</p><p>近年来，多任务学习使得深度学习方法在自然语言处理（NLP）和自然语言处理（CV）中的学习表征方面优于传统的单任务学习方法。它的思想是并行处理多个任务，以识别和利用这些任务之间的相似性/差异。研究表明，与特定任务模型相比，这样做可以提高整体绩效[Ruder，2017；Wu等人，2020]。请注意，给定一个由多种类型的顶点和边组成的异构网络，它通常与各种挖掘任务相关联。例如，在一个异构的学术网络上有许多实际应用，如名称消歧、论文主题或作者研究兴趣的推断、文献和引文推荐、相似性搜索等。所有这些异质网络任务都可以从多任务学习中受益。</p><p>在多任务学习中，任务间的共享表示被学习，任务特定的参数可以对其他任务做出贡献。异构网络的独特特性是包含多种类型的顶点和边，这可能是多任务学习的自然应用。</p></li><li><p>动态性和可拓展性</p><p>在现实世界中，大多数网络都是随着时间的推移而演化的，其建模一直是一个研究难题。当网络中存在不同类型的顶点和边时，网络动态问题就变得特别具有挑战性。现有的方法大多是基于时间戳将输入动态网络分解为多层网络来处理。因此，跨不同层的结构和时间依赖通常被忽略。为此，如何有效地对动态异构网络进行建模仍是一个有待解决的问题，更不用说表示学习了。</p><p>另一个常见的挑战在于真实世界图形的大规模。OAG由数十亿个顶点和边组成，跨越1800到2020年。其他网络规模的图表可以更大。对于大多数现有的异构网络表示学习技术来说，在Web规模的图上学习是非常昂贵的。因此，可扩展和计算的可行模型是未来工作的关键方向。</p></li><li><p>其他</p><p>通用GNN模型也面临着一些挑战，例如许多GNN层堆叠时的 over-smoothing 和 over-fitting 问题</p></li></ol><h3 id="Open-Data-and-Benchmark"><a href="#Open-Data-and-Benchmark" class="headerlink" title="Open Data and Benchmark"></a>Open Data and Benchmark</h3><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>在这项工作中，我们介绍了异构网络表示学习的问题，并讨论了其潜在的挑战。我们回顾了最近在应对这些挑战方面取得的进展。更重要的是，我们深入探讨问题，揭示未来应该解决的关键问题和痛点。为了促进这一快速发展的课题的开放性和可复制性研究，我们首先为研究社区发布 异构图的 Benchmark。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;异构网络表示学习&quot;&gt;&lt;a href=&quot;#异构网络表示学习&quot; class=&quot;headerlink&quot; title=&quot;异构网络表示学习&quot;&gt;&lt;/a&gt;异构网络表示学习&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>python实现发送短信验证码</title>
    <link href="https://panlianghnu.github.io/2021/04/01/python%E5%AE%9E%E7%8E%B0%E5%8F%91%E9%80%81%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81/"/>
    <id>https://panlianghnu.github.io/2021/04/01/python%E5%AE%9E%E7%8E%B0%E5%8F%91%E9%80%81%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81/</id>
    <published>2021-04-01T07:50:25.000Z</published>
    <updated>2021-04-01T09:46:32.460Z</updated>
    
    <content type="html"><![CDATA[<p>调用 smtplib、MIMEText、formataddr库函数</p><p>发邮件、邮件格式、标准地址</p><p>代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"><span class="keyword">from</span> email.utils <span class="keyword">import</span> formataddr</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> md5</span><br><span class="line"></span><br><span class="line">my_sender = <span class="string">&#x27;2261834866@qq.com&#x27;</span>  <span class="comment"># 发件人邮箱账号</span></span><br><span class="line">my_pass = <span class="string">&#x27;xxxxxxxxxxxxxxxxxxx&#x27;</span>  <span class="comment"># 发件人邮箱密码, 可能是授权码</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回True则发送成功，返回False则发送失败</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_mail</span>(<span class="params">receiver=<span class="string">&#x27;&#x27;</span></span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        code = generate_code(receiver)</span><br><span class="line">        msg = MIMEText(<span class="string">&#x27;您的验证码为：&#x27;</span> + code, <span class="string">&#x27;plain&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        msg[<span class="string">&#x27;From&#x27;</span>] = formataddr([<span class="string">&quot;From AIdrug&quot;</span>, my_sender])  <span class="comment"># 括号里的对应发件人邮箱昵称、发件人邮箱账号</span></span><br><span class="line">        msg[<span class="string">&#x27;To&#x27;</span>] = formataddr([<span class="string">&quot;nick_name&quot;</span>, receiver])  <span class="comment"># 括号里的对应收件人邮箱昵称、收件人邮箱账号</span></span><br><span class="line">        msg[<span class="string">&#x27;Subject&#x27;</span>] = <span class="string">&quot;感谢使用AIdrug&quot;</span>  <span class="comment"># 邮件的主题，也可以说是标题</span></span><br><span class="line"></span><br><span class="line">        server = smtplib.SMTP_SSL(<span class="string">&quot;smtp.qq.com&quot;</span>, <span class="number">465</span>)  <span class="comment"># 发件人邮箱中的SMTP服务器，端口是25</span></span><br><span class="line">        server.login(my_sender, my_pass)  <span class="comment"># 括号中对应的是发件人邮箱账号、邮箱密码</span></span><br><span class="line">        server.sendmail(my_sender, [receiver, ], msg.as_string())  <span class="comment"># 括号中对应的是发件人邮箱账号、收件人邮箱账号、发送邮件</span></span><br><span class="line">        server.quit()  <span class="comment"># 关闭连接</span></span><br><span class="line">    <span class="keyword">except</span> Exception:  <span class="comment"># 如果 try 中的语句没有执行，则会执行下面的 ret=False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_code</span>(<span class="params">email: <span class="built_in">str</span> = <span class="string">&quot;&quot;</span></span>):</span></span><br><span class="line">    code = md5(email.encode())</span><br><span class="line">    <span class="keyword">return</span> code.hexdigest()[<span class="number">0</span>:<span class="number">4</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里我采用了 md5 来生成验证码，这样算是比较简单的一种加密方式吧，但是这样有个问题就是用户操作时每次验证码都会相同，但是我们这里只有注册时用到验证码，就无所谓吧。后期可以改成每5分钟换一下加密方式（或者在email后混一个字符串再进行MD5）来解决这个问题。</p><p><img src="/2021/04/01/python%E5%AE%9E%E7%8E%B0%E5%8F%91%E9%80%81%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81/image-20210401155754905.png" alt="image-20210401155754905"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;调用 smtplib、MIMEText、formataddr库函数&lt;/p&gt;
&lt;p&gt;发邮件、邮件格式、标准地址&lt;/p&gt;
&lt;p&gt;代码如下&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Flask操作数据库</title>
    <link href="https://panlianghnu.github.io/2021/03/31/Flask%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>https://panlianghnu.github.io/2021/03/31/Flask%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93/</id>
    <published>2021-03-31T07:49:40.000Z</published>
    <updated>2021-03-31T08:20:24.625Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install flask-sqlalchemy</span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><div class="table-container"><table><thead><tr><th>配置选项</th><th>说明</th></tr></thead><tbody><tr><td><code>SQLALCHEMY_DATABASE_URI</code></td><td>连接数据库。示例：<code>mysql://username:password@host/post/db?charset=utf-8</code></td></tr><tr><td><code>SQLALCHEMY_BINDS</code></td><td>一个将会绑定多种数据库的字典。 更多详细信息请看官文 <a href="https://links.jianshu.com/go?to=http%3A%2F%2Fflask-sqlalchemy.pocoo.org%2F2.3%2Fbinds%2F%23binds">绑定多种数据库</a>.</td></tr><tr><td><code>SQLALCHEMY_ECHO</code></td><td>调试设置为true</td></tr><tr><td><code>SQLALCHEMY_POOL_SIZE</code></td><td>数据库池的大小，默认值为5。</td></tr><tr><td><code>SQLALCHEMY_POOL_TIMEOUT</code></td><td>连接超时时间</td></tr><tr><td><code>SQLALCHEMY_POOL_RECYCLE</code></td><td>自动回收连接的秒数。</td></tr><tr><td><code>SQLALCHEMY_MAX_OVERFLOW</code></td><td>控制在连接池达到最大值后可以创建的连接数。当这些额外的 连接回收到连接池后将会被断开和抛弃。</td></tr><tr><td><code>SQLALCHEMY_TRACK_MODIFICATIONS</code></td><td>如果设置成 True (默认情况)，Flask-SQLAlchemy 将会追踪对象的修改并且发送信号。这需要额外的内存， 如果不必要的可以禁用它。</td></tr></tbody></table></div><p>操作数据库需要先创建一个db对象，通常写在<code>exts.py</code>文件里。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask_sqlalchemy <span class="keyword">import</span> SQLAlchemy</span><br><span class="line">db = SQLAlchemy()</span><br></pre></td></tr></table></figure><p>flask项目一般将数据库配置写入<code>configs.py</code>文件里面，配置在创建引擎前需写好，不要在程序运行时修改配置，如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">DIALECT = <span class="string">&#x27;mysql&#x27;</span></span><br><span class="line">DRIVER = <span class="string">&#x27;pymysql&#x27;</span></span><br><span class="line">USERNAME = <span class="string">&#x27;root&#x27;</span></span><br><span class="line">PASSWORD = <span class="string">&#x27;********&#x27;</span></span><br><span class="line">HOST = <span class="string">&#x27;127.0.0.1&#x27;</span></span><br><span class="line">PORT = <span class="string">&#x27;3306&#x27;</span></span><br><span class="line">DATABASE = <span class="string">&#x27;AIdrug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># mysql 不会认识utf-8,而需要直接写成utf8</span></span><br><span class="line">SQLALCHEMY_DATABASE_URI = <span class="string">&quot;&#123;&#125;+&#123;&#125;://&#123;&#125;:&#123;&#125;@&#123;&#125;:&#123;&#125;/&#123;&#125;?charset=utf8&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line"> DIALECT, DRIVER, USERNAME, PASSWORD, HOST, PORT, DATABASE)</span><br><span class="line"></span><br><span class="line">SQLALCHEMY_TRACK_MODIFICATIONS = <span class="literal">False</span></span><br><span class="line">SQLALCHEMY_ECHO = <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>写完数据库配置后需要和app绑定，<code>main.py</code>文件里写flask应用的创建和蓝图的注册等等，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">import</span> configs</span><br><span class="line"><span class="keyword">from</span> exts <span class="keyword">import</span> db</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"><span class="comment"># 加载配置文件</span></span><br><span class="line">app.config.from_object(configs)</span><br><span class="line"><span class="comment"># db绑定app</span></span><br><span class="line">db.init_app(app)</span><br></pre></td></tr></table></figure><h4 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h4><div class="table-container"><table><thead><tr><th>数据类型</th><th>说明</th></tr></thead><tbody><tr><td>Integer</td><td>整型</td></tr><tr><td>String</td><td>字符串</td></tr><tr><td>Text</td><td>文本</td></tr><tr><td>DateTime</td><td>日期</td></tr><tr><td>Float</td><td>浮点型</td></tr><tr><td>Boolean</td><td>布尔值</td></tr><tr><td>PickleType</td><td>存储一个序列化（ Pickle ）后的Python对象</td></tr><tr><td>LargeBinary</td><td>巨长度二进制数据</td></tr></tbody></table></div><ol><li><p>表的创建</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建表写在models.py文件里面</span></span><br><span class="line"><span class="keyword">from</span> .exts <span class="keyword">import</span> db</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">建表</span></span><br><span class="line"><span class="string">以下表关系：</span></span><br><span class="line"><span class="string">一个用户对应多篇文章（一对多）</span></span><br><span class="line"><span class="string">一篇文章对应多个标签，一个标签对应多个文章（多对多）</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">一对一关系中，需要设置relationship中的uselist=Flase，其他数据库操作一样。</span></span><br><span class="line"><span class="string">一对多关系中，外键设置在多的一方中，关系（relationship）可设置在任意一方。</span></span><br><span class="line"><span class="string">多对多关系中，需建立关系表，设置 secondary=关系表</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用户表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params">db.Model</span>):</span></span><br><span class="line">    __tablename__ = <span class="string">&#x27;user&#x27;</span></span><br><span class="line">    <span class="built_in">id</span> = db.Column(db.Integer, primary_key=<span class="literal">True</span>, autoincrement=<span class="literal">True</span>)</span><br><span class="line">    email = db.Column(db.String(<span class="number">30</span>))</span><br><span class="line">    username = db.Column(db.String(<span class="number">30</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Log表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Log</span>(<span class="params">db.Model</span>):</span></span><br><span class="line">    __tablename__ = <span class="string">&#x27;log&#x27;</span></span><br><span class="line">    <span class="built_in">id</span> = db.Column(db.Integer, primary_key=<span class="literal">True</span>, autoincrement=<span class="literal">True</span>)</span><br><span class="line">    userId = db.Column(db.Integer, db.ForeignKey(<span class="string">&#x27;user.id&#x27;</span>))  <span class="comment"># 外键</span></span><br><span class="line">    log = db.Column(db.String(<span class="number">50</span>))</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>表的映射</p><p>创建好表后需要映射到数据库中，这里用<code>flask-migrate</code>库，编写启动文件<code>manage.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask_script <span class="keyword">import</span> Manager, Server</span><br><span class="line"><span class="keyword">from</span> main <span class="keyword">import</span> app</span><br><span class="line"><span class="keyword">from</span> flask_migrate <span class="keyword">import</span> Migrate, MigrateCommand</span><br><span class="line"><span class="keyword">from</span> dao.exts <span class="keyword">import</span> db</span><br><span class="line"><span class="keyword">from</span> dao <span class="keyword">import</span> models  <span class="comment"># 模型文件必须导入进来，否则运行报错</span></span><br><span class="line"></span><br><span class="line">manager = Manager(app)</span><br><span class="line">Migrate(app=app, db=db)</span><br><span class="line">manager.add_command(<span class="string">&#x27;db&#x27;</span>, MigrateCommand) <span class="comment"># 创建数据库映射命令</span></span><br><span class="line">manager.add_command(<span class="string">&#x27;start&#x27;</span>, Server(port=<span class="number">8000</span>, use_debugger=<span class="literal">True</span>)) <span class="comment"># 创建启动命令</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    manager.run()</span><br></pre></td></tr></table></figure><p>编写好启动文件后，进入项目根目录，输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python manage.py db init</span><br><span class="line">python manage.py db migrate</span><br><span class="line">python manage.py db upgrade</span><br></pre></td></tr></table></figure></li></ol><ol><li>表的增删改查</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原生sql语句操作</span></span><br><span class="line">sql = <span class="string">&#x27;select * from user&#x27;</span></span><br><span class="line">result = db.session.execute(sql)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询全部</span></span><br><span class="line">User.query.<span class="built_in">all</span>()</span><br><span class="line"><span class="comment"># 主键查询</span></span><br><span class="line">User.query.get(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 条件查询</span></span><br><span class="line">User.query.filter_by(User.username=<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="comment"># 多条件查询</span></span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> and_</span><br><span class="line">User.query.filter_by(and_(User.username ==<span class="string">&#x27;name&#x27;</span>,User.password==<span class="string">&#x27;passwd&#x27;</span>))</span><br><span class="line"><span class="comment"># 比较查询</span></span><br><span class="line">User.query.<span class="built_in">filter</span>(User.<span class="built_in">id</span>.__lt__(<span class="number">5</span>)) <span class="comment"># 小于5</span></span><br><span class="line">User.query.<span class="built_in">filter</span>(User.<span class="built_in">id</span>.__le__(<span class="number">5</span>)) <span class="comment"># 小于等于5</span></span><br><span class="line">User.query.<span class="built_in">filter</span>(User.<span class="built_in">id</span>.__gt__(<span class="number">5</span>)) <span class="comment"># 大于5</span></span><br><span class="line">User.query.<span class="built_in">filter</span>(User.<span class="built_in">id</span>.__ge__(<span class="number">5</span>)) <span class="comment"># 大于等于5</span></span><br><span class="line"><span class="comment"># in查询</span></span><br><span class="line">User.query.<span class="built_in">filter</span>(User.username.in_(<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>))</span><br><span class="line"><span class="comment"># 排序</span></span><br><span class="line">User.query.order_by(<span class="string">&#x27;age&#x27;</span>) <span class="comment"># 按年龄排序，默认升序，在前面加-号为降序&#x27;-age&#x27;</span></span><br><span class="line"><span class="comment"># 限制查询</span></span><br><span class="line">User.query.<span class="built_in">filter</span>(age=<span class="number">18</span>).offset(<span class="number">2</span>).limit(<span class="number">3</span>)  <span class="comment"># 跳过二条开始查询，限制输出3条</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加</span></span><br><span class="line">use = User(<span class="built_in">id</span>,username,password)</span><br><span class="line">db.session.add(use)</span><br><span class="line">db.session.commit() </span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除</span></span><br><span class="line">User.query.filter_by(User.username=<span class="string">&#x27;name&#x27;</span>).delete()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改</span></span><br><span class="line">User.query.filter_by(User.username=<span class="string">&#x27;name&#x27;</span>).update(&#123;<span class="string">&#x27;password&#x27;</span>:<span class="string">&#x27;newdata&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure><p>成功！</p><p><img src="/2021/03/31/Flask%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93/image-20210331161346831.png" alt="image-20210331161346831"></p><p><img src="/2021/03/31/Flask%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93/image-20210331161413793.png" alt="image-20210331161413793"></p><p><img src="/2021/03/31/Flask%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93/image-20210331162012647.png" alt="image-20210331162012647"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MacOS安装MySQL</title>
    <link href="https://panlianghnu.github.io/2021/03/31/MacOS%E5%AE%89%E8%A3%85MySQL/"/>
    <id>https://panlianghnu.github.io/2021/03/31/MacOS%E5%AE%89%E8%A3%85MySQL/</id>
    <published>2021-03-31T02:28:20.000Z</published>
    <updated>2021-03-31T03:12:44.554Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MacOS安装MySQL"><a href="#MacOS安装MySQL" class="headerlink" title="MacOS安装MySQL"></a>MacOS安装MySQL</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>登陆MySQL网站，使用dmg方式安装</p><p>打开<a href="http://www.mysql.com/downloads/">MySQL官网</a>，选择下面的MySQL community Server，选择dmg文件下载</p><p><img src="/2021/03/31/MacOS%E5%AE%89%E8%A3%85MySQL/image-20210331103043570.png" alt="image-20210331103043570"></p><p><img src="/2021/03/31/MacOS%E5%AE%89%E8%A3%85MySQL/image-20210331103058200.png" alt="image-20210331103058200"></p><p>可以选择不登陆直接下载</p><p>下载完成后一路确定，输入你要设置的密码</p><p><img src="/2021/03/31/MacOS%E5%AE%89%E8%A3%85MySQL/image-20210331103153455.png" alt="image-20210331103153455"></p><p><img src="/2021/03/31/MacOS%E5%AE%89%E8%A3%85MySQL/image-20210331103302014.png" alt="image-20210331103302014"></p><hr><h2 id="打开MySQL服务"><a href="#打开MySQL服务" class="headerlink" title="打开MySQL服务"></a>打开MySQL服务</h2><ol><li>进入系统偏好设置</li></ol><p><img src="/2021/03/31/MacOS%E5%AE%89%E8%A3%85MySQL/image-20210331103716596.png" alt="image-20210331103716596"></p><p><img src="/2021/03/31/MacOS%E5%AE%89%E8%A3%85MySQL/image-20210331103754137.png" alt="image-20210331103754137"></p><p>点击MySQL</p><p><img src="/2021/03/31/MacOS%E5%AE%89%E8%A3%85MySQL/image-20210331103919619.png" alt="image-20210331103919619"></p><p>红色代表还没启动，绿色代表启动了</p><p>我服了，刚设的密码忘记了</p><p><img src="/2021/03/31/MacOS%E5%AE%89%E8%A3%85MySQL/image-20210331111040237.png" alt="image-20210331111040237"></p><p>卸载重装！</p><p>asd990711</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MacOS安装MySQL&quot;&gt;&lt;a href=&quot;#MacOS安装MySQL&quot; class=&quot;headerlink&quot; title=&quot;MacOS安装MySQL&quot;&gt;&lt;/a&gt;MacOS安装MySQL&lt;/h1&gt;&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>网易云音乐解锁灰歌-MacOS</title>
    <link href="https://panlianghnu.github.io/2021/03/28/%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E8%A7%A3%E9%94%81%E7%81%B0%E6%AD%8C-MacOS/"/>
    <id>https://panlianghnu.github.io/2021/03/28/%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E8%A7%A3%E9%94%81%E7%81%B0%E6%AD%8C-MacOS/</id>
    <published>2021-03-27T16:23:21.000Z</published>
    <updated>2021-03-27T16:32:05.204Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网易云音乐解锁灰歌"><a href="#网易云音乐解锁灰歌" class="headerlink" title="网易云音乐解锁灰歌"></a>网易云音乐解锁灰歌</h1><p style="text-align:right">For MacOS</p><p><a href="https://github.com/nondanee/UnblockNeteaseMusic/issues">github链接</a></p><h2 id="简易版本"><a href="#简易版本" class="headerlink" title="简易版本"></a>简易版本</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/nondanee/UnblockNeteaseMusic.git</span><br><span class="line">cd UnblockNeteaseMusic</span><br><span class="line">npm i</span><br></pre></td></tr></table></figure><p>接着信任证书，双击目录下的 <code>ca.crt</code> 文件，点击添加<img src="/2021/03/28/%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E8%A7%A3%E9%94%81%E7%81%B0%E6%AD%8C-MacOS/90654597-21898b00-e273-11ea-86c9-8a7af6c0787c.png" alt="90654597-21898b00-e273-11ea-86c9-8a7af6c0787c"></p><p>输入密码后再双击：<img src="/2021/03/28/%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E8%A7%A3%E9%94%81%E7%81%B0%E6%AD%8C-MacOS/90654852-67465380-e273-11ea-864b-703a5cc2e510.png" alt="90654852-67465380-e273-11ea-864b-703a5cc2e510"></p><p>按照指引点击，输入密码<img src="/2021/03/28/%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E8%A7%A3%E9%94%81%E7%81%B0%E6%AD%8C-MacOS/90654979-965cc500-e273-11ea-9043-bbdf84b38d32.png" alt="90654979-965cc500-e273-11ea-9043-bbdf84b38d32"></p><h2 id="1-寻找网易云服务器的IP"><a href="#1-寻找网易云服务器的IP" class="headerlink" title="1. 寻找网易云服务器的IP"></a>1. 寻找网易云服务器的IP</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping music.163.com</span><br></pre></td></tr></table></figure><p>得到IP：59.111.181.60</p><h2 id="2-向hosts文件添加记录"><a href="#2-向hosts文件添加记录" class="headerlink" title="2. 向hosts文件添加记录"></a>2. 向hosts文件添加记录</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/hosts</span><br><span class="line">append</span><br><span class="line">127.0.0.1 music.163.com</span><br><span class="line">127.0.0.1 interface.music.163.com</span><br></pre></td></tr></table></figure><h2 id="3-设置参数启动"><a href="#3-设置参数启动" class="headerlink" title="3. 设置参数启动"></a>3. 设置参数启动</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd UnblockNeteaseMusic</span><br><span class="line">node app.js -p 80:443 -f 59.111.181.60</span><br></pre></td></tr></table></figure><p>接着使用 <code>safari</code> 打开 <code>https://music.163.com</code> 确保可以访问（如果弹出无法访问，再信任一次）</p><p>重启网抑云～</p><p>或者可以使用别人的一键脚本：</p><p><a href="https://github.com/geoleonsh/unblockNeteaseShell">unblockNeteaseShell</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;网易云音乐解锁灰歌&quot;&gt;&lt;a href=&quot;#网易云音乐解锁灰歌&quot; class=&quot;headerlink&quot; title=&quot;网易云音乐解锁灰歌&quot;&gt;&lt;/a&gt;网易云音乐解锁灰歌&lt;/h1&gt;&lt;p style=&quot;text-align:right&quot;&gt;For MacOS&lt;/p&gt;

&lt;p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Flask+Vue 前后端分离JWT用户验证</title>
    <link href="https://panlianghnu.github.io/2021/03/25/Flask-Vue-%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBJWT%E7%94%A8%E6%88%B7%E9%AA%8C%E8%AF%81/"/>
    <id>https://panlianghnu.github.io/2021/03/25/Flask-Vue-%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBJWT%E7%94%A8%E6%88%B7%E9%AA%8C%E8%AF%81/</id>
    <published>2021-03-25T08:35:28.000Z</published>
    <updated>2021-03-25T09:12:04.864Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2021/03/25/Flask-Vue-%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBJWT%E7%94%A8%E6%88%B7%E9%AA%8C%E8%AF%81/image-20210325163605308.png" alt="image-20210325163605308"></p><p>传统Flask通过Flask-Login的login_user()解决登录问题，通过session进行处理，不适合前后端分离系统，所以使用JWT进行用户认证</p><blockquote><p>传统Flask通过Flask-Login的login_user()解决登录问题，通过session进行处理，不适合前后端分离系统，所以使用JWT进行用户认证</p><h5 id="Session-cookie"><a href="#Session-cookie" class="headerlink" title="Session-cookie:"></a>Session-cookie:</h5><p>Session是对于服务端来说的，客户端是没有Session一说的。Session是服务器在和客户端建立连接时添加客户端连接标志，最终会在服务器软件(Apache、Tomcat、JBoss)转化为一个临时Cookie(SessionId)发送给给客户端，当客户端请求时服务器会检查是否携带了这个SessionId(临时Cookie)，如果没有则会要求重新登录。</p><p>问题：</p><ol><li>如果我们的页面出现了 XSS 漏洞，由于 cookie 可以被 JavaScript 读取，XSS 漏洞会导致用户SessionId泄露，而作为后端识别用户的标识，cookie 的泄露意味着用户信息不再安全。在设置 cookie 的时候，其实你还可以设置 httpOnly 以及 secure 项。设置 httpOnly 后 cookie 将不能被 JS 读取，浏览器会自动的把它加在请求的 header 当中，设置 secure 的话，cookie 就只允许通过 HTTPS 传输。</li><li>httpOnly 选项使得 JS 不能读取到 cookie，那么 XSS 注入的问题也基本不用担心了。但设置 httpOnly 就带来了另一个问题，就是很容易的被 XSRF或CSRF(跨站请求伪造)。当你浏览器开着这个页面的时候，另一个页面可以很容易的跨站请求这个页面的内容。因为 cookie 默认被发了出去。</li><li>由于后端保存了所有用户的Session，后端每次都需要根据SessionId查出用户Session进行匹配，加大了服务器端的压力。</li></ol><h5 id="JWT"><a href="#JWT" class="headerlink" title="JWT:"></a>JWT:</h5><p>JWT 是一个开放标准(RFC 7519)，它定义了一种用于简洁，自包含的用于通信双方之间以 JSON 对象的形式安全传递信息的方法。JWT 可以使用 HMAC 算法或者是 RSA 的公钥密钥对进行签名。它具备两个特点：</p><ol><li><p>简洁(Compact)</p><p>可以通过URL, 参数或者在 HTTP header 发送，因为数据量小，传输速度快</p></li><li><p>自包含(Self-contained)</p><p>负载中包含了所有用户所需要的信息，避免了多次查询数据库</p><p>JWT一共由三部分组成，header（头部）、payload（负载）、signature（签名）通过‘.’进行拼接</p><p><img src="/2021/03/25/Flask-Vue-%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBJWT%E7%94%A8%E6%88%B7%E9%AA%8C%E8%AF%81/image-20210325163645225.png" alt="image-20210325163645225"></p><p>header(头部) 转Base64</p><p>payload(负载) 自定义信息内容, 不建议存储敏感信息(如密码) 转Base64</p><p>signature(签名) 一共三部分。转base64的header和转base64的payload拼接之后，然后使用header中声明的加密方式和secret加盐的方式加密字符串</p><ul><li><p>转Base64的header</p></li><li><p>转Base64的payload</p></li><li><p>secret(私钥)</p><p>最后一步签名的过程，实际上是对头部以及负载内容进行签名，防止内容被窜改。如果有人对头部以及负载的内容解码之后进行修改，再进行编码，最后加上之前的签名组合形成新的JWT的话，那么服务器端会判断出新的头部和负载形成的签名和JWT附带上的签名是不一样的。如果要对新的头部和负载进行签名，在不知道服务器加密时用的密钥的话，得出来的签名也是不一样的。</p></li><li><p>iss 签发者</p></li><li>sub 面向的用户</li><li>aud 接收jwt的一方</li><li>exp 过期时间(必须大于签发时间jat)</li><li>nbf 定义在什么时间之前，该jwt都是不可用的</li><li>jat 签发时间</li><li><p>jti 唯一身份标识，主要用来作为一次性token,从而回避重放攻击</p></li><li><p>alg 加密算法</p></li><li><p>typ 类型</p></li><li><p>差异比较</p></li></ul><p>Session方式存储用户id的最大弊病在于Session是存储在服务器端的，所以需要占用大量服务器内存，对于较大型应用而言可能还要保存许多的状态。一般而言，大型应用还需要借助一些KV数据库和一系列缓存机制来实现Session的存储。</p><p>JWT方式将用户状态分散到了客户端中，可以明显减轻服务端的内存压力。除了用户id之外，还可以存储其他的和用户相关的信息，例如该用户是否是管理员、用户所在的分组等。虽说JWT方式让服务器有一些计算压力（例如加密、编码和解码），但是这些压力相比磁盘存储而言可能就不算什么了。具体是否采用，需要在不同场景下用数据说话</p><ul><li>单点登陆</li></ul><p>Session方式来存储用户id，一开始用户的Session只会存储在一台服务器上。对于有多个子域名的站点，每个子域名至少会对应一台不同的服务器，例如：www.taobao.com，nv.taobao.com，nz.taobao.com，login.taobao.com。所以如果要实现在login.taobao.com登录后，在其他的子域名下依然可以取到Session，这要求我们在多台服务器上同步Session。使用JWT的方式则没有这个问题的存在，因为用户的状态已经被传送到了客户端。</p></li></ol></blockquote><h1 id="JWT认证流程"><a href="#JWT认证流程" class="headerlink" title="JWT认证流程"></a>JWT认证流程</h1><p><img src="/2021/03/25/Flask-Vue-%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBJWT%E7%94%A8%E6%88%B7%E9%AA%8C%E8%AF%81/image-20210325163819387.png" alt="image-20210325163819387"></p><ol><li>首先，前端通过Web表单将自己的用户名和密码发送到后端的接口。这一过程一般是一个HTTP POST请求。建议的方式是通过SSL加密的传输（https协议），从而避免敏感信息被嗅探。</li><li>后端核对用户名和密码成功后，将用户的id等其他信息作为JWT Payload（负载），将其与头部分别进行Base64编码拼接后签名，形成一个JWT。形成的JWT就是一个形同hhh.ppp.sss的字符串。</li><li>后端将JWT字符串作为登录成功的返回结果返回给前端。前端可以将返回的结果保存在localStorage或sessionStorage上，退出登录时前端删除保存的JWT即可。</li><li>前端在每次请求时将JWT放入HTTP Header中的Authorization位。(解决XSS和XSRF问题)</li><li>后端检查是否存在，如存在验证JWT的有效性。例如，检查签名是否正确；检查JWT是否过期；检查JWT的接收方是否是自己</li><li>验证通过后后端使用JWT中包含的用户信息进行其他逻辑操作，返回相应结果。</li></ol><hr><h1 id="Vue前端"><a href="#Vue前端" class="headerlink" title="Vue前端"></a>Vue前端</h1><h2 id="Vue-router"><a href="#Vue-router" class="headerlink" title="Vue-router"></a>Vue-router</h2><p>成功登录时，将后端返回的jwt存入sessionStorage</p><p>使用Vue-router在前端每次界面切换前都判断jwt，不符合要求则跳转至login登录界面</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 路由守护</span></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> accessToken = <span class="built_in">window</span>.sessionStorage.getItem(<span class="string">&#x27;accessToken&#x27;</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(accessToken) </span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment">// 重新登录后，转到之前的页面</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">Object</span>.keys(<span class="keyword">from</span>.query).length !== <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">let</span> redirect = <span class="keyword">from</span>.query.redirect</span><br><span class="line">        <span class="keyword">if</span>(to.path === redirect) <span class="comment">// 解决无限循环问题</span></span><br><span class="line">        &#123;</span><br><span class="line">          next()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          next(&#123;<span class="attr">path</span>:redirect&#125;) <span class="comment">// 重新登录后，转到之前的页面</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(accessToken &amp;&amp; to.path !== <span class="string">&#x27;/login&#x27;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 有token 但不是去 login页面</span></span><br><span class="line">    next()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(accessToken &amp;&amp; to.path === <span class="string">&#x27;/login&#x27;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//用户已经登陆，不让访问Login登录界面</span></span><br><span class="line">    next(&#123;<span class="attr">path</span>: <span class="keyword">from</span>.fullPath&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(!accessToken &amp;&amp; to.path !== <span class="string">&#x27;/login&#x27;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 未登录</span></span><br><span class="line">    next(<span class="string">&#x27;/login&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    next()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h2><p>axios 全局配置拦截器</p><p>request拦截器每次向后端请求携带header头Authorization信息</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// http request 拦截器</span></span><br><span class="line">axios.interceptors.request.use(</span><br><span class="line">  config =&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span>(sessionStorage.getItem(<span class="string">&quot;accessToken&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        config.headers.Authorization = sessionStorage.getItem(<span class="string">&quot;accessToken&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  &#125;,</span><br><span class="line">  err =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err);</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>response拦截器若接收到401错误，则是未登录，无权访问，则清除sessionStorage信息并跳转至login登录界面</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/ http response 拦截器</span><br><span class="line">axios.interceptors.response.use(</span><br><span class="line">  response =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;,</span><br><span class="line">  error =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(error.response)&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;axios:&#x27;</span> + error.response.status);</span><br><span class="line">      <span class="keyword">switch</span>(error.response.status)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">401</span>:</span><br><span class="line">          <span class="comment">// 返回401 清除token信息并跳转到登录页面</span></span><br><span class="line">          sessionStorage.clear() </span><br><span class="line">          router.replace(&#123;</span><br><span class="line">            path: <span class="string">&#x27;/login&#x27;</span>,</span><br><span class="line">            query: &#123;<span class="attr">redirect</span>: router.currentRoute.fullPath&#125;   <span class="comment">// 重新登录后，返回之前的页面</span></span><br><span class="line">          &#125;)</span><br><span class="line">          Message(&#123;<span class="attr">showClose</span>:<span class="literal">true</span>, <span class="attr">message</span>:<span class="string">&#x27;未登录，返回登陆界面&#x27;</span>, <span class="attr">type</span>:<span class="string">&#x27;error&#x27;</span>, <span class="attr">duration</span>:<span class="number">3000</span>&#125;)  </span><br><span class="line">   </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);   <span class="comment">// 返回接口的错误信息</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><hr><h1 id="Flask后端"><a href="#Flask后端" class="headerlink" title="Flask后端"></a>Flask后端</h1><ol><li><p>安装PyJWT pip install PyJWT</p></li><li><p>编写JWT生成函数与解密函数(util.py)</p><ol><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">key = <span class="string">&quot;123456&quot;</span> <span class="comment"># secret私钥,可通过配置文件导入</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_access_token</span>(<span class="params">username: <span class="built_in">str</span> = <span class="string">&quot;&quot;</span>, algorithm: <span class="built_in">str</span> = <span class="string">&#x27;HS256&#x27;</span>, exp: <span class="built_in">float</span> = <span class="number">2</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    生成access_token</span></span><br><span class="line"><span class="string">    :param username: 用户名(自定义部分)</span></span><br><span class="line"><span class="string">    :param algorithm: 加密算法</span></span><br><span class="line"><span class="string">    :param exp: 过期时间</span></span><br><span class="line"><span class="string">    :return:token</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    now = datetime.utcnow()</span><br><span class="line">    exp_datetime = now + timedelta(hours=exp)</span><br><span class="line">    access_payload = &#123;</span><br><span class="line">        <span class="string">&#x27;exp&#x27;</span>: exp_datetime,</span><br><span class="line">        <span class="string">&#x27;flag&#x27;</span>: <span class="number">0</span>,   <span class="comment">#标识是否为一次性token，0是，1不是</span></span><br><span class="line">        <span class="string">&#x27;iat&#x27;</span>: now,   <span class="comment"># 开始时间</span></span><br><span class="line">        <span class="string">&#x27;iss&#x27;</span>: <span class="string">&#x27;leon&#x27;</span>,   <span class="comment"># 签名</span></span><br><span class="line">        <span class="string">&#x27;username&#x27;</span>: username   <span class="comment">#用户名(自定义部分)</span></span><br><span class="line">    &#125;</span><br><span class="line">    access_token = jwt.encode(access_payload, key, algorithm=algorithm)</span><br><span class="line">    <span class="keyword">return</span> access_token</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decode_auth_token</span>(<span class="params">token: <span class="built_in">str</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    解密token</span></span><br><span class="line"><span class="string">    :param token:token字符串</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        payload = jwt.decode(token, key=key, algorithms=<span class="string">&#x27;HS256&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> (jwt.ExpiredSignatureError, jwt.InvalidTokenError, jwt.InvalidSignatureError):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">identify</span>(<span class="params">auth_header: <span class="built_in">str</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    用户鉴权</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> auth_header:</span><br><span class="line">        payload = decode_auth_token(auth_header)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> payload:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;username&quot;</span> <span class="keyword">in</span> payload <span class="keyword">and</span> <span class="string">&quot;flag&quot;</span> <span class="keyword">in</span> payload:</span><br><span class="line">            <span class="keyword">if</span> payload[<span class="string">&quot;flag&quot;</span>] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> payload[<span class="string">&quot;username&quot;</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>编写登录保护函数(util.py)</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login_required</span>(<span class="params">f</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    登录保护，验证用户是否登录</span></span><br><span class="line"><span class="string">    :param f:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @wraps(<span class="params">f</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        token = request.headers.get(<span class="string">&quot;Authorization&quot;</span>, default=<span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> token:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;not Login&#x27;</span>,<span class="string">&#x27;401 Permission Denied&#x27;</span></span><br><span class="line">        username = identify(token)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> username:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;not Login&#x27;</span>,<span class="string">&#x27;401 Permission Denied&#x27;</span>      <span class="comment"># return 响应体, 状态码, 响应头</span></span><br><span class="line">        <span class="keyword">return</span> f(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><p>tips: Flask的Response常用返回 return 响应体, 状态码, 响应头</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2021/03/25/Flask-Vue-%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBJWT%E7%94%A8%E6%88%B7%E9%AA%8C%E8%AF%81/image-20210325163605</summary>
      
    
    
    
    
    <category term="python" scheme="https://panlianghnu.github.io/tags/python/"/>
    
    <category term="Flask" scheme="https://panlianghnu.github.io/tags/Flask/"/>
    
    <category term="Vue" scheme="https://panlianghnu.github.io/tags/Vue/"/>
    
    <category term="JWT" scheme="https://panlianghnu.github.io/tags/JWT/"/>
    
  </entry>
  
  <entry>
    <title>直播小工具</title>
    <link href="https://panlianghnu.github.io/2021/03/15/%E7%9B%B4%E6%92%AD%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
    <id>https://panlianghnu.github.io/2021/03/15/%E7%9B%B4%E6%92%AD%E5%B0%8F%E5%B7%A5%E5%85%B7/</id>
    <published>2021-03-15T05:33:01.000Z</published>
    <updated>2021-03-15T07:13:48.289Z</updated>
    
    <content type="html"><![CDATA[<h1 id="直播小工具"><a href="#直播小工具" class="headerlink" title="直播小工具"></a>直播小工具</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近有充分的时间摸鱼…我捣鼓了一个看直播的小工具</p><p align="right">- inspired by Zlive</p><p>自从我手机端下载了<a href="https://app.zhibo.at">Z直播</a>，我就卸载了其他直播软件（斗鱼、虎牙），一个软件看各大平台直播实在是太好了。而且它还轻便，不用注册，没广告，没礼物，没全站喇叭……</p><p>可惜，<a href="https://app.zhibo.at">Z直播</a>并没有PC客户端，我就想着自己捣鼓一个程序看全网直播，不拘束于各大平台。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>优雅地看直播</p><ul><li><p>跨直播平台</p></li><li><p>无广告</p></li><li>高清流畅</li><li>没有礼物特效</li><li>无需注册账号</li></ul><h2 id="展示"><a href="#展示" class="headerlink" title="展示"></a>展示</h2><p>下面是GIF：</p><p><img src="/2021/03/15/%E7%9B%B4%E6%92%AD%E5%B0%8F%E5%B7%A5%E5%85%B7/优雅地看直播.gif" alt="优雅地看直播"></p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/panlianghnu/WatchLive_cross-platform.git</span><br><span class="line">cd WatchLive_cross-platform/</span><br></pre></td></tr></table></figure><h3 id="1、安装依赖"><a href="#1、安装依赖" class="headerlink" title="1、安装依赖"></a>1、安装依赖</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install</span><br></pre></td></tr></table></figure><h3 id="2、修改订阅"><a href="#2、修改订阅" class="headerlink" title="2、修改订阅"></a>2、修改订阅</h3><p>按照 “平台” “房间号” “标注” 的格式，每一行代表一个直播间，行内元素用空格分开</p><p>如图:</p><p><img src="/2021/03/15/%E7%9B%B4%E6%92%AD%E5%B0%8F%E5%B7%A5%E5%85%B7/image-20210315144140484.png" alt="image-20210315144140484"></p><h3 id="3、修改播放器"><a href="#3、修改播放器" class="headerlink" title="3、修改播放器"></a>3、修改播放器</h3><p>第 59 行，修改 open_app 的值，改成自己的支持流媒体输出的视频播放器的路径，比如你是 IINA 播放器，就写 open_app = “open -a /Applications/IINA.app”</p><p>如果不是 MacOS ，可能命令不是 open -a，需要自己修改</p><h3 id="4、运行"><a href="#4、运行" class="headerlink" title="4、运行"></a>4、运行</h3><p>在当前目录直接运行 python main.py 即可啦</p><p>可以像我一样在桌面放置一个 shell 文件，修改路径为自己的 shell 和 main.py</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/zsh</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># author:panliang</span></span></span><br><span class="line">python ~/real-url/main.py</span><br></pre></td></tr></table></figure><p>本工具仅在 python3 的环境测试</p><p>获取斗鱼的直播源，需 JavaScript 环境，可使用 node.js</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>流媒体地址获取参考 <a href="https://github.com/wbt5/real-url">real-url</a> </p><p>通过 <a href="https://github.com/wbt5/real-url">real-url</a> 获取直播间的真实播放源，然后通过一些可以播放流媒体的播放器打开播放源，达到不用注册、不用看广告、直接高清观看直播的目的</p><p>可以打开直播源的播放器很多：INNA、PotPlayer、VLC、DPlayer……</p><p><a href="https://github.com/panlianghnu/WatchLive_cross-platform">源代码</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;直播小工具&quot;&gt;&lt;a href=&quot;#直播小工具&quot; class=&quot;headerlink&quot; title=&quot;直播小工具&quot;&gt;&lt;/a&gt;直播小工具&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>杭电OJ</title>
    <link href="https://panlianghnu.github.io/2021/03/14/%E6%9D%AD%E7%94%B5OJ/"/>
    <id>https://panlianghnu.github.io/2021/03/14/%E6%9D%AD%E7%94%B5OJ/</id>
    <published>2021-03-14T09:05:52.000Z</published>
    <updated>2021-03-14T14:50:13.194Z</updated>
    
    <content type="html"><![CDATA[<h1 id="刷刷OJ放松一下"><a href="#刷刷OJ放松一下" class="headerlink" title="刷刷OJ放松一下"></a>刷刷OJ放松一下</h1><h2 id="1001-数列和"><a href="#1001-数列和" class="headerlink" title="1001-数列和"></a>1001-数列和</h2><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1001">原题链接</a></p><p>这个题目就是给一个正整数n，求 sum =  1 + 2 + 3 + … + n</p><p>我的第一反应就是循环相加或者递归相加复杂度太高，可能过不了。直接用求和公式即可</p><p>当我写下 sum = (n+1)*n/2 以为稳过的时候，提交后 err 了。。。想了很久代码应该没问题，去网上查发现这个题递归就能AC，崩溃！最后发现是中间结果爆 int 了，改成判断奇偶做就 AC 了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.c</span></span><br><span class="line"><span class="comment">//  OJ-HD-1004</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by panliang on 2021/3/12.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n)!=EOF) &#123;</span><br><span class="line">        n%<span class="number">2</span>==<span class="number">0</span>?</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n\n&quot;</span>,n/<span class="number">2</span>*(n+<span class="number">1</span>))</span><br><span class="line">        :</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n\n&quot;</span>,(n+<span class="number">1</span>)/<span class="number">2</span>*n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1002-大数相加"><a href="#1002-大数相加" class="headerlink" title="1002-大数相加"></a>1002-大数相加</h2><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1002">原题链接</a></p><p>这个题目就是不断输入两个正整数，然后求他们的和，数据很大很大，需要用高精度来做</p><p>用字符串保存数据，一步步模拟加法过程即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.c</span></span><br><span class="line"><span class="comment">//  OJ-HD-1002</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by panliang on 2021/3/12.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxsize 1010</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">plus</span><span class="params">(<span class="keyword">char</span>*,<span class="keyword">char</span>*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// two big positive integer plus</span></span><br><span class="line">    <span class="keyword">int</span> n,i=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">char</span> a[maxsize];</span><br><span class="line">        <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*maxsize);</span><br><span class="line">        <span class="keyword">char</span> b[maxsize];</span><br><span class="line">        <span class="built_in">memset</span>(b,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*maxsize);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>,a,b);</span><br><span class="line">        <span class="keyword">char</span>* c = plus(a,b);</span><br><span class="line">        <span class="comment">// a plus b</span></span><br><span class="line">        <span class="keyword">if</span>(i&gt;<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d:\n%s + %s = %s\n&quot;</span>,i,a,b,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>* a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> tmp[maxsize];</span><br><span class="line">    <span class="built_in">strcpy</span>(tmp,a);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len = <span class="built_in">strlen</span>(a);</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;i&lt;len;i++) &#123;</span><br><span class="line">        a[i] = tmp[len-i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">plus</span><span class="params">(<span class="keyword">char</span>* a,<span class="keyword">char</span>* b)</span></span>&#123;</span><br><span class="line">    reverse(a);</span><br><span class="line">    reverse(b);</span><br><span class="line">    <span class="keyword">char</span>* c = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*maxsize);</span><br><span class="line">    <span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*maxsize);</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;i&lt;maxsize;i++) &#123; <span class="comment">// 按位相加</span></span><br><span class="line">        <span class="keyword">if</span> (a[i]+b[i]) &#123; <span class="comment">// 如果不同时为&#x27;\0&#x27;</span></span><br><span class="line">            c[i] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (a[i]&gt;=<span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                c[i] += a[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (b[i]&gt;=<span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                c[i] += b[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理进位，两个数相加无需回溯考虑，最多也就19 =&gt; 9</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;maxsize<span class="number">-1</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(c[i]&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">            c[i] -= <span class="number">10</span>;</span><br><span class="line">            c[i+<span class="number">1</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(a); <span class="comment">// 程序健壮性</span></span><br><span class="line">    reverse(b); <span class="comment">// reverse只是方便处理相加，返回前应该复原</span></span><br><span class="line">    reverse(c);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1003-最大子序列和"><a href="#1003-最大子序列和" class="headerlink" title="1003-最大子序列和"></a>1003-最大子序列和</h2><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1003">原题链接</a></p><p>给一个序列，求一个子序列，要求这个子序列的和，是所有子序列的和中最大的那个。输出子序列的和、起始索引、终止索引</p><p>这个题目我的第一反应是二维动态规划，使用一个数组 dp[i][j] 表示 sum = arr[i]+…+arr[j]，然后数据太大爆内存了。。后来发现这个题目好像没有必要二维动态规划，只是求最大值而已，一维即可。</p><p>做法是遍历数组，需要5个变量作为中间变量</p><p>sum : 记录最大子序列的和，最终输出</p><p>left : 记录最大子序列的左索引，最终输出</p><p>right : 记录最大子序列的右索引，最终输出</p><p>tmp_sum : 保存中间序列的和，动态变化，不断和 sum 比较大小</p><p>tmp_left : 保存中间序列的左索引，如果中间序列的和是负数，则开新窗口，移动 tmp_left</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.c</span></span><br><span class="line"><span class="comment">//  OJ-HD-1003</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by panliang on 2021/3/12.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxsize 100010</span></span><br><span class="line"><span class="keyword">int</span> arr[maxsize];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">    <span class="keyword">int</span> cases=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;cases&lt;=t;cases++)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(arr,<span class="number">0</span>,<span class="keyword">sizeof</span>(arr));</span><br><span class="line">        <span class="keyword">int</span> len,i;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;len);</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;len;i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 求 arr 的最大子序列和</span></span><br><span class="line">        <span class="comment">// 二维动态规划必定爆内存，100010*100010*sizeof(int)</span></span><br><span class="line">        <span class="comment">// dp[i][j] = sum of arr[i] +...+ arr[j]</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>,sum=<span class="number">-1010</span>,tmp_sum=<span class="number">0</span>,tmp_left=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;len;i++) &#123;</span><br><span class="line">            tmp_sum += arr[i];</span><br><span class="line">            <span class="keyword">if</span> (tmp_sum &gt; sum) &#123;</span><br><span class="line">                sum = tmp_sum;</span><br><span class="line">                left = tmp_left;</span><br><span class="line">                right = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmp_sum &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                tmp_left = i+<span class="number">1</span>;</span><br><span class="line">                tmp_sum = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cases&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d:\n%d %d %d\n&quot;</span>,cases,sum,left+<span class="number">1</span>,right+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1004-Let-the-Balloon-Rise"><a href="#1004-Let-the-Balloon-Rise" class="headerlink" title="1004-Let the Balloon Rise"></a>1004-Let the Balloon Rise</h2><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1004">原题链接</a></p><p>输入N(0&lt;N&lt;=1000)个字符串，求出现次数最多的字符串</p><p>最简单的就是使用 map<string,int>，但是C语言标准库没有 string，也没有 map 。。。</string,int></p><p>我看N不大，没有用 hash，直接使用数组也过了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.c</span></span><br><span class="line"><span class="comment">//  OJ-HD-1004</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by panliang on 2021/3/14.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">&#125; colors[<span class="number">1010</span>];</span><br><span class="line"><span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertColor</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* toinsert)</span></span>&#123;</span><br><span class="line">    <span class="built_in">strcpy</span>(colors[len].str,toinsert);</span><br><span class="line">    colors[len++].num = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearColor</span><span class="params">()</span></span>&#123;</span><br><span class="line">    len=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleColor</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span>&#123; <span class="comment">// 找到则+1，没找到则 insert</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;len;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(colors[i].str, str) == <span class="number">0</span>) &#123;</span><br><span class="line">            colors[i].num++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    insertColor(str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">maxColor</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,tmpMax=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span>* res=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;len;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tmpMax &lt; colors[i].num) &#123;</span><br><span class="line">            tmpMax = colors[i].num;</span><br><span class="line">            res = colors[i].str;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// hashmap[] is the best way, but c has no stl</span></span><br><span class="line">    <span class="keyword">int</span> n,i;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n) &amp;&amp; n) &#123;</span><br><span class="line">        clearColor();</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> str[<span class="number">16</span>];</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">            handleColor(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,maxColor());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1005-Number-Sequence"><a href="#1005-Number-Sequence" class="headerlink" title="1005-Number Sequence"></a>1005-Number Sequence</h2><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1005">原题链接</a></p><p>f(1) = 1, f(2) = 1, f(n) = (A <em> f(n - 1) + B </em> f(n - 2)) mod 7.</p><p>给你 A B n， (1 &lt;= A, B &lt;= 1000, 1 &lt;= n &lt;= 100,000,000)，求 f(n)</p><p>这个题目涉及到 mod 运算，那么贴一个 mod 运算的性质</p><blockquote><p>模运算满足结合律、交换律、分配率，具体如下：</p><p>A. 结合律</p><p>((a+b)%p+c)%p=(a+(b+c)%p)%p</p><p>((ab)%p <em> c)%p= (a </em> (bc)%p)%p</p><p>B. 交换律</p><p>(a+b)%p=(b+a)%p</p><p>(ab)%p=(ba)%p</p><p>C. 分配率</p><p>(a+b)%p=(a%p+b%p)%p</p><p>((a+b)%pc)%p = ( (ac)%p + (b*c)%p )%p</p></blockquote><p>所以这个题目我可以先对输入的 A、B求mod，不会影响最终的结果，大幅缩小A、B的值会让中间的乘法运算更快，然后我交了一次，超时了。。。</p><p>我开始找数组的规律，可以发现 f(i) 只和 f(i-1) f(i-2) 有关，f(1) = f(2) = 1，所以只要当后面计算出来的结果也有连续的1，这个数字序列就进入了循环了，上代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.c</span></span><br><span class="line"><span class="comment">//  OJ-HD-1005</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by panliang on 2021/3/14.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//A number sequence is defined as follows:</span></span><br><span class="line"><span class="comment">//f(1) = 1, f(2) = 1, f(n) = (A * f(n - 1) + B * f(n - 2)) mod 7.</span></span><br><span class="line"><span class="comment">//Given A, B, and n, you are to calculate the value of f(n).</span></span><br><span class="line"><span class="comment">// 周期性函数,什么时候 one two 都变成1 ，就是一个周期到了</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b,n,i;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;n) &amp;&amp; (a+b+n)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span> || n==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        a = a%<span class="number">7</span>;</span><br><span class="line">        b = b%<span class="number">7</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp=<span class="number">0</span>,one=<span class="number">1</span>,two=<span class="number">1</span>;;</span><br><span class="line">        <span class="keyword">int</span> circle = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 新增一个数组，循环最多49次就会出现</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">3</span>;i&lt;=n;i++) &#123;</span><br><span class="line">            tmp = (a*two + b*one)%<span class="number">7</span>;  <span class="comment">// tmp = f(i)</span></span><br><span class="line">            one = two;                <span class="comment">// one = f(i-1)</span></span><br><span class="line">            two = tmp;                <span class="comment">// two = f(i)</span></span><br><span class="line">            <span class="keyword">if</span> (one == <span class="number">1</span> &amp;&amp; two == <span class="number">1</span>) &#123;  <span class="comment">// 周期 --&gt; f(i) = f(2)  f(i-1) = f(1)</span></span><br><span class="line">                circle = i<span class="number">-2</span>;</span><br><span class="line">                n = n%circle + circle; <span class="comment">// 加一个circle 防止落在0 , 大幅度缩小 n.... md还是超时...</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (circle) &#123;</span><br><span class="line">            <span class="keyword">if</span>(n==<span class="number">1</span> || n==<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (i=<span class="number">3</span>;i&lt;=n;i++) &#123;</span><br><span class="line">                tmp = (a*two + b*one)%<span class="number">7</span>;  <span class="comment">// tmp = f(i)</span></span><br><span class="line">                one = two;                <span class="comment">// one = f(i-1)</span></span><br><span class="line">                two = tmp;                <span class="comment">// two = f(i)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提交！</p><p>还是超时了😭</p><p>我去看看别人的博客发现了序列的循环不一定是整个循环，可能出现序列运行一段时间然后陷入循环，这个时候循环的部分不一定是以连续两个1开始。</p><p>知道了错误即可重新优化 n 的值</p><p>定义一个 hasShow[one][two] ，保存连续出现的两个值 one two 的索引（保存的是 one 的索引）</p><p>每次迭代计算新的 one two 时，标记 hasShow，直到命中 hasShow，即可确定循环在何处开始，训话你的大小是多少。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> hasShow[<span class="number">7</span>][<span class="number">7</span>];   <span class="comment">// hasShow[one][two] 代表 one two 排列已经出现，值为one出现的index</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b,n,i;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;n) &amp;&amp; (a+b+n)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span> || n==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        a = a%<span class="number">7</span>;</span><br><span class="line">        b = b%<span class="number">7</span>;</span><br><span class="line">        <span class="built_in">memset</span>(hasShow,<span class="number">0</span>,<span class="keyword">sizeof</span>(hasShow));</span><br><span class="line">        hasShow[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>; <span class="comment">// one=1 two=1 已经出现， index of one is 1</span></span><br><span class="line">        <span class="keyword">int</span> tmp=<span class="number">0</span>,one=<span class="number">1</span>,two=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> fall_in_cycle = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">3</span>;i&lt;=n;i++) &#123;</span><br><span class="line">            tmp = (a*two + b*one)%<span class="number">7</span>;  <span class="comment">// tmp = f(i)</span></span><br><span class="line">            one = two;                <span class="comment">// one = f(i-1)</span></span><br><span class="line">            two = tmp;                <span class="comment">// two = f(i)</span></span><br><span class="line">            <span class="keyword">if</span> (hasShow[one][two]) &#123;</span><br><span class="line">                <span class="comment">// cycle is (index of one - hasShow[one][two]) and now one is i-1</span></span><br><span class="line">                <span class="keyword">int</span> cycle = i<span class="number">-1</span> - hasShow[one][two];</span><br><span class="line">                <span class="comment">// 然后就可以定位 n 了，从 hasShow[one][two]开始,不断按照cycle循环</span></span><br><span class="line">                n = n - (hasShow[one][two]<span class="number">-1</span>);  <span class="comment">// 减去循环前的一段</span></span><br><span class="line">                <span class="keyword">int</span> index = n%cycle;  <span class="comment">//找到落在每个循环的 index  0 &lt;= index &lt;= cycle</span></span><br><span class="line">                n = (i<span class="number">-1</span>)<span class="number">-1</span> + index; <span class="comment">// 将 n 定位到循环中去</span></span><br><span class="line">                fall_in_cycle = cycle;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                hasShow[one][two] = i<span class="number">-1</span>; <span class="comment">// one 出现的 index</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 已经找到 n 的缩小值</span></span><br><span class="line">        one=two=<span class="number">1</span>;tmp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">3</span>;i&lt;=n;i++) &#123;</span><br><span class="line">            tmp = (a*two + b*one)%<span class="number">7</span>;  <span class="comment">// tmp = f(i)</span></span><br><span class="line">            one = two;                <span class="comment">// one = f(i-1)</span></span><br><span class="line">            two = tmp;                <span class="comment">// two = f(i)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2012-素数判断"><a href="#2012-素数判断" class="headerlink" title="2012-素数判断"></a>2012-素数判断</h2><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2012">原题链接</a></p><p>对于表达式n^2+n+41，当n在（x,y）范围内取整数值时（包括x,y）(-39&lt;=x&lt;y&lt;=50)，判定该表达式的值是否都为素数。</p><p>经典大素数判定问题，大一上的ACM选修课专门讲过…</p><p>如果我们对每一个数进行素数判断，而素数判断的复杂度又是 O(n)，那么复杂度就是 O(n^2)，而数据很大的情况绝对是超时的。所以我们采用填坑法，所有素数的倍数都不是素数，其他的数就是素数了，填坑法的复杂度只需要 O((logn)^2)，所以没被填的坑就是素数了，最后的判断就很简单了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.c</span></span><br><span class="line"><span class="comment">//  OJ-HD-2012</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by panliang on 2021/3/11.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> prime[<span class="number">2610</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initPrime</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    initPrime();</span><br><span class="line">    <span class="comment">// number = n^2+n+41</span></span><br><span class="line">    <span class="comment">// n = x ~ y</span></span><br><span class="line">    <span class="comment">// n is between 41 ~ 2591</span></span><br><span class="line">    <span class="keyword">int</span> x,y,n,number;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y) &amp;&amp;!(x==<span class="number">0</span>&amp;&amp;y==<span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">int</span> isPutSorry=<span class="number">0</span>;</span><br><span class="line">        n = x;</span><br><span class="line">        <span class="keyword">while</span>(n&lt;=y) &#123;</span><br><span class="line">            number = n*n+n+<span class="number">41</span>;</span><br><span class="line">            <span class="keyword">if</span> (!isPrime(number)) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Sorry\n&quot;</span>);</span><br><span class="line">                isPutSorry=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!isPutSorry)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;OK\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initPrime</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(prime,<span class="number">0</span>,<span class="keyword">sizeof</span>(prime));  <span class="comment">// 初始化为0 =&gt; 都是素数</span></span><br><span class="line">    <span class="comment">// 51*51 = 2601</span></span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">2</span>; <span class="comment">// 所有素数的倍数都不是素数</span></span><br><span class="line">    <span class="keyword">for</span> (;i&lt;=<span class="number">51</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> t=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (;t&lt;=i;t++) &#123;</span><br><span class="line">            prime[i*t] = <span class="number">1</span>;     <span class="comment">// 标记为1 =&gt; 不是素数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> prime[a]?<span class="number">0</span>:<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2025-查找最大元素"><a href="#2025-查找最大元素" class="headerlink" title="2025-查找最大元素"></a>2025-查找最大元素</h2><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2025">原题链接</a></p><p>对于输入的每个字符串，查找其中的最大字母，在该字母后面插入字符串“(max)”。</p><p>这是一个简单的 ascii 字符排序问题</p><p>处理输入的时候因为可能有空格，需要自己写一个 getLine()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.c</span></span><br><span class="line"><span class="comment">//  OJ-HD-2025</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by panliang on 2021/3/11.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getLine</span><span class="params">(<span class="keyword">char</span>*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> table[<span class="number">300</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">110</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        getLine(str);</span><br><span class="line">        <span class="keyword">if</span>(str[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">memset</span>(table,<span class="number">0</span>,<span class="keyword">sizeof</span>(table));</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (;i&lt;<span class="number">110</span>;i++) &#123;   <span class="comment">// 扫描输入字符串,打表</span></span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            table[str[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> maxchar = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">299</span>;i&gt;<span class="number">0</span>;i--)&#123;  <span class="comment">// 反向扫描table 找到 maxchar</span></span><br><span class="line">            <span class="keyword">if</span>(table[i] != <span class="number">0</span>)&#123;</span><br><span class="line">                maxchar = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">110</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[i] == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (str[i] == maxchar) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%c(max)&quot;</span>,str[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,str[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getLine</span><span class="params">(<span class="keyword">char</span> * str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">char</span> c = getchar();</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">&#x27;\n&#x27;</span> || c == EOF)&#123;</span><br><span class="line">            str[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        str[i++] = c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2058-The-sum-problem"><a href="#2058-The-sum-problem" class="headerlink" title="2058-The sum problem"></a>2058-The sum problem</h2><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2058">原题链接</a></p><p>给定一个序列 1，2，3，…N，你的工作是计算所有可能的子序列，子序列的和是M。</p><p>输入：N，M（ 1 &lt;= N, M &lt;= 1000000000 ）</p><p>需要输出所有可能的序列 [x,y] 使得 x+…+y = M</p><p>又是子序列和的题目，我第一反应就是用等差数列求和公式+滑动窗口来做，这样时间复杂度是O(n)，因为每次循环 a 和 b 都在单向移动，但是超时了。</p><p>这是滑动窗口的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n,m;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m) &amp;&amp; n+m)&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">1</span>,b=<span class="number">1</span>,sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(b&lt;n)&#123;</span><br><span class="line">      sum = (a+b)*(b-a+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span>(sum&lt;m)</span><br><span class="line">        b++;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(sum&gt;m)</span><br><span class="line">        a++;</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d,%d]&quot;</span>,a,b);</span><br><span class="line">        b++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>超时了之后我考虑优化滑动窗口。我想着让窗口从右往左滑动，这样窗口大小不会变小，想着这样可能不会有回溯的过程，，写了半天最后发现其实并没有提高效率，还是超时了。但是从窗口大小的角度思考让我得到了灵感！</p><p>假设有 n 个窗口能够满足序列和刚好是 M，那么这 n 个窗口的长度一定是越来越短的，因为窗口内的元素越来越大了</p><p>分析一下每个窗口应该是什么情况：</p><ul><li>如果这个窗口宽度为1，那么显然就是 M 本身，也就是输出 [M,M]</li><li>如果这个窗口宽度为2，那么显然是这样的：(M/2向下取整) + (M/2向上取整)</li><li>如果这个窗口宽度为3，那么显然是这样的：(M/3-1) + (M/3) + (M/3+1)</li><li>……</li></ul><p>显然窗口宽度和窗口内容是密切相关的</p><p>这样复杂度会显著降低了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.c</span></span><br><span class="line"><span class="comment">//  OJ-HD-2058</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by panliang on 2021/3/11.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxsize 200</span></span><br><span class="line"><span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">stack</span>[maxsize][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>[length][<span class="number">0</span>] = l;</span><br><span class="line">    <span class="built_in">stack</span>[length][<span class="number">1</span>] = r;</span><br><span class="line">    length++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isEmpty()) <span class="keyword">return</span>;</span><br><span class="line">    length--;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%d,%d]\n&quot;</span>,<span class="built_in">stack</span>[length][<span class="number">0</span>],<span class="built_in">stack</span>[length][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m) &amp;&amp; n &amp;&amp; m)&#123;</span><br><span class="line">        <span class="keyword">int</span> num=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(num&lt;m)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num%<span class="number">2</span> == <span class="number">1</span> &amp;&amp; m%num == <span class="number">0</span>)&#123;   <span class="comment">// num 为奇数 且能被m整除</span></span><br><span class="line">                <span class="keyword">int</span> center = m/num;</span><br><span class="line">                <span class="keyword">int</span> l = center-num/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(l&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> r = center+num/<span class="number">2</span>;</span><br><span class="line">                push(l,r);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(num%<span class="number">2</span> == <span class="number">0</span>)&#123;  <span class="comment">// num 为偶数</span></span><br><span class="line">                <span class="keyword">int</span> centerSmall = m/num;</span><br><span class="line">                <span class="keyword">int</span> l = centerSmall - num/<span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(l&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> r = centerSmall + num/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">int</span> sum = (l+r)*num/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(sum == m) push(l,r);</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// none</span></span><br><span class="line">            &#125;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!isEmpty())&#123;</span><br><span class="line">            pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了反过来输出结果，我写了一个栈。虽然对窗口大小由大到小遍历可以省略栈，但是会增加遍历的次数，窗口由小往大遍历的话我们就可以在 (这种情况) =&gt; {要从负数开始加到正数才等于M} 直接跳出循环，这时窗口更大是不可能了，窗口最左边已经到负数了，跳出循环可以显著降低循环次数。</p><p>这次终于AC了！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;刷刷OJ放松一下&quot;&gt;&lt;a href=&quot;#刷刷OJ放松一下&quot; class=&quot;headerlink&quot; title=&quot;刷刷OJ放松一下&quot;&gt;&lt;/a&gt;刷刷OJ放松一下&lt;/h1&gt;&lt;h2 id=&quot;1001-数列和&quot;&gt;&lt;a href=&quot;#1001-数列和&quot; class=&quot;head</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ML学习笔记-2</title>
    <link href="https://panlianghnu.github.io/2021/03/10/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/"/>
    <id>https://panlianghnu.github.io/2021/03/10/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/</id>
    <published>2021-03-10T07:10:34.000Z</published>
    <updated>2021-03-14T14:59:14.515Z</updated>
    
    <content type="html"><![CDATA[<p>学习算法可能有很多 feature、attribute</p><p>如何处理无穷多的 feature 而不爆内存，比如 support vector machine </p><p>监督学习就是对数据集标 label ，然后算法预测正确值</p><h1 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h1><h2 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h2><h3 id="聚类算法"><a href="#聚类算法" class="headerlink" title="聚类算法"></a>聚类算法</h3><p>聚类算法-clustering: 给许多没有label或相同label的数据，在data set 里面找到structure，分成几个 cluster，这就叫聚类算法</p><p>比如谷歌新闻每天收集成千上万的新闻，将他们组成一个个新闻专题，点击URL跳转到其他公司的网站</p><p>比如社交网络划分圈子，比如客户画像</p><blockquote><p>聚类算法和分类算法的比较</p><p>聚类分析是研究如何在没有训练的条件下把样本划分为若干类。<br>在分类中，对于目标数据库中存在哪些类是知道的，要做的就是将每一条记录分别属于哪一类标记出来。<br>聚类需要解决的问题是将已给定的若干无标记的模式聚集起来使之成为有意义的聚类，聚类是在<strong>预先不知道目标数据库到底有多少类</strong>的情况下，希望将所有的记录组成不同的类或者说聚类，并且使得在这种分类情况下，以某种度量（例如：距离）为标准的相似性，在同一聚类之间最小化，而在不同聚类之间最大化。<br>无监督学习不依赖预先定义的类或带类标记的训练实例，需要<strong>由聚类学习算法自动确定标记</strong></p><p>分类学习的实例或数据样本有类别标记。</p></blockquote><h3 id="鸡尾酒会问题"><a href="#鸡尾酒会问题" class="headerlink" title="鸡尾酒会问题"></a>鸡尾酒会问题</h3><p>两个人都在说话，传到两个距离不一的麦克风，用算法将叠加在一起的声音们分离出开。将多个音源的录音分离出声音。</p><p>吴恩达推荐 octave，作为机器学习编程环境</p><blockquote><p>矩阵乘法具有结合律但没有交换律</p><p>AxBxC = Ax(BxC)</p><p>AxB != BxA</p></blockquote><h2 id="多元线性回归"><a href="#多元线性回归" class="headerlink" title="多元线性回归"></a>多元线性回归</h2><h3 id="假设函数"><a href="#假设函数" class="headerlink" title="假设函数"></a>假设函数</h3><p><img src="/2021/03/10/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/image-20210311222721023.png" alt="image-20210311222721023"></p><p>x 是一个包含 features 的 vector，乘以各个待求系数的 vector，即为假设函数</p><h3 id="使用梯度下降解决多元线性回归"><a href="#使用梯度下降解决多元线性回归" class="headerlink" title="使用梯度下降解决多元线性回归"></a>使用梯度下降解决多元线性回归</h3><p><img src="/2021/03/10/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/image-20210311223151543.png" alt="image-20210311223151543"></p><p>不断地求 cost function 各个参数的偏导，然后向量减法调整参数的值</p><p><img src="/2021/03/10/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/image-20210311223225493.png" alt="image-20210311223225493"></p><p>怎么求偏导不重要，各种开源库</p><h3 id="特征缩放"><a href="#特征缩放" class="headerlink" title="特征缩放"></a>特征缩放</h3><p>假设x1是房屋面积(0~2000)，x2是卧室数量(0~5)</p><p>他们取值范围差别很大时，最终的梯度下降等高线会成为特别瘦长的椭圆，梯度下降会来回振荡(偏导可能不会指向 HIT )，下降的很慢</p><p><img src="/2021/03/10/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/image-20210311224754875.png" alt="image-20210311224754875"></p><p>尽量让 feature 的取值集中在 -1 ~ 1</p><p><img src="/2021/03/10/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/image-20210311224930834.png" alt="image-20210311224930834"></p><p>各个 feature 的数量级要一致</p><p>具体的操作为：</p><p><img src="/2021/03/10/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/image-20210311225057398.png" alt="image-20210311225057398"></p><p>特征缩放不需要很精确，只是让梯度下降快速一些</p><p>feature 的次方不同时，参数进行特征缩放很重要：</p><p><img src="/2021/03/10/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/image-20210311230909926.png" alt="image-20210311230909926"></p><h3 id="学习率选择"><a href="#学习率选择" class="headerlink" title="学习率选择"></a>学习率选择</h3><p>只要学习率足够小，cost function 会随着迭代不断下降，最终会收敛，但是算法效率会很慢</p><p>学习率太大，则可能不会每次 cost function 都下降，甚至无法收敛</p><h3 id="正规方程法（非迭代）"><a href="#正规方程法（非迭代）" class="headerlink" title="正规方程法（非迭代）"></a>正规方程法（非迭代）</h3><p>一次性求出参数的最佳值</p><p>算法：</p><p>cost function 是参数的 function，那么可以直接求出该 function 的最小值，以及 cost function 取最小时，参数等于多少。比如求导+令导数=0。或者求出所有偏导并令所有偏导等于0。偏微分可能很复杂</p><h2 id="梯度下降和正规方程法比较"><a href="#梯度下降和正规方程法比较" class="headerlink" title="梯度下降和正规方程法比较"></a>梯度下降和正规方程法比较</h2><p>梯度下降</p><ul><li><p>更普遍适用，即使有上百万 features 也可以正常运行</p></li><li><p>适合更复杂的学习算法</p></li></ul><p>正规方程法：</p><ul><li><p>不需要特征缩放，不需要选择学习率，不需要迭代，不用检查收敛，n 比较小时快得多</p></li><li><p>但是计算值的复杂度大概是 n^3，n 为 feature 数量，计算会比梯度下降慢很多，如果 n 大于万级，则不要使用正规方程法</p></li><li><p>不适合更复杂的学习算法，比如分类算法逻辑回归</p></li></ul><h2 id="向量化"><a href="#向量化" class="headerlink" title="向量化"></a>向量化</h2><p>计算假设函数时，使用向量有很多好处</p><p>模型预测的向量化</p><script type="math/tex; mode=display">h_\theta(x) = \sum_{j=0}^n \theta_j x_j \Rightarrow h_\theta(x) = \theta^Tx</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">prediction = <span class="number">0.0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    prediction = prediction + theta(i)*x(i)</span><br></pre></td></tr></table></figure><p>向量化后变成</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">theta = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">x = np.array([x1,x2,x3])</span><br><span class="line">prediction = np.matmul(theta.T, x) <span class="comment"># 转置巨震</span></span><br></pre></td></tr></table></figure><p>不需要自己写循环，而且更高效</p><p>Gradient descent 的向量化</p><p><img src="/2021/03/10/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/image-20210312165302732.png" alt="image-20210312165302732"></p><p>变成了简单的</p><script type="math/tex; mode=display">\theta = \theta - \alpha \delta</script><script type="math/tex; mode=display">\delta = \frac1m \sum_{i=1}^m (h_\theta x^{(i)}-y^{(i)})x^{(i)}</script><h2 id="逻辑回归-分类"><a href="#逻辑回归-分类" class="headerlink" title="逻辑回归(分类)"></a>逻辑回归(分类)</h2><p>最流行的学习算法</p><h3 id="二分类"><a href="#二分类" class="headerlink" title="二分类"></a>二分类</h3><p>比如可以简单的线性回归，设置一个阈值，大于输出1、小于输出0，但是这样做不准确，通常不是一个好主意，如图</p><p><img src="/2021/03/10/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/image-20210312171333206.png" alt="image-20210312171333206"></p><p>训练样本的错误率很高，无法很好拟合</p><p>逻辑回归：令 h(x) 处在0和1之间</p><script type="math/tex; mode=display">h_\theta(x) = g(\theta^Tx)</script><script type="math/tex; mode=display">g(z) = \frac1{1+e^{-z}}</script><p>这样就让 prediction 落在 [0,1] 了，function g is called logistics function</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;学习算法可能有很多 feature、attribute&lt;/p&gt;
&lt;p&gt;如何处理无穷多的 feature 而不爆内存，比如 support vector machine &lt;/p&gt;
&lt;p&gt;监督学习就是对数据集标 label ，然后算法预测正确值&lt;/p&gt;
&lt;h1 id=&quot;机器学习</summary>
      
    
    
    
    
    <category term="机器学习" scheme="https://panlianghnu.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>AOPEDF学习</title>
    <link href="https://panlianghnu.github.io/2021/03/03/AOPEDF%E5%AD%A6%E4%B9%A0/"/>
    <id>https://panlianghnu.github.io/2021/03/03/AOPEDF%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-03-03T11:26:04.000Z</published>
    <updated>2021-04-10T09:15:13.789Z</updated>
    
    <content type="html"><![CDATA[<h2 id="同构网络和异构网络"><a href="#同构网络和异构网络" class="headerlink" title="同构网络和异构网络"></a>同构网络和异构网络</h2><h3 id="同构网络"><a href="#同构网络" class="headerlink" title="同构网络"></a>同构网络</h3><p>同构网络：所有的节点有相同的 function，一个用户可以与下一个用户交换基本功能，比如，固定电话网络中，每个节点（电话）基本上执行与其他任何节点相同的功能，并且人们出于相同的原因使用电话。通常，电信网络是同构的。</p><h3 id="异构网络"><a href="#异构网络" class="headerlink" title="异构网络"></a>异构网络</h3><p>异构网络：节点不止有一个类别，按照功能和效用分成多个类别。比如，在HoneyBook市场网络中，活动策划和摄影师的行为就不一样，摄影师和花店的行为也不一样。eBay上的买方节点和卖方节点也不是同一个类，他们是异构网络。</p><h2 id="实验复现"><a href="#实验复现" class="headerlink" title="实验复现"></a>实验复现</h2><h3 id="BUG1"><a href="#BUG1" class="headerlink" title="BUG1"></a>BUG1</h3><p>K-Fold交叉验证，参数多了一个 label[:,0]，n_folds 参数找不到（应该是 n_splits ?）</p><p><img src="/2021/03/03/AOPEDF%E5%AD%A6%E4%B9%A0/image-20210303192653242.png" alt="image-20210303192653242"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, n_splits=<span class="string">&#x27;warn&#x27;</span>, shuffle=<span class="literal">False</span>, random_state=<span class="literal">None</span></span>):</span></span><br><span class="line">  <span class="keyword">if</span> n_splits == <span class="string">&#x27;warn&#x27;</span>:</span><br><span class="line">    warnings.warn(NSPLIT_WARNING, FutureWarning)</span><br><span class="line">    n_splits = <span class="number">3</span></span><br><span class="line">    <span class="built_in">super</span>(StratifiedKFold, self).__init__(n_splits, shuffle, random_state)</span><br></pre></td></tr></table></figure><p>论文</p><h2 id="introduction"><a href="#introduction" class="headerlink" title="introduction"></a>introduction</h2><p>识别DTI在药物发现领域很重要</p><blockquote><p>药物发现已成为药物研发体系必不可少的技术之一，尤其是针对罕见病治疗药物和 神经保护药物的研发。考虑到体外实验昂贵且耗时，高效计算预测方法可以作为药物发 现的有效策略。在生物大数据的推动下，新一代基于网络分析方法的理性药物预测筛选 技术体系正在快速形成。系统地识别已知药物的分子靶点对于药物的开发和了解其意想 不到的副作用起着至关重要的作用。与传统的实验分析方法相比，预测药物-靶点相互作 用(DTI)的计算方法是非常理想的。此外，多组学技术和系统生物学方法的最新进展产 生了大规模的异质生物网络，为基于网络的已知药物新分子靶点的识别提供了意想不到 的机会。</p></blockquote><p>实验预测DTI费时费力，目前有几种通过计算机辅助DTI预测的方法：</p><ol><li><p>基于蛋白质结构的</p><p>基于蛋白质结构的方法通常需要蛋白质的三维结构，对于结构未知的蛋白质性能有限，然而结构未知才是大多数靶点的情况。</p></li><li><p>基于配体的</p><p>利用已知相互作用配体的常识进行预测，但是这种情况如果参考配体库中没有指明感兴趣 的化合物，这种方法就不能得到可靠的预测结果。</p></li><li><p>基于机器学习的</p><p>充分挖 掘了药物和靶点相关特征之间的潜在相关性，成为 DTI 预测的一种非常有前景的策略</p></li></ol><p>除了已知的 DTI 数据外，药物和靶点的化学结构、蛋白质序列信息和其他特性也可 以通过其在生物系统中的各种功能作用来表征(例如蛋白质之间的相互作用和药物-疾病 关联)。事实上，通过整合来自不同数据源的不同信息，DTINet、MSCMF 和 HNM 等方法可以进一步提高 DTI 预测的准确性。然而，这些方法仍有一些局限性需要解决。</p><p>例如，在 MSCMF 中，给定 DTI 网络所采用的矩阵分解操作通过相应的药物和蛋白质 相似性矩阵进行正则化，这些矩阵是通过加权平均方案整合多个数据源获得的。在这种数据集成策略下，可能会发生大量信息丢失，从而导致次优解决方案。而 DTINet 首先使 用无监督的方式从异构网络数据源中自动学习药物和靶点的低维特征表示，然后应用归 纳矩阵完成法基于所学习的特征预测新的 DTI。在这样一个框架中，将特征学习与手头 的预测任务分离可能不会产生最优解，因为从无监督学习过程中学习的特征可能不是药 物或目标的最合适的表示，不适合最终的 DTI 预测任务。此外，通过限制学习模型仅采 用相对简单的形式(例如双线性或对数双线性函数)，这些方法可能不足以捕获异构网络 数据背后复杂的隐藏特征。</p><p>将传统卷积神经网络(CNN)推广到大规模图形数据的信息传递和聚合技术的最新进 展表明，与网络相关的预测任务的性能得到了显著改善。这启发我们结合更深层次的学 习模型，从一个高层次的异构网络数据源中提取复杂的信息，并发现新的 DTI。</p><h2 id="Materials-and-methods"><a href="#Materials-and-methods" class="headerlink" title="Materials and methods"></a>Materials and methods</h2><h3 id="Data-resource"><a href="#Data-resource" class="headerlink" title="Data resource"></a>Data resource</h3><p><code>DTI information</code> from DrugBank database、therapeutic target database、PharmGKB database.</p><p><code>bioactivity(生物活性) data for drug–target pairs</code> from ChEMBL、BindingDB、IUPHAR/BPS Guide to PHARMACOLOGY.</p><p><code>chemical structure of each drug</code> from DrugBank.</p><p>DTI 需要满足以下三个条件才会被采纳：</p><ol><li>the human target is represented by a unique UniProt accession number</li><li>the target is marked as ‘reviewed’ in the UniProt database</li><li>结合亲和力，包括Ki、Kd、IC50或EC50都&lt;=10 uM。我们使用低结合亲和力截止值10 lM，因为弱结合药物在治疗发展中也起着至关重要的作用</li></ol><p>DTI网络连接了732种FDA批准的药物和1519种独特的人类靶点（蛋白质）</p><p>我们随机选择了未知药物-靶点对的匹配数（排除所有已知DTI）作为 negative samples</p><p>此外，我们还构建了<code>九个药物网络</code></p><ol><li>临床报告的药物-药物相互作用</li><li>药物-疾病联系</li><li>药物-副作用联系</li><li>化学相似性</li><li>来自解剖治疗化学分类系统的治疗相似性</li><li>靶序列衍生药物-药物相似性</li><li>基因本体生物学过程</li><li>基因本体细胞成分</li><li>基因本体分子功能</li></ol><p><code>六个蛋白质网络</code></p><ol><li>蛋白质-蛋白质相互作用</li><li>蛋白质-疾病联系</li><li>蛋白质序列相似性</li><li>基因本体生物学过程</li><li>基因本体细胞成分</li><li>基因本体分子功能</li></ol><p>The detailed description for building 15 networks is provided in the <a href="/Users/panliang/Documents/湖南大学/本科/毕业设计/论文/btaa010_supplementary_data.pdf">SUPPLEMENTARY Methods</a> </p><p>对于外部验证集，我们从DrugCentral数据库（Ursu et al.，2019）和ChEMBL数据库（Mendez et al.，2019）中通过排除训练集中重叠的药物-靶点对来组装最新的实验验证DTI。</p><p>分别来自DrugCentral和ChEMBL数据库的两个验证集之间存在部分重叠</p><p>训练集和两个外部验证集之间没有任何重叠的dti。</p><hr><h3 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h3><p>As shown in Fig 1. AOPEDF 包括三个步骤</p><ol><li>data preparation and benchmarking</li><li>保留任意阶相似度的网络嵌入（AROPE）</li><li>基于森林的深度DTI预测</li></ol><p>首先整合15个网络，来组建一个复杂的异构网络，包含了各种信息、多个视角来预测新的DTI</p><p>然后我们保留每个网络的任意阶相似度去获取信息，用低维度的向量去表征药物和靶点</p><p>最后我们可以用深度森林分类器去预测潜在的DTIs</p><h4 id="AROPE"><a href="#AROPE" class="headerlink" title="AROPE"></a>AROPE</h4><h4 id="Deep-forest-algorithm"><a href="#Deep-forest-algorithm" class="headerlink" title="Deep forest algorithm"></a>Deep forest algorithm</h4><p>学习了药物和靶点的低维度向量表示之后，我们利用深度森林来进行预测，这为DNNs提供了一种以较低的计算代价学习超层次表示的方法。</p><p>DNNs中会使用分层处理原始特征，受DNNs影响，Deep forest 采用级联结构，每一层级收到的 feature information 都是被上一层处理过的，然后处理这些 feature information 后将 result 输出到下一层级</p><p>每一层都是决策树林的集合，例如集合的集合。多样性是集成构建的关键。</p><p>在此，我们使用</p><ol><li>two random forests (RFs)</li><li>two completely random tree forests</li><li>two gradient boosting tree forests</li></ol><p>每个 forests 包括500 trees，总共3000 trees</p><p>比如，每个森林会产生一个 class distribution (概率分布？) 的估计值，计算相关实例所在叶节点上不同类的训练实例的百分比，然后在同一林中的所有树上求平均值。</p><blockquote><p>例如，每个森林将通过计算相关实例所在叶节点上不同类的训练实例的百分比，然后对同一森林中的所有树进行平均，从而产生类分布的估计</p></blockquote><p>估计的类分布形成类向量，然后将其与原始特征向量串联以输入到级联的下一级（图1）。</p><p>这里，在二元分类中有两个类，六个森林中的每一个产生一个2D分类向量。总的来说，级联的下一级将接收12(2*6)个增强特征。</p><p>为了减少过度拟合的风险，每个森林产生的类向量通过k-折叠交叉验证（k1⁄45）生成。</p><p>具体而言，每个森林将用作训练 k-1 次数据，产生 k-1 个分类向量，然后将这些分类向量平均得到最终的分类向量，作为下一级级联的增强 features</p><p>在扩展到一个新的层级后，整个级联的性能将在验证集上估计，如果没有显著的性能增益，训练过程将终止，随后，自动确定层叠层数。</p><p>deepforest采用基于滑动窗口的多粒度扫描策略，通过扫描原始输入来提取局部特征，生成一系列局部低维特征向量。</p><p>然后利用这些低维向量训练一系列森林，得到输入向量的类分布。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;同构网络和异构网络&quot;&gt;&lt;a href=&quot;#同构网络和异构网络&quot; class=&quot;headerlink&quot; title=&quot;同构网络和异构网络&quot;&gt;&lt;/a&gt;同构网络和异构网络&lt;/h2&gt;&lt;h3 id=&quot;同构网络&quot;&gt;&lt;a href=&quot;#同构网络&quot; class=&quot;headerli</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Vue学习1</title>
    <link href="https://panlianghnu.github.io/2021/03/02/Vue%E5%AD%A6%E4%B9%A01/"/>
    <id>https://panlianghnu.github.io/2021/03/02/Vue%E5%AD%A6%E4%B9%A01/</id>
    <published>2021-03-02T08:07:04.000Z</published>
    <updated>2021-03-25T08:42:18.990Z</updated>
    
    <content type="html"><![CDATA[<h1 id="VueJs"><a href="#VueJs" class="headerlink" title="VueJs"></a>VueJs</h1><h2 id="声明式渲染"><a href="#声明式渲染" class="headerlink" title="声明式渲染"></a>声明式渲染</h2><p>Vue 应用会将其挂载到一个 DOM 元素(比如DIV) 上，然后对其完全控制</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; message &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: <span class="string">&#x27;Hello Vue!&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>结果显示 Hello Vue！</p><p>不仅可以绑定到 DOM 的文本或 attribute，还可以绑定到 DOM 结构：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">&quot;seen&quot;</span>&gt;</span>可以看到吗<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;app.$data.seen=!app.$data.seen&quot;</span>&gt;</span>切换可见<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    seen: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当一个 Vue 实例被创建时，它将 <code>data</code> 对象中的所有的 property 加入到 Vue 的<strong>响应式系统</strong>中。当这些 property 的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。</p><p>当这些数据改变时，视图会进行重渲染。只有当 Vue 实例被创建时就已经存在于 <code>data</code> 中的 property 才是<strong>响应式</strong>的。也就是说如果你添加一个新的 property，比如：vm.newdata = ‘new’ ，则对 newdata 不触发渲染。如果你知道你会在晚些时候需要一个 property，但是一开始它为空或不存在，那么你仅<strong>需要设置一些初始值</strong>。data:{ newdata: ‘’ }</p><p>唯一的例外是使用 <code>Object.freeze()</code>，这会阻止修改现有的 property，也意味着响应系统无法再<em>追踪</em>变化。</p><p>Vue 实例还暴露了一些有用的实例 property 与方法，都以$开头，和用户自定义的 property 和 methods 区分：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#example&#x27;</span>,</span><br><span class="line">  data: data</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">vm.$data === data <span class="comment">// =&gt; true</span></span><br><span class="line">vm.$el === <span class="built_in">document</span>.getElementById(<span class="string">&#x27;example&#x27;</span>) <span class="comment">// =&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// $watch 是一个实例方法</span></span><br><span class="line">vm.$watch(<span class="string">&#x27;a&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">newValue, oldValue</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这个回调将在 `vm.a` 改变后调用</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="实例生命周期钩子-hook"><a href="#实例生命周期钩子-hook" class="headerlink" title="实例生命周期钩子(hook)"></a>实例生命周期钩子(hook)</h2><p><img src="/2021/03/02/Vue%E5%AD%A6%E4%B9%A01/lifecycle.png" alt="lifecycle"></p><p><img src="/2021/03/02/Vue%E5%AD%A6%E4%B9%A01/image-20210302163430490.png" alt="image-20210302163430490"></p><p>注意⚠️：钩子函数不要写成 ()=&gt;{} ，箭头函数没有 this</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>Vue.js 使用了基于 HTML 的模板语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。所有 Vue.js 的模板都是合法的 HTML，所以能被遵循规范的浏览器和 HTML 解析器解析。</p><p>在底层的实现上，<strong>Vue 将模板编译成虚拟 DOM 渲染函数</strong>。结合响应系统，Vue 能够<strong>智能地计算出最少需要重新渲染多少组件</strong>，并把 DOM 操作次数减到最少。</p><h3 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h3><h4 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h4><p>数据绑定最常见的形式就是使用“Mustache”语法 (双大括号) 的文本插值：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Message: &#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>无论何时，绑定的数据对象上 <code>msg</code> property 发生了改变，插值处的内容都会更新。</p><h4 id="原始-HTML"><a href="#原始-HTML" class="headerlink" title="原始 HTML"></a>原始 HTML</h4> 表达式会将 rawHtml 的值解析为文本，如果你希望它输出为 HTML，需要使用 v-html 指令：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data:&#123;<span class="attr">hello</span>:<span class="string">&quot;&lt;p style=&quot;</span>color:red<span class="string">&quot;&gt;hello&lt;/p&gt;&quot;</span>&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;hello&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-html</span>=<span class="string">&quot;hello&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>显示效果为:</p><p>\</p><p style="color:red">hello\</p><p></p><p style="color:red">hello</p><p>这个 <code>span</code> 的内容将会被替换成为 property 值 <code>hello</code>，直接作为 HTML——会忽略解析 property 值中的数据绑定。</p><blockquote><p>你的站点上动态渲染的任意 HTML 可能会非常危险，因为它很容易导致 <a href="https://en.wikipedia.org/wiki/Cross-site_scripting">XSS 攻击</a>。请只对可信内容使用 HTML 插值，<strong>绝不要</strong>对用户提供的内容使用插值。</p></blockquote><h4 id="Attribute"><a href="#Attribute" class="headerlink" title="Attribute"></a>Attribute</h4><p>Mustache 语法不能作用在 HTML attribute 上，需要使用 v-bind 指令</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">&quot;dynamicId&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>    <span class="comment">&lt;!-- 正确 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#123;&#123;dynamicId&#125;&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>         <span class="comment">&lt;!-- 错误 --&gt;</span></span><br></pre></td></tr></table></figure><h4 id="使用-JavaScript-表达式"><a href="#使用-JavaScript-表达式" class="headerlink" title="使用 JavaScript 表达式"></a>使用 JavaScript 表达式</h4><p>可以这样绑定 JS 的表达式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; number + 1 &#125;&#125;</span><br><span class="line">&#123;&#123; ok ? &#x27;YES&#x27; : &#x27;NO&#x27; &#125;&#125;  // 不要用 if()&#123;&#125;</span><br><span class="line">&#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">&quot;&#x27;list-&#x27; + id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>模板表达式都被放在沙盒中，只能访问<strong>全局变量的一个白名单</strong>，如 <code>Math</code> 和 <code>Date</code> 。你不应该在模板表达式中试图访问用户定义的全局变量。</p></blockquote><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p>指令 (Directives) 是带有 <code>v-</code> 前缀的特殊 attribute。指令 attribute 的值预期是单个表达式，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。</p><p>比如 v-if=”seen” ，当 seen 为 false，该 DOM 对象不会显示</p><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>一些指令能接受一个参数，在指令名称后以冒号表示。</p><p>比如 v-bind 指令：可以响应式更新 HTML attribute</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>比如 v-on 指令：用于监听  DOM 事件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span> </span><br><span class="line">// 鼠标点击会触发 vue 对象的 methods:dosomething()</span><br></pre></td></tr></table></figure><h4 id="动态参数"><a href="#动态参数" class="headerlink" title="动态参数"></a>动态参数</h4><blockquote><p>2.6.0 新增</p></blockquote><p>从 2.6.0 开始，可以用方括号括起来的 JavaScript 表达式作为一个指令的参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">注意，参数表达式的写法存在一些约束，如之后的“对动态参数表达式的约束”章节所述。</span><br><span class="line">--&gt;</span><br><span class="line">&lt;a v-bind:[attributeName]&#x3D;&quot;url&quot;&gt; ... &lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure><p>这里的 <code>attributeName</code> 会被作为一个 JavaScript 表达式进行动态求值，求得的值将会作为最终的参数来使用。例如，如果你的 Vue 实例有一个 <code>data</code> property <code>attributeName</code>，其值为 <code>&quot;href&quot;</code>，那么这个绑定将等价于 <code>v-bind:href</code>。</p><p>同样地，你可以使用动态参数为一个动态的事件名绑定处理函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a v-on:[eventName]&#x3D;&quot;doSomething&quot;&gt; ... &lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure><p>在这个示例中，当 <code>eventName</code> 的值为 <code>&quot;focus&quot;</code> 时，<code>v-on:[eventName]</code> 将等价于 <code>v-on:focus</code>。</p><p>在 DOM 中使用模板时 (直接在一个 HTML 文件里撰写模板)，还需要避免使用大写字符来命名键名，因为浏览器会把 attribute 名全部强制转为小写：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">在 DOM 中使用模板时这段代码会被转换为 `v-bind:[someattr]`。</span></span><br><span class="line"><span class="comment">除非在实例中有一个名为“someattr”的 property，否则代码不会工作。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:</span>[<span class="attr">someAttr</span>]=<span class="string">&quot;value&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><h3 id="缩写"><a href="#缩写" class="headerlink" title="缩写"></a>缩写</h3><p><code>v-</code> 前缀作为一种视觉提示，用来识别模板中 Vue 特定的 attribute。</p><p>Vue 为 <code>v-bind</code> 和 <code>v-on</code> 这两个最常用的指令，提供了特定简写：</p><h4 id="v-bind-缩写"><a href="#v-bind-缩写" class="headerlink" title="v-bind 缩写"></a>v-bind 缩写</h4><p>直接省略 v-bind。以冒号开头即可</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 完整语法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 缩写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:</span>[<span class="attr">key</span>]=<span class="string">&quot;url&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="v-on-缩写"><a href="#v-on-缩写" class="headerlink" title="v-on 缩写"></a>v-on 缩写</h4><p>直接省略 v-on。以 @ 开头即可</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 完整语法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 缩写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> @<span class="attr">click</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> @[<span class="attr">event</span>]=<span class="string">&quot;doSomething&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2>、但是不应该在模版内放入复杂逻辑，这时候应该在模板内放入“计算属性”，同样能达到数据变化=>计算属性变化=>重渲染计算属性：实例化 Vue 对象时，增加 computed: {}，写入对应的“计算属性”的 function 作为该属性的 getter()注意⚠️，computed 和 methods 是不一样的，computed 是作为 getter 函数并会响应式渲染<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Original message: &quot;&#123;&#123; message &#125;&#125;&quot;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Computed reversed message: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#example&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: <span class="string">&#x27;Hello&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    <span class="comment">// 计算属性的 getter</span></span><br><span class="line">    reversedMessage: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// `this` 指向 vm 实例</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.message.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在这个例子中，message 发生变化则会触发 reversedMessage 的变化，message 和 reversedMessage 的绑定在 Vue 对象初始化时进行。</p><blockquote><p>你可以像绑定普通 property 一样在模板中绑定计算属性。Vue 知道 <code>vm.reversedMessage</code> 依赖于 <code>vm.message</code>，因此当 <code>vm.message</code> 发生改变时，所有依赖 <code>vm.reversedMessage</code> 的绑定也会更新。而且最妙的是我们已经以声明的方式创建了这种依赖关系：计算属性的 getter 函数是没有副作用 (side effect) 的，这使它更易于测试和理解。</p></blockquote><h3 id="计算属性-vs-方法"><a href="#计算属性-vs-方法" class="headerlink" title="计算属性 vs 方法"></a>计算属性 vs 方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  reversedMessage: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.message.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做最终显示出来的结果是完全相同的。</p><p>但是性能有差别：</p><p>计算属性是有响应式缓存的，当依赖没有变化的时候，多次访问 reversedMessage 会立刻返回之前的计算结果，而不会再次执行函数。</p><p>相比之下，每当触发重新渲染时，调用方法将<strong>总会</strong>再次执行函数。</p><blockquote><p>我们为什么需要缓存？假设我们有一个性能开销比较大的计算属性 <strong>A</strong>，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 <strong>A</strong>。如果没有缓存，我们将不可避免的多次执行 <strong>A</strong> 的 getter！如果你不希望有缓存，请用方法来替代。</p></blockquote><h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h2><p>v-if 条件渲染元素，可以配合 v-else-if、v-else 使用</p><p>v-show 和 v-if 基本一样，都能控制元素是否显示</p><p>v-if 是真正的条件渲染，是惰性的。而 v-show 是始终渲染，只简单的 CSS 切换 display</p><p>v-if 的切换开销更大，初始化开销更小</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;seen=!seen&quot;</span>&gt;</span>切换可见<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">&quot;seen&quot;</span>&gt;</span>可以看到吗<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    seen: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="循环渲染-事件"><a href="#循环渲染-事件" class="headerlink" title="循环渲染/事件"></a>循环渲染/事件</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;todo in todos&quot;</span>&gt;</span>&#123;&#123;todo.text&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;reverseList&quot;</span>&gt;</span>反转<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    todos: [</span><br><span class="line">      &#123; <span class="attr">text</span>: <span class="string">&#x27;学习 javascript&#x27;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">text</span>: <span class="string">&#x27;学习 Vue&#x27;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">text</span>: <span class="string">&#x27;学习前端&#x27;</span> &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    reverseList: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> str <span class="keyword">in</span> app.todos) &#123;</span><br><span class="line">        app.todos[str].text = </span><br><span class="line">          app.todos[str].text.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在控制台可以输入 app.todos.push({ text:’hello world’ }) 可以看到渲染是实时的</p><p>反转按钮会触发 v-on:click 事件，对 List 的所有元素 reverse</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;VueJs&quot;&gt;&lt;a href=&quot;#VueJs&quot; class=&quot;headerlink&quot; title=&quot;VueJs&quot;&gt;&lt;/a&gt;VueJs&lt;/h1&gt;&lt;h2 id=&quot;声明式渲染&quot;&gt;&lt;a href=&quot;#声明式渲染&quot; class=&quot;headerlink&quot; title=&quot;声明式</summary>
      
    
    
    
    
    <category term="Vue" scheme="https://panlianghnu.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>简单树形P2P网络实现</title>
    <link href="https://panlianghnu.github.io/2021/02/19/%E7%AE%80%E5%8D%95%E6%A0%91%E5%BD%A2P2P%E7%BD%91%E7%BB%9C%E5%AE%9E%E7%8E%B0/"/>
    <id>https://panlianghnu.github.io/2021/02/19/%E7%AE%80%E5%8D%95%E6%A0%91%E5%BD%A2P2P%E7%BD%91%E7%BB%9C%E5%AE%9E%E7%8E%B0/</id>
    <published>2021-02-19T04:36:20.000Z</published>
    <updated>2021-03-19T15:26:36.654Z</updated>
    
    <content type="html"><![CDATA[<p>树形结构：</p><p>先写一个种子文件，种子文件里是一个根节点的URL（单点故障）<del>后面可以改成多个节点们</del></p><p>新的客户端接入该 P2P 网络</p><ul><li>先读取种子文件，找到根节点</li><li>根节点给客户端分配一个（多个）节点，并给其一个ID</li><li>客户端连接上这些节点</li><li>客户端监听 http、p2p 端口 <em>自己设置</em>，并告诉根节点</li></ul><p>根节点维护全局节点的信息，普通节点维护相连的节点的信息</p><p>每个节点退出时，向根节点发送退出消息，根节点维护节点列表</p><p>我写的比较简单，根节点只维护了node_ID列表，但是这样会有bug</p><ul><li>某个节点退出时，删除了该节点的子节点而子节点并未结束程序，新的子节点到来，旧的子节点结束时又发送退出消息，这个时候根节点会错误的将新来的子节点也删除。</li><li><p>bug出现原因：node_ID不能唯一标识节点</p></li><li><p>解决方法：根节点不止维护node_ID，还维护每个节点的端口号，因为端口号是向操作系统随机申请的，可以认为唯一代表某个节点，或者我们可以在节点申请getPeer的时候记录时间，用时间唯一标识节点，将维护一个node_ID列表变成维护一个time列表，可以fix这个bug，但是我懒得写了…</p></li></ul><p>测试</p><p>还是一样的 访问 http/ping</p><p>每个节点会把 “I am alive” 发送给相邻节点  =》根节点会收到所有节点的消息</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;树形结构：&lt;/p&gt;
&lt;p&gt;先写一个种子文件，种子文件里是一个根节点的URL（单点故障）&lt;del&gt;后面可以改成多个节点们&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;新的客户端接入该 P2P 网络&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先读取种子文件，找到根节点&lt;/li&gt;
&lt;li&gt;根节点给客户端分配一个（</summary>
      
    
    
    
    
    <category term="nodejs" scheme="https://panlianghnu.github.io/tags/nodejs/"/>
    
    <category term="P2P" scheme="https://panlianghnu.github.io/tags/P2P/"/>
    
  </entry>
  
  <entry>
    <title>基于WebSocket的聊天室</title>
    <link href="https://panlianghnu.github.io/2021/02/04/%E5%9F%BA%E4%BA%8EWebSocket%E7%9A%84%E8%81%8A%E5%A4%A9%E5%AE%A4/"/>
    <id>https://panlianghnu.github.io/2021/02/04/%E5%9F%BA%E4%BA%8EWebSocket%E7%9A%84%E8%81%8A%E5%A4%A9%E5%AE%A4/</id>
    <published>2021-02-04T01:57:56.000Z</published>
    <updated>2021-03-14T14:59:57.523Z</updated>
    
    <content type="html"><![CDATA[<p>源码见：<a href="https://github.com/panlianghnu/WebSocketChat">github</a></p><h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><h3 id="使用-‘express’-封装-http-请求，监听7777端口，返回前端页面"><a href="#使用-‘express’-封装-http-请求，监听7777端口，返回前端页面" class="headerlink" title="使用 ‘express’ 封装 http 请求，监听7777端口，返回前端页面"></a>使用 ‘express’ 封装 http 请求，监听7777端口，返回前端页面</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)()    <span class="comment">// 封装 http </span></span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>,<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">res.sendFile(__dirname + <span class="string">&#x27;/chat.html&#x27;</span>)   <span class="comment">// 返回页面</span></span><br><span class="line">&#125;)</span><br><span class="line">app.listen(<span class="number">7777</span>,<span class="string">&#x27;localhost&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="使用-nodejs-websocket-工具包处理聊天，监听8888端口"><a href="#使用-nodejs-websocket-工具包处理聊天，监听8888端口" class="headerlink" title="使用 nodejs-websocket 工具包处理聊天，监听8888端口"></a>使用 nodejs-websocket 工具包处理聊天，监听8888端口</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ws = <span class="built_in">require</span>(<span class="string">&#x27;nodejs-websocket&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> server = ws.createServer(<span class="function">(<span class="params">socket</span>) =&gt;</span> &#123;    <span class="comment">// 处理聊天</span></span><br><span class="line"><span class="keyword">var</span> username = socket.path</span><br><span class="line"><span class="built_in">console</span>.log(username + <span class="string">&#x27; 加入群聊&#x27;</span>)</span><br><span class="line">clientList.push(socket)</span><br><span class="line">broadcast(username + <span class="string">&#x27; 加入群聊&#x27;</span>)</span><br><span class="line"></span><br><span class="line">socket.on(<span class="string">&#x27;text&#x27;</span>,<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(username + <span class="string">&#x27;: &#x27;</span>+data)</span><br><span class="line">broadcast(username + <span class="string">&#x27;: &#x27;</span> + data)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">socket.on(<span class="string">&#x27;close&#x27;</span>,<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(username + <span class="string">&#x27; 退出群聊&#x27;</span>)</span><br><span class="line">deleteSocketFromList(socket)</span><br><span class="line">broadcast(username + <span class="string">&#x27; 退出群聊&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;).listen(<span class="number">8888</span>)</span><br></pre></td></tr></table></figure><p>客户端刚连接服务器时，服务器会用链表 clientList 保存这个 socket 连接，并进行广播 “xxx加入群聊”。</p><p>设置了两个事件</p><ul><li>text 事件，客户端向服务器发送消息时触发<ul><li>服务器向所有客户端广播该消息</li></ul></li><li>close 事件，客户端失去连接时触发<ul><li>服务器删除该 socket 对象，并广播给其他客户端</li></ul></li></ul><h3 id="广播的实现"><a href="#广播的实现" class="headerlink" title="广播的实现"></a>广播的实现</h3><p>遍历 socket ，调用 send 发送消息</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">broadcast</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;clientList.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(clientList[i] !== <span class="literal">null</span>)&#123;</span><br><span class="line">clientList[i].send(data)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><h3 id="定义-url-和-ws-对象"><a href="#定义-url-和-ws-对象" class="headerlink" title="定义 url 和 ws 对象"></a>定义 url 和 ws 对象</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">&quot;ws://localhost:8888/&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> ws = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h3 id="加入群聊，即初始化-websocket-对象，并绑定事件"><a href="#加入群聊，即初始化-websocket-对象，并绑定事件" class="headerlink" title="加入群聊，即初始化 websocket 对象，并绑定事件"></a>加入群聊，即初始化 websocket 对象，并绑定事件</h3><p>username 通过用户输入，调用 document.getElementById 得到内容</p><p>直接在连接时的 url 字符串后面拼接 username，后端识别 path 得到用户名</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">joinRoom</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ws) &#123;</span><br><span class="line">    alert(<span class="string">&quot;你已经在聊天室，不能再加入&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> username = <span class="built_in">document</span>.getElementById(<span class="string">&quot;user&quot;</span>).value;</span><br><span class="line">  ws = <span class="keyword">new</span> WebSocket(url + username);</span><br><span class="line">  <span class="comment">//与服务端建立连接触发</span></span><br><span class="line">  ws.onopen = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;与服务器成功建立连接&quot;</span>)</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//服务端推送消息触发</span></span><br><span class="line">  ws.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">ev</span>) </span>&#123;</span><br><span class="line">    talking(ev.data);     <span class="comment">// 接收数据，刷新页面</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//发生错误触发</span></span><br><span class="line">  ws.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;连接错误&quot;</span>)</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//正常关闭触发</span></span><br><span class="line">  ws.onclose = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;连接关闭&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendMsg</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!ws)&#123;</span><br><span class="line">    alert(<span class="string">&quot;你已掉线，请重新加入&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//消息发送</span></span><br><span class="line">  ws.send(<span class="built_in">document</span>.getElementById(<span class="string">&quot;sendMsg&quot;</span>).value);</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&quot;sendMsg&quot;</span>).value = <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先判断是否已经初始化 websocket 对象</p><h3 id="接收数据，刷新页面"><a href="#接收数据，刷新页面" class="headerlink" title="接收数据，刷新页面"></a>接收数据，刷新页面</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">talking</span>(<span class="params">content</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&quot;content&quot;</span>).append(content + <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">content 是一个 &lt;textarea/&gt; 对象</span><br></pre></td></tr></table></figure><h3 id="GUI"><a href="#GUI" class="headerlink" title="GUI"></a>GUI</h3><p><img src="/2021/02/04/%E5%9F%BA%E4%BA%8EWebSocket%E7%9A%84%E8%81%8A%E5%A4%A9%E5%AE%A4/image-20210219103207635.png" alt="image-20210219103207635"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;源码见：&lt;a href=&quot;https://github.com/panlianghnu/WebSocketChat&quot;&gt;github&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;后端&quot;&gt;&lt;a href=&quot;#后端&quot; class=&quot;headerlink&quot; title=&quot;后端&quot;&gt;&lt;/a&gt;后端&lt;</summary>
      
    
    
    
    
    <category term="websocket" scheme="https://panlianghnu.github.io/tags/websocket/"/>
    
    <category term="聊天室" scheme="https://panlianghnu.github.io/tags/%E8%81%8A%E5%A4%A9%E5%AE%A4/"/>
    
  </entry>
  
  <entry>
    <title>ML学习笔记-1</title>
    <link href="https://panlianghnu.github.io/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/"/>
    <id>https://panlianghnu.github.io/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/</id>
    <published>2021-01-03T08:45:14.000Z</published>
    <updated>2021-03-14T14:59:21.364Z</updated>
    
    <content type="html"><![CDATA[<h1 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h1><p>机器学习就是让机器自动找函数</p><p><img src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210101104434728.png" alt="image-20210101104434728"></p><p>Regression：输出数值</p><p>Classification：二分类、多类分类</p><p>Generation：生成有复杂结构的东西（如翻译，画二次元头像）</p><h2 id="如何告诉机器，想要什么样的函数"><a href="#如何告诉机器，想要什么样的函数" class="headerlink" title="如何告诉机器，想要什么样的函数"></a>如何告诉机器，想要什么样的函数</h2><p>Supervised learning  有监督学习，对每个 input，给出一个标准 output，需要对资料做 label</p><p>机器就可以对生成的函数做一个评估，有一个 loss function，用来计算 function 的好坏</p><p>Reinforcement learning  强化学习，比如阿尔法狗，让机器和自己、别人下棋，然后赢了，机器会知道这样下比较好，哪几步比较好还不是很清楚</p><blockquote><p>强化学习是智能体（Agent）以“试错”的方式进行学习，通过与环境进行交互获得的奖赏指导行为，目标是使智能体获得最大的奖赏，强化学习不同于连接主义学习中的监督学习，主要表现在强化信号上，强化学习中由环境提供的强化信号是对产生动作的好坏作一种评价(通常为标量信号)，而不是告诉强化学习系统RLS(reinforcement learning system)如何去产生正确的动作。由于外部环境提供的信息很少，RLS必须靠自身的经历进行学习。通过这种方式，RLS在行动-评价的环境中获得知识，改进行动方案以适应环境。</p></blockquote><h2 id="机器如何找到函数"><a href="#机器如何找到函数" class="headerlink" title="机器如何找到函数"></a>机器如何找到函数</h2><h3 id="1、给定函数范围"><a href="#1、给定函数范围" class="headerlink" title="1、给定函数范围"></a>1、给定函数范围</h3><p>linear function </p><p>network architecture  RNN循环神经网络  CNN卷积神经网络</p><h3 id="2、函数寻找方法"><a href="#2、函数寻找方法" class="headerlink" title="2、函数寻找方法"></a>2、函数寻找方法</h3><p>Gradient Descent 梯度下降</p><p><img src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210101111415435.png" alt="image-20210101111415435"></p><p>Anomaly detection 能不能知道 自己不知道</p><p>meta learning   让机器学习如何学习，让机器自己设计学习的方法</p><h2 id="Regression"><a href="#Regression" class="headerlink" title="Regression"></a>Regression</h2><p>输出数值（Scalar）</p><p>比如无人车驾驶：input 一些sensor ，输出方向盘角度</p><p>比如推荐系统：input A和商品B，输出A购买B的可能性</p><p>比如宝可梦：输入某只宝可梦，输出他进化后的CP值</p><p>三个步骤</p><p>1、找到一个model（A set of functions）比如线性model cp_new = b + w*cp_old</p><p><img src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210101162247930.png" alt="image-20210101162247930"></p><p>2、定义 Loss function，输入一个 function，输出一个 function 评估结果</p><p><img src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210101162204542.png" alt="image-20210101162204542"></p><p>这里采用的平方 loss function ，用真实数据减去预测数值再取平方</p><p>3、找一个最好的 function</p><p><img src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210101163034130.png" alt="image-20210101163034130"></p><p>穷举所有的 w 和 b，求出最好的 w 和 b</p><p>Gradient Descent，可以处理任何可以微分的 function</p><p><img src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210101163613411.png" alt="image-20210101163613411"></p><p>随机选取初始 w0，再初始w0这个位置，计算w参数对L的微分（切线斜率），若斜率为负，则右边 loss 较低，应该增加 w0，增加量为：微分值*(learning rate) </p><p>就这样不断地求 w，直到 w 到达 local optimal，但是会陷入局部最优（当然 linear set 没有局部最优）</p><p>如果有两个参数呢？</p><p><img src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210101164005142.png" alt="image-20210101164005142"></p><p><img src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210101164409136.png" alt="image-20210101164409136"></p><p>其实算出来的就是等高线的法线方向</p><p><img src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210101164451537.png" alt="image-20210101164451537"></p><p>这种情况就会陷入局部最优，但 linear regression 没有 local optimal</p><p>求出来 b 和 w 之后，我们关心新数据和预测函数的误差，发现比较大</p><p>重新设计 model</p><p>二次式：y = b + w1<em>Xcp + w2</em>*(Xcp)^2</p><p>一样的用刚才的算法去求最好的 b、w1、w2</p><p>三次式：y = b + w1<em>Xcp + w2\</em>(Xcp)^2 + w3*(Xcp)^3</p><p>四次式：。。。不断地拟合，loss function()的值不断变小，但是 test data 效果却更差，这波啊，这波是过拟合</p><p><img src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210103132844166.png" alt="image-20210103132844166"></p><p>如图，training data 效果特别好，但是显然不是一个合理的宝可梦CP预测的 function</p><p><img src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210103133116007.png" alt="image-20210103133116007"></p><p>越复杂的model、我们可以找到 training data 的loss function 最低的 function，但是在testing data 的结果是不一样的</p><p><img src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210103133206717.png" alt="image-20210103133206717"></p><p>testing 的结果反而变差了，拟合的并不是很好（Overfitting）</p><h3 id="overfitting"><a href="#overfitting" class="headerlink" title="overfitting"></a>overfitting</h3><p><img src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210103143405103.png" alt="image-20210103143405103"></p><p>model 并不是越复杂越好</p><p>当收集足够多的数据之后，发现并不是简单的和旧CP值有关</p><p><img src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210103133652548.png" alt="image-20210103133652548"></p><p>物种是有关键性影响的，重新设计 model ，将 物种（species）考虑进去</p><p><img src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210103133802784.png" alt="image-20210103133802784"></p><p><img src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210103133924202.png" alt="image-20210103133924202"></p><p>这也是一个线性拟合…为啥不分四个训练集呢。。感觉就像是把 Xcp这个 feature 分成四个 feature了，分别表示对四个种类的 cp 值</p><p>来个更复杂的 model</p><p><img src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210103134601138.png" alt="image-20210103134601138"></p><p>对 eevee 考虑的更加复杂一些，其实也不是很复杂，作业可能几百个参数。。。</p><p>然后算出来 loss 为1.4，testing data loss 102.3，显然 overfitting 了</p><h3 id="如何避免-overfitting"><a href="#如何避免-overfitting" class="headerlink" title="如何避免 overfitting"></a>如何避免 overfitting</h3><p>回到 regularization ，redesigned loss function </p><p>loss function 不应该只考虑误差平方和，还应该加上 wi (wi 为各级x的系数) 的平方和，为什么？</p><p><img src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210103145609976.png" alt="image-20210103145609976"></p><p>因为当 wi 比较小，则求出来的 function 比较平滑，输出对输入更加不敏感</p><p>更倾向于平滑的 function，因为越平滑，收到 noise 的影响越小</p><p>不断的调节 <em>λ</em> ，求出结果， <em>λ</em> 越大则考虑平滑越多</p><p>发现越平滑，考虑的err越少，则 training data 的结果越糟糕，但是 testing data 效果反而可能好一些，所以需要调节  <em>λ</em> 来决定 function 的平滑程度，（调节平滑不需要考虑 b）</p><p><img src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210103152631989.png" alt="image-20210103152631989"></p><p>总结：宝可梦的当前CP和物种决定几乎进化后的CP值（可能还有其他因素）</p><p>梯度下降，过度拟合和考虑平滑</p><h3 id="error-来自哪里"><a href="#error-来自哪里" class="headerlink" title="error 来自哪里"></a>error 来自哪里</h3><p>来自 bias 平均</p><p>来自 variance 方差</p><p><img src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210103154345098.png" alt="image-20210103154345098"></p><p><img src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210103154955082.png" alt="image-20210103154955082"></p><p>error 来自 bias，说明你没有瞄准好，导致估计值偏离真实值</p><p>error 来自 variance，说明你射的不够稳，还没有收敛/773.0</p><p><img src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210103155658459.png" alt="image-20210103155658459"></p><p>求各个模型的 f*（100组不同数据） ，发现简单的 model 是比较集中的，即 variance 比较小，不容易散开</p><p>model 比较复杂的话，function 散布就会很开，variance 比较开</p><p>为什么？</p><p>因为 model 比较复杂，受到不同的 data 影响比较大</p><p>bias：large bias，如何评测 f* 和 f^ 的 bias 差多少？</p><p><img src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210103160043302.png" alt="image-20210103160043302"></p><p>这里用红色表示各个 function 的结果，蓝色表示平均值，黑色表示正确答案，</p><p><img src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210103160242454.png" alt="image-20210103160242454"></p><p>可以看到，虽然这些 f<em> 不知道飘到哪里去了，但是平均起来看，f</em> 和 f^ 还是比较接近的，即 复杂的 model 的 bias 还是比较小的</p><p>所以，当你的 model 越来越复杂，bias 会越来越小，variance 会越来越大</p><p><img src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210103160649516.png" alt="image-20210103160649516"></p><h4 id="如何分辨现在是-underfitting-还是-overfitting？"><a href="#如何分辨现在是-underfitting-还是-overfitting？" class="headerlink" title="如何分辨现在是 underfitting 还是 overfitting？"></a>如何分辨现在是 underfitting 还是 overfitting？</h4><p>当你的 traning data 结果比较差的时候，是 underfitting</p><p>当你的 training data 结果比较好但是 testing data 结果很差的时候，大概是 overfitting</p><p><img src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210103160835816.png" alt="image-20210103160835816"></p><p>怎么做？</p><p>error from bias：重新设计 model、或者用一个更加复杂的 model，找更多 data 也没用</p><p>error from variance：</p><p><img src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210103161153542.png" alt="image-20210103161153542"></p><p>找更多 data、或者 generate 一些假 data 哈哈哈</p><p>或者 regularization：再加一些参数，比如曲线平滑度</p><p><img src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210103161601332.png" alt="image-20210103161601332"></p><p>但是这样子得到的数据可能会伤害你的 bias</p><blockquote><p>bias偏移量越大，模型越垃圾。而高阶model往往会造成其bias偏移量较小（参考高数泰勒展开）。从而导致高阶model（或者说是复杂model）的模型更贴合于数据的真实分布。但是当我们用新的测试集在高阶model上进行预测时，由于高阶model的形态过分贴合训练集数据且高阶model群较为繁杂，其在新的测试集数据上的拟合优度一定不会很好。</p></blockquote><h3 id="model-选择"><a href="#model-选择" class="headerlink" title="model 选择"></a>model 选择</h3><p>我们希望找一个 bias 和 variance 都比较小的 model</p><p>should not do：</p><p><img src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210103162039800.png" alt="image-20210103162039800"></p><p>你的 testing set 只是一个验证 training set 的 set，真实的 testing set 往往都是没有的</p><p>所以应该是这样做：用training data 选择 function，用 traning + validation 验证 model，这样才能真实反映 testing 的 bias（也就是不要提前考虑 testing data 的bias）</p><p><img src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210103162412021.png" alt="image-20210103162412021"></p><p>N 折交叉验证：</p><p><img src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210103162636812.png" alt="image-20210103162636812"></p><p>把 training data 分成 n 份，选一个作为 validation</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;机器学习&quot;&gt;&lt;a href=&quot;#机器学习&quot; class=&quot;headerlink&quot; title=&quot;机器学习&quot;&gt;&lt;/a&gt;机器学习&lt;/h1&gt;&lt;p&gt;机器学习就是让机器自动找函数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2021/01/03/ML%E5%AD%A6%E4%B9%</summary>
      
    
    
    
    
    <category term="机器学习" scheme="https://panlianghnu.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>简易区块链C语言实现</title>
    <link href="https://panlianghnu.github.io/2020/12/30/%E7%AE%80%E6%98%93%E5%8C%BA%E5%9D%97%E9%93%BEC%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/"/>
    <id>https://panlianghnu.github.io/2020/12/30/%E7%AE%80%E6%98%93%E5%8C%BA%E5%9D%97%E9%93%BEC%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-12-30T04:11:39.000Z</published>
    <updated>2021-03-14T14:59:39.787Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简易区块链C语言实现"><a href="#简易区块链C语言实现" class="headerlink" title="简易区块链C语言实现"></a>简易区块链C语言实现</h1><p>在CSDN的第四个任务：实现一个最简单的区块链，不带区块链网络、时间戳、merkle tree等</p><p>虽然说技术上难度不大，但是想要实现它，还真是一个不小的工程。。。</p><p>除了 SHA256 的计算部分，其余的代码都是自己实现的，写的不好还望见谅</p><h2 id="区块链数据结构："><a href="#区块链数据结构：" class="headerlink" title="区块链数据结构："></a>区块链数据结构：</h2><p><img src="/2020/12/30/%E7%AE%80%E6%98%93%E5%8C%BA%E5%9D%97%E9%93%BEC%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/image-20201229232408783.png" alt="image-20201229232408783"></p><p>如图所示，每个区块分为区块 head，和区块 body</p><p>区块头又分为 SHA_ALL、nonce、SHA_PREV、SHA_BLOCK</p><p>&gt;<br>&gt;</p><blockquote><p>SHA_BLOCK: 对区块的 body 部分进行一次 SHA256运算，保存在SHA_BLOCK</p><p>SHA_PREV: 保存上一个区块整体(head+body)的 SHA256 值</p><p>nonce: 随机数，意义仅仅只是让区块头（不包含SHA_ALL的部分）+区块体一起进行SHA256运算，使得最终的结果刚好出现 n 个前导0，n 可以设置，代表出块的难度，模拟POW共识算法（比特币采用POW），我看了比特币源码，比特币源码的 nonce 是采用的 long long ，那我这里采用 unsigned long，之前龙哥和我说256位的nonce，我跑了跑发现没有必要，nonce跑到10万就需要我电脑好几秒了。。。unsigned long（8字节） 最大值有<strong>18446744073709551615</strong>，根本跑不完好吗。。。</p><p>当然比特币的 nonce 虽然只有8字节，但这里并不是说比特币的区块取值每次只需要计算2^64种情况，比特币实际挖坑时，最终的哈希值前导 0 特别长，只遍历一次 nonce 是几乎不可能的情况，矿机需要不断地改变区块体里面的 coinbase 里的无意义的值，然后不断地去遍历 nonce ，才能试探出前导0多于 n 个的情况，这将耗费巨大的算力，也是比特币POW共识策略的体现</p><p>SHA_ALL: 存放在区块头的最上面，SHA_ALL 保存整个区块（不包含头最上面的这256比特）的SHA256计算结果，必须有 n 个前导0。它的意义在于，只要你修改了这个区块的任意部分，你就需要重新计算 HASH_BLOCK、重新计算 NONCE ，使得最终的 SHA_ALL 算出来要出现 n 个前导0，当 n 比较大，区块链比较长时，想要修改某区块并使整个区块链仍合法的工作量不可估量，这是区块链“不可篡改”的重要因素之一</p></blockquote><p>区块体就比较随意了，我这里只弄了一个字符串</p><p>这样就实现了一个最简单的区块链</p><p>具体代码实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> byte[<span class="number">104</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> sha_all[<span class="number">32</span>];       <span class="comment">// 256 bit sha_all</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> nonce;             <span class="comment">// 64 bit nonce</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> sha_prev[<span class="number">32</span>];      <span class="comment">// 256 bit sha_prev</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> sha_block[<span class="number">32</span>];     <span class="comment">// 256 bit sha_block</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125; block_chain_head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> body[<span class="number">1000</span>];</span><br><span class="line">&#125; block_chain_body;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    block_chain_head head;</span><br><span class="line">    block_chain_body body;</span><br><span class="line">&#125; block;</span><br></pre></td></tr></table></figure><p>这里补充一下C语言共用体的知识：</p><ul><li><p>我们知道结构体（Struct）是一种构造类型或复杂类型，它可以包含多个类型不同的成员。在C语言中，还有另外一种和结构体非常类似的语法，叫做<strong>共用体（Union）</strong>，它的定义格式为：</p><p>union 共用体名{<br>  成员列表<br>};</p><blockquote><p>共用体有时也被称为联合或者联合体，这也是 Union 这个单词的本意。</p></blockquote><p>结构体和共用体的区别在于：结构体的各个成员会占用不同的内存，互相之间没有影响；而共用体的所有成员占用同一段内存，修改一个成员会影响其余所有成员。</p><p>结构体占用的内存大于等于所有成员占用的内存的总和（成员之间可能会存在缝隙），共用体占用的内存等于最长的成员占用的内存。共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来成员的值覆盖掉。</p></li></ul><p>这里采用 Union + Struct 的数据结构，是为了录入数据+读取数据都比较方便直观。当我想要录入数据时，我只需要读字节流，将104个字节赋值给 byte 数组即可，当我想访问某些数据时，我又可以用结构体的方式直接访问成员变量，代码非常的简洁，可读性也高</p><p>题外话：</p><p>之前想着是用哈希值命名文件，区块头可以少一个 sha 字段，看起来好像没啥问题，但是实际实现的时候，用哈希值来命名区块，有一个很严重的 bug</p><p>我们使用最终的哈希值有n个前导0，这样来控制难度，文件名是一个字符串，0在字符串里表现为字符 ‘\0’ ，而这个字符被视为默认的字符串终止符，这个字符串你赋值给 const char* tmp，编译器会发现第一个字符就是字符串终止符，故而会把 tmp 这个字符串常量视为 “” 这样的空字符串保存在常量池，故而不能直接用这个哈希值来作为区块文件的文件名</p><p>同样的，但凡这个哈希值里面有 ‘\0’ ，我们都不能将它作为文件名，所以文件名我不采用哈希值，哈希值还是选择保存在区块头中</p><h2 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h2><p>一个简易的区块链，必须有下面几个功能：</p><ul><li>生成创世纪块</li><li>读取文件夹下的所有区块</li><li>查找创世纪块</li><li>查找区块链的最后一个区块</li><li>在区块链的尾部追加区块</li><li>对区块的SHA计算</li></ul><p>求SHA256:</p><p>我使用了别人实现的SHA256算法，参考：<a href="https://github.com/panlianghnu/Blockchain-programming-exercises/tree/master/1.Blockchain%20basic%20exercises/2.Cryptography%20and%20security%20technology/SHA256/C%20Code">SHA256-C语言实现</a></p><p>这个程序有一个bug，当我将区块头和尾合并，一起作为字节数组传入时，有时候求出来的SHA256值正常，有时候值是错误的，我检查好久发现他在加密实现的过程中对传入的比特数组做了 strlen() 运算。。。这直接导致了如果传入的数据有 unsigned char 0，将被识别为字符串终结符，strlen() 函数遇到tmp直接终止计算，导致传入的字符串长度识别不正常，故而时好时坏（特别是创世纪块中有大量的 unsigned char 0，一直算出错误的SHA，还难以发现），我手动算字符串长度并作为参数传入计算，算是修了这个bug</p><h4 id="生成创世纪块："><a href="#生成创世纪块：" class="headerlink" title="生成创世纪块："></a>生成创世纪块：</h4><p>先贴代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;    <span class="comment">// 创建创世纪块</span></span><br><span class="line">    block_chain_head* genesis = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(block_chain_head));</span><br><span class="line">    block_chain_body genesis_body;</span><br><span class="line">    <span class="built_in">strcpy</span>(genesis_body.body,<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(genesis-&gt;byte,<span class="number">0</span>,<span class="keyword">sizeof</span>(block_chain_head));    <span class="comment">// 先将区块字节头全部初始化为0</span></span><br><span class="line">    sha256_main(genesis_body.body,<span class="keyword">sizeof</span>(genesis_body.body),genesis-&gt;sha_block);   <span class="comment">// 哈希body</span></span><br><span class="line">    <span class="comment">// 随机 nonce ，对(块头+块体)再次哈希</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;开始随机nonce\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (genesis-&gt;nonce &lt; <span class="number">0xffffffffffffffff</span>) &#123;</span><br><span class="line">        <span class="comment">// 把块头块体 读入一个 BYTE 数组</span></span><br><span class="line">        BYTE text[<span class="number">10200</span>];</span><br><span class="line">        read_head_body(text,genesis,genesis_body);</span><br><span class="line">        BYTE buf[SHA256_BLOCK_SIZE];</span><br><span class="line">        <span class="keyword">size_t</span> size_of_text = <span class="keyword">sizeof</span>(block_chain_head)<span class="number">-32</span> + <span class="built_in">strlen</span>(genesis_body.body);</span><br><span class="line">        sha256_main(text,size_of_text,buf);    <span class="comment">// 计算 sha256   有bug??? (已解决)</span></span><br><span class="line">        <span class="comment">// 当text 含有 &#x27;\0&#x27; 时，出现bug</span></span><br><span class="line">        <span class="comment">// 所以添加变量 size_of_text (注意要减去32 sha_all)</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;当前nonce为: %lu     &quot;</span>,genesis-&gt;nonce);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;前8bit为:%02x\n&quot;</span>,buf[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span> (check_sha(buf)) &#123;   <span class="comment">// 检查是否为前导0</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;创世纪块nonce为: %lu\n&quot;</span>,genesis-&gt;nonce);</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span>* filename = <span class="string">&quot;Genesis.block&quot;</span>;</span><br><span class="line">            FILE *fp = fopen(filename,<span class="string">&quot;w&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line">            <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;SHA256_BLOCK_SIZE;i++) &#123;</span><br><span class="line">                genesis-&gt;sha_all[i] = buf[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="keyword">sizeof</span>(block_chain_head);i++) &#123;   <span class="comment">// 写入区块头</span></span><br><span class="line">                <span class="built_in">fprintf</span>(fp,<span class="string">&quot;%c&quot;</span>,genesis-&gt;byte[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(genesis_body.body);i++) &#123;  <span class="comment">// 写入区块体</span></span><br><span class="line">                <span class="built_in">fprintf</span>(fp,<span class="string">&quot;%c&quot;</span>,genesis_body.body[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        genesis-&gt;nonce++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就体现出联合体的优点了，直接可以通过 memset 对整个头初始化，却不影响我访问对应的结构题属性，计算 SHA256 时，我引用了别人的函数，sha256_main()，将对应的属性保存（创世纪块sha_prev = 0)，不断的计算nonce，由于采用了 unsigned long ，遍历只需要递增即可，注意每次递增 nonce，重新计算 SHA 的时候，一定要注意是从区块头的第32个字节开始往下读，一直把区块体的内容也读完，读出来的所有字节放入一个 BYTE text[SHA256_BLOCK_SIZE] 数组里，一起去求 SHA256，这样算出来的 SHA_ALL才是正确的，我这边难度设置的是前 16个 bit 为0，平均大概10秒能出一个块吧</p><h4 id="验证-genesis-文件："><a href="#验证-genesis-文件：" class="headerlink" title="验证 genesis 文件："></a>验证 genesis 文件：</h4><p>使用 Mac 的二进制编辑器Hex Fiend打开查看：</p><p><img src="/2020/12/30/%E7%AE%80%E6%98%93%E5%8C%BA%E5%9D%97%E9%93%BEC%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/image-20201229173435239.png" alt="image-20201229173435239"></p><p>可以看到，前32字节的 sha_all ，是一串乱码，是我们使用SHA256生成的整个文件的256bit 哈希值</p><p>接下来8个字节：</p><p><img src="/2020/12/30/%E7%AE%80%E6%98%93%E5%8C%BA%E5%9D%97%E9%93%BEC%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/image-20201229173836110.png" alt="image-20201229173836110"></p><p>再接下来32字节的 sha_prev 全为0，这是我们初始化生成的0，创世纪块没有前一个块嘛</p><p>再接下来32字节是 sha_block ，这是区块体的哈希值，可以看到也是一串乱码</p><p><img src="/2020/12/30/%E7%AE%80%E6%98%93%E5%8C%BA%E5%9D%97%E9%93%BEC%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/image-20201229174021198.png" alt="image-20201229174021198"></p><p>最后的部分就是区块 body 的内容了，创世纪块的body 内容我写的很简单，就是hello world，可以看到在右边已经把它解析出来了</p><h4 id="读取文件夹下的所有区块："><a href="#读取文件夹下的所有区块：" class="headerlink" title="读取文件夹下的所有区块："></a>读取文件夹下的所有区块：</h4><p>C语言标准库没有提供读取文件夹的函数，官方文档也没找到。。。</p><p><img src="/2020/12/30/%E7%AE%80%E6%98%93%E5%8C%BA%E5%9D%97%E9%93%BEC%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/image-20201230113237235.png" alt="image-20201230113237235"></p><p>我引用了 “dirent.h” 库来读文件夹，调用 readdir(dir) 和 entry-&gt;d_name 来匹配文件名</p><p>参考<a href="https://blog.csdn.net/wangqingchuan92/article/details/80109793">C语言读取文件夹</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read_dir_block</span><span class="params">(block block_list[],<span class="keyword">const</span> <span class="keyword">char</span>* filePath)</span></span>&#123; <span class="comment">// 读文件夹所有块文件</span></span><br><span class="line">    DIR *dir = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">entry</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((dir = opendir(filePath)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open dir failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((entry = readdir(dir))!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span>* filename = entry-&gt;d_name;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strstr</span>(filename,<span class="string">&quot;.block&quot;</span>)) &#123;      <span class="comment">// 匹配区块文件(以.block结尾)</span></span><br><span class="line">            read_block(&amp;block_list[num],filename);</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    closedir(dir);</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 string.h 库函数 strstr() 子串查找，匹配文件名包含 .block 的文件，调用 read_block() 去读取文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_block</span><span class="params">(block *blockitem,<span class="keyword">const</span> <span class="keyword">char</span>* filename)</span></span>&#123;   <span class="comment">// 读一个块</span></span><br><span class="line">    FILE *fp = fopen(filename,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!fp) &#123;</span><br><span class="line">        perror(<span class="string">&quot;File opening failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> c,i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((c = fgetc(fp)) != EOF) &#123; <span class="comment">// standard C I/O file reading loop</span></span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="keyword">sizeof</span>(block_chain_head)) &#123;</span><br><span class="line">            blockitem-&gt;head.byte[i] = c;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            blockitem-&gt;body.body[i-<span class="keyword">sizeof</span>(block_chain_head)] = c;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历每个字符，这里又体现出联合体的优势了，直接载入文件的字符流，读 sizeof(block_chain_head) 个字符即可录入头部数据，文件剩余字符全部录入 body 即可</p><p>如此便可读取目录下的所有区块文件，放入 block_list 中</p><h4 id="查找创世纪块："><a href="#查找创世纪块：" class="headerlink" title="查找创世纪块："></a>查找创世纪块：</h4><p>实现了读取目录下的所有区块之后，查找创世纪块变得尤其简单，只需要遍历所有的区块，找到某个 SHA_PREV 为全0的区块，即是创世纪块</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">block <span class="title">find_first_block</span><span class="params">()</span></span>&#123;</span><br><span class="line">    block block_list[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *filePath = <span class="string">&quot;.&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> size = read_dir_block(block_list,filePath);   <span class="comment">// 一共 size 个区块</span></span><br><span class="line">    block tmp;</span><br><span class="line">    <span class="built_in">memset</span>(tmp.head.byte, <span class="number">0</span>, <span class="keyword">sizeof</span>(block_chain_head));</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;no block file\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    BYTE hash[SHA256_BLOCK_SIZE] = &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;size;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> cmp = <span class="built_in">memcmp</span>(hash,block_list[i].head.sha_prev,SHA256_BLOCK_SIZE);</span><br><span class="line">        <span class="keyword">if</span>(cmp == <span class="number">0</span>)&#123;   <span class="comment">// equal， this is the first block</span></span><br><span class="line">            <span class="keyword">return</span> block_list[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我使用memcmp() 函数来比较 SHA_PREV 是否为全0，这是 memcmp 的官方文档：</p><p><img src="/2020/12/30/%E7%AE%80%E6%98%93%E5%8C%BA%E5%9D%97%E9%93%BEC%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/image-20201230114505328.png" alt="image-20201230114505328"></p><p>可以看到，memcmp将二者解释为无符号字符数组，一个个比较，全部相等会返回0，特别方便</p><p>所以在这里我直接定义一个32字节全0的字符数组，然后调用 memcmp 比较即可</p><h4 id="查找最后一个区块："><a href="#查找最后一个区块：" class="headerlink" title="查找最后一个区块："></a>查找最后一个区块：</h4><p>这个算是特别常用的一个功能了</p><p>在查找文件夹下所有区块和查找创世纪块的基础之上，我们就可以去做区块的拓扑排序了</p><p>查找最后一个区块也就变成了求区块的拓扑排序，返回拓扑排序的最后一个区块即可</p><p>求拓扑序列的代码很简单我就不展示了，基本上就是一个二重循环，匹配第 j 个区块的 SHA_PREV 和当前区块的 SHA_ALL ，然后在尾部添加即可</p><h4 id="尾部添加区块："><a href="#尾部添加区块：" class="headerlink" title="尾部添加区块："></a>尾部添加区块：</h4><p>有了查找最后一个区块，尾部添加区块也就特别简单了</p><p>只需要找到最后一个区块的 SHA_ALL ，新开一个区块，写入 SHA_PREV ，然后就和之前的生成创世纪块类似了，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">new_block</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* block_name ,<span class="keyword">char</span>* content)</span></span>&#123; <span class="comment">// 和 init 类似，在末尾添加</span></span><br><span class="line">    block last_block = find_last_block();</span><br><span class="line">    </span><br><span class="line">    block_chain_head* genesis = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(block_chain_head));</span><br><span class="line">    block_chain_body genesis_body;</span><br><span class="line">    <span class="built_in">strcpy</span>(genesis_body.body,content);</span><br><span class="line">    <span class="built_in">memset</span>(genesis-&gt;byte,<span class="number">0</span>,<span class="keyword">sizeof</span>(block_chain_head));    <span class="comment">// 先将区块头全部初始化为0</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;SHA256_BLOCK_SIZE;i++) &#123;</span><br><span class="line">        genesis-&gt;sha_prev[i] = last_block.head.sha_all[i];  <span class="comment">// 写入 sha_prev</span></span><br><span class="line">    &#125;</span><br><span class="line">    sha256_main(genesis_body.body,<span class="keyword">sizeof</span>(genesis_body.body),genesis-&gt;sha_block); <span class="comment">// sha_block</span></span><br><span class="line">    <span class="comment">// 随机 nonce ，对(块头+块体)再次哈希</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;开始随机nonce\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (genesis-&gt;nonce &lt; <span class="number">0xffffffffffffffff</span>) &#123;</span><br><span class="line">        <span class="comment">// 把块头块体 读入一个 BYTE 数组</span></span><br><span class="line">        BYTE text[<span class="number">10200</span>];</span><br><span class="line">        read_head_body(text,genesis,genesis_body);</span><br><span class="line">        BYTE buf[SHA256_BLOCK_SIZE];</span><br><span class="line">        <span class="keyword">size_t</span> size_of_text = <span class="keyword">sizeof</span>(block_chain_head)<span class="number">-32</span> + <span class="built_in">strlen</span>(genesis_body.body);</span><br><span class="line">        sha256_main(text,size_of_text,buf);    <span class="comment">// 计算 sha256   有bug??? (已解决)</span></span><br><span class="line">        <span class="comment">// 当text 含有 &#x27;\0&#x27; 时，出现bug</span></span><br><span class="line">        <span class="comment">// 所以添加变量 size_of_text (注意要减去32 sha_all)</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;当前nonce为: %lu     &quot;</span>,genesis-&gt;nonce);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;前8bit为:%02x\n&quot;</span>,buf[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span> (check_sha(buf)) &#123;   <span class="comment">// 检查是否为前导0</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;新区块nonce为: %lu\n&quot;</span>,genesis-&gt;nonce);</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span>* filename = <span class="built_in">strcat</span>(block_name, <span class="string">&quot;.block&quot;</span>);</span><br><span class="line">            FILE *fp = fopen(filename,<span class="string">&quot;w&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;SHA256_BLOCK_SIZE;i++) &#123;</span><br><span class="line">                genesis-&gt;sha_all[i] = buf[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="keyword">sizeof</span>(block_chain_head);i++) &#123;   <span class="comment">// 写入区块头</span></span><br><span class="line">                <span class="built_in">fprintf</span>(fp,<span class="string">&quot;%c&quot;</span>,genesis-&gt;byte[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(genesis_body.body);i++) &#123;  <span class="comment">// 写入区块体</span></span><br><span class="line">                <span class="built_in">fprintf</span>(fp,<span class="string">&quot;%c&quot;</span>,genesis_body.body[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        genesis-&gt;nonce++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>不要在意为什么新区块也叫 genesis 我懒得改了</del></p><p>除了区块的 filename 、SHA_PREV 、body 不一样，其他的操作完全和创世纪块一样</p><p>写新区块时，我需要给新区块后缀命名为 .block </p><p>c语言不能直接使用 + 运算符对字符串进行拼接，故使用strcat，跑到一半又报错了。。原因是strcat直接在字符数组尾部添加字符，晕，数组越界了。</p><p><img src="/2020/12/30/%E7%AE%80%E6%98%93%E5%8C%BA%E5%9D%97%E9%93%BEC%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/image-20201229223124304.png" alt="image-20201229223124304"></p><p>不得不再次感叹C语言的字符串处理真是太不方便了</p><p><img src="/2020/12/30/%E7%AE%80%E6%98%93%E5%8C%BA%E5%9D%97%E9%93%BEC%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/image-20201229224105511.png" alt="image-20201229224105511"></p><p>可以看到 block_one 的 sha_prev 的部分，变成了 genesis 的前32字节，也就是哈希值指向 genesis </p><p>新区块的产生基本和创世纪块一样，只是调用一下 find_last_block ，找到 sha_prev 的值即可，然后自行输入 block_name 和 block_body</p><p>再看 block_two 和 block_one</p><p><img src="/2020/12/30/%E7%AE%80%E6%98%93%E5%8C%BA%E5%9D%97%E9%93%BEC%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/image-20201229224428292.png" alt="image-20201229224428292"></p><p>相应的 sha_prev、  sha_all 字段都是一一对应起来的</p><p><img src="/2020/12/30/%E7%AE%80%E6%98%93%E5%8C%BA%E5%9D%97%E9%93%BEC%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/image-20201229224529388.png" alt="image-20201229224529388"></p><p>解析出来的 body 也是正常的</p><p>尾部新增区块完成！</p><h4 id="检验区块链合法"><a href="#检验区块链合法" class="headerlink" title="检验区块链合法"></a>检验区块链合法</h4><p>在 find_last_block() 函数的实现中，topo 序列只要能构造出来，说明sha_prev 和 sha_all 能够一一对上，该区块链是合法的，所以实现也和 find_last_block 基本一样。如果创世纪块找不到，则区块链不合法，从创世纪块后找 n个区块（n为区块总数目-1），一旦找不到区块的 sha_prev 指向当前 sha_all，则区块链不合法，具体实现在 check_block_chain() 函数里，得到拓扑序列之后，遍历这个序列，计算各个区块的 SHA_，任意区块的 SHA 计算错误则该区块链不合法</p><h4 id="建立区块链索引"><a href="#建立区块链索引" class="headerlink" title="建立区块链索引"></a>建立区块链索引</h4><p>find_last_block() 和 check_block_chain() 函数里都做过拓扑排序的操作，参考上面的函数即可</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>感谢能看到最后的小伙伴！代码我开源到 GitHub 了</p><p><a href="https://github.com/panlianghnu/block_chain">https://github.com/panlianghnu/block_chain</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简易区块链C语言实现&quot;&gt;&lt;a href=&quot;#简易区块链C语言实现&quot; class=&quot;headerlink&quot; title=&quot;简易区块链C语言实现&quot;&gt;&lt;/a&gt;简易区块链C语言实现&lt;/h1&gt;&lt;p&gt;在CSDN的第四个任务：实现一个最简单的区块链，不带区块链网络、时间戳、me</summary>
      
    
    
    
    
    <category term="c语言" scheme="https://panlianghnu.github.io/tags/c%E8%AF%AD%E8%A8%80/"/>
    
    <category term="区块链" scheme="https://panlianghnu.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>JS 单线程</title>
    <link href="https://panlianghnu.github.io/2020/12/22/JS-%E5%8D%95%E7%BA%BF%E7%A8%8B/"/>
    <id>https://panlianghnu.github.io/2020/12/22/JS-%E5%8D%95%E7%BA%BF%E7%A8%8B/</id>
    <published>2020-12-22T12:44:08.000Z</published>
    <updated>2021-03-14T14:59:30.211Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS-单线程"><a href="#JS-单线程" class="headerlink" title="JS 单线程"></a>JS 单线程</h1><p>JS执行是单线程</p><blockquote><p>单线程是指Js引擎执行Js时只分了一个线程给他执行，也就是执行js时是单线程的。</p></blockquote><p>那么问题来了，什么是线程？进程又是什么？</p><p>在分析浏览器的渲染过程之前，我们先了解一下什么是进程和线程：</p><p>（1）什么是进程？</p><p>进程是CPU进行资源分配的基本单位</p><p>（2）什么是线程？</p><p>线程是CPU调度的最小单位，是建立在进程的基础上运行的单位，共享进程的内存空间。</p><p>多进程<br>1、浏览器是多进程</p><p>2、不同类型的标签页都会开启一个新的进程</p><p>3、相同类型的标签页是会合并到一个进程</p><p>1、浏览器进程</p><p>（1）负责管理各个标签页的创建和销毁</p><p>（2）负责浏览器的页面显示和功能（前进，后退，收藏等）</p><p>（3）负责资源的管理与下载</p><p>2、第三方插件进程</p><p>（1）负责每个第三方插件的使用，每个第三方插件使用时候都会创建一个对应的进程</p><p>3、GPU进程</p><p>（1）负责3D绘制和硬件加速</p><p>4、浏览器渲染进程（咱们这回主要分析的）</p><p>1、浏览器内核，主要负责HTML，CSS，JS等文件的解析和执行</p><p>什么是浏览器内核？</p><p>浏览器内核就是浏览器渲染进程，从接收下载文件后再到呈现整个页面的过程，由浏览器渲染进程负责，主要流程如下：</p><p>1、解析HTML文件和CSS文件，加载图片等资源文件，渲染成用户看到的页面<br>2、执行解析js文件脚本代码</p><p>这里主要讲浏览器页面渲染过程，在该过程中浏览器渲染进程会开启多个线程协作完成，主要的线程以及作用如下：</p><p>1、GUI渲染线程<br>2、JS引擎线程<br>3、事件触发线程<br>4、定时器出发线程<br>5、异步HTTP请求线程</p><h2 id="JS引擎"><a href="#JS引擎" class="headerlink" title="JS引擎"></a>JS引擎</h2><p>1、JS内核，也称JS引擎（例如V8引擎），负责处理执行javascript脚本程序，<br>2、由于js是单线程（一个Tab页内中无论什么时候都只有一个JS线程在运行JS程序），依靠任务队列来进行js代码的执行，所以js引擎会一直等待着任务队列中任务的到来，然后加以处理。</p><blockquote><p>注意，JavaScript 只在一个线程上运行，不代表 JavaScript 引擎只有一个线程。事实上，JavaScript 引擎有多个线程，单个脚本只能在一个线程上运行（称为主线程），其他线程都是在后台配合</p></blockquote><p>为了利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作 DOM。所以，这个新标准并没有改变 JavaScript 单线程的本质。</p><h2 id="V8引擎的内部结构"><a href="#V8引擎的内部结构" class="headerlink" title="V8引擎的内部结构"></a>V8引擎的内部结构</h2><p>1、V8是一个非常复杂的项目，使用cloc统计可知，它竟然有超过100万行C++代码。<br>2、V8由许多子模块构成，其中这4个模块是最重要的：</p><ol><li>Parser：负责将JavaScript源码转换为Abstract Syntax Tree (AST)</li><li>Ignition：interpreter，即解释器，负责将AST转换为Bytecode，解释执行Bytecode；同时收集3. TurboFan优化编译所需的信息，比如函数参数的类型；</li><li>TurboFan：compiler，即编译器，利用Ignitio所收集的类型信息，将Bytecode转换为优化的汇编代码；</li><li>Orinoco：garbage collector，垃圾回收模块，负责将程序不再需要的内存空间回收；</li></ol><blockquote><p>再次强调：单线程是指Js引擎执行Js时只分了一个线程给他执行，也就是执行js时是单线程的。</p></blockquote><p><strong>既然JS是单线程的，那怎么实现异步的呢？</strong></p><p>单线程意味着什么：JavaScript 同时只能执行一个任务，其他任务都必须在后面排队等待。也就是说代码只能同步执行，必须执行上一行才能执行下一行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure><p>然而并不是，还有异步！！！</p><p>程序里面所有的任务，可以分成两类：同步任务（synchronous）和异步任务（asynchronous）。</p><p>同步任务是那些没有被引擎挂起、在主线程上排队执行的任务。只有前一个任务执行完毕，才能执行后一个任务。</p><p>异步任务是那些被引擎放在一边，不进入主线程、而进入任务队列的任务。只有引擎认为某个异步任务可以执行了（比如 Ajax 操作从服务器得到了结果），该任务（采用回调函数的形式）才会进入主线程执行。排在异步任务后面的代码，不用等待异步任务结束会马上运行，也就是说，异步任务不具有“堵塞”效应。</p><p>举例来说，Ajax 操作可以当作同步任务处理，也可以当作异步任务处理，由开发者决定。如果是同步任务，主线程就等着 Ajax 操作返回结果，再往下执行；如果是异步任务，主线程在发出 Ajax 请求以后，就直接往下执行，等到 Ajax 操作有了结果，主线程再执行对应的回调函数。</p><h2 id="任务队列和事件循环-（实现异步）"><a href="#任务队列和事件循环-（实现异步）" class="headerlink" title="任务队列和事件循环 （实现异步）"></a>任务队列和事件循环 （实现异步）</h2><p>JavaScript 运行时，除了一个正在运行的主线程，引擎还提供一个任务队列（task queue），里面是各种需要当前程序处理的异步任务。（实际上，根据异步任务的类型，存在多个任务队列。为了方便理解，这里假设只存在一个队列。）</p><p>首先，主线程会去执行所有的同步任务。等到同步任务全部执行完，就会去看任务队列里面的异步任务。如果满足条件，那么异步任务就重新进入主线程开始执行，这时它就变成同步任务了。等到执行完，下一个异步任务再进入主线程开始执行。一旦任务队列清空，程序就结束执行。</p><p>异步任务的写法通常是回调函数。一旦异步任务重新进入主线程，就会执行对应的回调函数。如果一个异步任务没有回调函数，就不会进入任务队列，也就是说，不会重新进入主线程，因为没有用回调函数指定下一步的操作。</p><p>JavaScript 引擎怎么知道异步任务有没有结果，能不能进入主线程呢？答案就是引擎在不停地检查，一遍又一遍，只要同步任务执行完了，引擎就会去检查那些挂起来的异步任务，是不是可以进入主线程了。这种循环检查的机制，就叫做事件循环（Event Loop）。维基百科的定义是：“事件循环是一个程序结构，用于等待和发送消息和事件（a programming construct that waits for and dispatches events or messages in a program）”。</p><p>代码是如何执行的？</p><p>宏任务(macro-task)、微任务(micro-task)</p><p>除了广义的同步任务和异步任务，JavaScript 单线程中的任务可以细分为宏任务和微任务。</p><p>macro-task包括：script(整体代码), setTimeout, setInterval, setImmediate, I/O, UI rendering。<br>micro-task包括：process.nextTick, Promises, Object.observe, MutationObserver。</p><p>有了宏任务和微任务的概念后，那 JS 的执行顺序是怎样的？是宏任务先还是微任务先？</p><p>第一次事件循环中，JavaScript 引擎会把整个 script 代码当成一个宏任务执行，执行完成之后，再检测本次循环中是否寻在微任务，存在的话就依次从微任务的任务队列中读取执行完所有的微任务，再读取宏任务的任务队列中的任务执行，再执行所有的微任务，如此循环。JS 的执行顺序就是每次事件循环中的宏任务-微任务。</p><p>页面刷新率？</p><p>每次微任务执行之后宏任务执行之前如果有UI操作页面会重新渲染，一般页面刷新率60HZ/秒，一帧是16.6毫秒，所以可以理解为事件循环每次轮询的时间大概是16.6毫秒</p><p>每一帧浏览器需要做什么？</p><p>我们所看到的网页，都是浏览器一帧一帧绘制出来的，通常认为FPS为60的时候是比较流畅的，而FPS为个位数的时候就属于用户可以感知到的卡顿了，那么在一帧里面浏览器都要做哪些事情呢</p><h2 id="渲染帧的流程"><a href="#渲染帧的流程" class="headerlink" title="渲染帧的流程"></a>渲染帧的流程</h2><p>渲染帧是指浏览器一次完整绘制过程，帧之间的时间间隔是 DOM 视图更新的最小间隔。 由于主流的屏幕刷新率都在 60Hz，那么渲染一帧的时间就必须控制在 16ms 才能保证不掉帧。 也就是说每一次渲染都要在 16ms 内页面才够流畅不会有卡顿感。 这段时间内浏览器需要完成如下事情：</p><ul><li>脚本执行（JavaScript）：脚本造成了需要重绘的改动，比如增删 DOM、请求动画等</li><li>样式计算（CSS Object Model）：级联地生成每个节点的生效样式。</li><li>布局（Layout）：计算布局，执行渲染算法</li><li>重绘（Paint）：各层分别进行绘制（比如 3D 动画）</li><li>合成（Composite）：合成各层的渲染结果</li></ul><p>最初 Webkit 使用定时器进行渲染间隔控制， 2014 年时开始 <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=337617">使用显示器的 vsync 信号控制渲染</a>（其实直接控制的是合成这一步）。 这意味着 16ms 内多次 commit 的 DOM 改动会合并为一次渲染。</p><h2 id="耗时-JS-会造成丢帧"><a href="#耗时-JS-会造成丢帧" class="headerlink" title="耗时 JS 会造成丢帧"></a>耗时 JS 会造成丢帧</h2><p>JavaScript 在并发编程上一个重要特点是“Run To Completion”。在事件循环的一次 Tick 中， 如果要执行的逻辑太多会一直阻塞下一个 Tick，所有异步过程都会被阻塞。 一个流畅的页面中，JavaScript 引擎中的执行队列可能是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">执行 JS -&gt; 空闲 -&gt; 绘制（16ms）-&gt; 执行 JS -&gt; 空闲 -&gt; 绘制（32ms）-&gt; ...</span><br></pre></td></tr></table></figure><p>如果在某个时刻有太多 JavaScript 要执行，就会丢掉一次帧的绘制：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">执行很多 JS...（20ms）-&gt; 空闲 -&gt; 绘制（32ms）-&gt; ...</span><br></pre></td></tr></table></figure><p>例如下面的脚本在保持 JavaScript 忙的状态（持续 5s）下每隔 1s 新增一行 DOM 内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;message&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var then &#x3D; Date.now()</span><br><span class="line">var i &#x3D; 0</span><br><span class="line">var el &#x3D; document.getElementById(&#39;message&#39;)</span><br><span class="line">while (true) &#123;</span><br><span class="line">  var now &#x3D; Date.now()</span><br><span class="line">  if (now - then &gt; 1000) &#123;</span><br><span class="line">    if (i++ &gt;&#x3D; 5) &#123;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">    el.innerText +&#x3D; &#39;hello!\n&#39;</span><br><span class="line">    console.log(i)</span><br><span class="line">    then &#x3D; now</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>可以观察到虽然每秒都会写一次 DOM，但在 5s 结束后才会全部渲染出来，明显耗时脚本阻塞了渲染。</p><p><img src="/2020/12/22/JS-%E5%8D%95%E7%BA%BF%E7%A8%8B/js-block-render.gif" alt="js block render"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JS-单线程&quot;&gt;&lt;a href=&quot;#JS-单线程&quot; class=&quot;headerlink&quot; title=&quot;JS 单线程&quot;&gt;&lt;/a&gt;JS 单线程&lt;/h1&gt;&lt;p&gt;JS执行是单线程&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;单线程是指Js引擎执行Js时只分了一个线程给他执行</summary>
      
    
    
    
    
    <category term="nodejs" scheme="https://panlianghnu.github.io/tags/nodejs/"/>
    
  </entry>
  
</feed>
