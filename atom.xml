<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>PanLiang&#39;s blog</title>
  
  
  <link href="https://panlianghnu.github.io/atom.xml" rel="self"/>
  
  <link href="https://panlianghnu.github.io/"/>
  <updated>2021-03-27T16:32:05.204Z</updated>
  <id>https://panlianghnu.github.io/</id>
  
  <author>
    <name>Pan Liang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>网易云音乐解锁灰歌-MacOS</title>
    <link href="https://panlianghnu.github.io/2021/03/28/%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E8%A7%A3%E9%94%81%E7%81%B0%E6%AD%8C-MacOS/"/>
    <id>https://panlianghnu.github.io/2021/03/28/%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E8%A7%A3%E9%94%81%E7%81%B0%E6%AD%8C-MacOS/</id>
    <published>2021-03-27T16:23:21.000Z</published>
    <updated>2021-03-27T16:32:05.204Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网易云音乐解锁灰歌"><a href="#网易云音乐解锁灰歌" class="headerlink" title="网易云音乐解锁灰歌"></a>网易云音乐解锁灰歌</h1><p style="text-align:right">For MacOS</p><p><a href="https://github.com/nondanee/UnblockNeteaseMusic/issues">github链接</a></p><h2 id="简易版本"><a href="#简易版本" class="headerlink" title="简易版本"></a>简易版本</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/nondanee/UnblockNeteaseMusic.git</span><br><span class="line">cd UnblockNeteaseMusic</span><br><span class="line">npm i</span><br></pre></td></tr></table></figure><p>接着信任证书，双击目录下的 <code>ca.crt</code> 文件，点击添加<img src="/2021/03/28/%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E8%A7%A3%E9%94%81%E7%81%B0%E6%AD%8C-MacOS/90654597-21898b00-e273-11ea-86c9-8a7af6c0787c.png" alt="90654597-21898b00-e273-11ea-86c9-8a7af6c0787c"></p><p>输入密码后再双击：<img src="/2021/03/28/%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E8%A7%A3%E9%94%81%E7%81%B0%E6%AD%8C-MacOS/90654852-67465380-e273-11ea-864b-703a5cc2e510.png" alt="90654852-67465380-e273-11ea-864b-703a5cc2e510"></p><p>按照指引点击，输入密码<img src="/2021/03/28/%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E8%A7%A3%E9%94%81%E7%81%B0%E6%AD%8C-MacOS/90654979-965cc500-e273-11ea-9043-bbdf84b38d32.png" alt="90654979-965cc500-e273-11ea-9043-bbdf84b38d32"></p><h2 id="1-寻找网易云服务器的IP"><a href="#1-寻找网易云服务器的IP" class="headerlink" title="1. 寻找网易云服务器的IP"></a>1. 寻找网易云服务器的IP</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping music.163.com</span><br></pre></td></tr></table></figure><p>得到IP：59.111.181.60</p><h2 id="2-向hosts文件添加记录"><a href="#2-向hosts文件添加记录" class="headerlink" title="2. 向hosts文件添加记录"></a>2. 向hosts文件添加记录</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/hosts</span><br><span class="line">append</span><br><span class="line">127.0.0.1 music.163.com</span><br><span class="line">127.0.0.1 interface.music.163.com</span><br></pre></td></tr></table></figure><h2 id="3-设置参数启动"><a href="#3-设置参数启动" class="headerlink" title="3. 设置参数启动"></a>3. 设置参数启动</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd UnblockNeteaseMusic</span><br><span class="line">node app.js -p 80:443 -f 59.111.181.60</span><br></pre></td></tr></table></figure><p>接着使用 <code>safari</code> 打开 <code>https://music.163.com</code> 确保可以访问（如果弹出无法访问，再信任一次）</p><p>重启网抑云～</p><p>或者可以使用别人的一键脚本：</p><p><a href="https://github.com/geoleonsh/unblockNeteaseShell">unblockNeteaseShell</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;网易云音乐解锁灰歌&quot;&gt;&lt;a href=&quot;#网易云音乐解锁灰歌&quot; class=&quot;headerlink&quot; title=&quot;网易云音乐解锁灰歌&quot;&gt;&lt;/a&gt;网易云音乐解锁灰歌&lt;/h1&gt;&lt;p style=&quot;text-align:right&quot;&gt;For MacOS&lt;/p&gt;

&lt;p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Flask+Vue 前后端分离JWT用户验证</title>
    <link href="https://panlianghnu.github.io/2021/03/25/Flask-Vue-%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBJWT%E7%94%A8%E6%88%B7%E9%AA%8C%E8%AF%81/"/>
    <id>https://panlianghnu.github.io/2021/03/25/Flask-Vue-%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBJWT%E7%94%A8%E6%88%B7%E9%AA%8C%E8%AF%81/</id>
    <published>2021-03-25T08:35:28.000Z</published>
    <updated>2021-03-25T09:12:04.864Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2021/03/25/Flask-Vue-%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBJWT%E7%94%A8%E6%88%B7%E9%AA%8C%E8%AF%81/image-20210325163605308.png" alt="image-20210325163605308"></p><p>传统Flask通过Flask-Login的login_user()解决登录问题，通过session进行处理，不适合前后端分离系统，所以使用JWT进行用户认证</p><blockquote><p>传统Flask通过Flask-Login的login_user()解决登录问题，通过session进行处理，不适合前后端分离系统，所以使用JWT进行用户认证</p><h5 id="Session-cookie"><a href="#Session-cookie" class="headerlink" title="Session-cookie:"></a>Session-cookie:</h5><p>Session是对于服务端来说的，客户端是没有Session一说的。Session是服务器在和客户端建立连接时添加客户端连接标志，最终会在服务器软件(Apache、Tomcat、JBoss)转化为一个临时Cookie(SessionId)发送给给客户端，当客户端请求时服务器会检查是否携带了这个SessionId(临时Cookie)，如果没有则会要求重新登录。</p><p>问题：</p><ol><li>如果我们的页面出现了 XSS 漏洞，由于 cookie 可以被 JavaScript 读取，XSS 漏洞会导致用户SessionId泄露，而作为后端识别用户的标识，cookie 的泄露意味着用户信息不再安全。在设置 cookie 的时候，其实你还可以设置 httpOnly 以及 secure 项。设置 httpOnly 后 cookie 将不能被 JS 读取，浏览器会自动的把它加在请求的 header 当中，设置 secure 的话，cookie 就只允许通过 HTTPS 传输。</li><li>httpOnly 选项使得 JS 不能读取到 cookie，那么 XSS 注入的问题也基本不用担心了。但设置 httpOnly 就带来了另一个问题，就是很容易的被 XSRF或CSRF(跨站请求伪造)。当你浏览器开着这个页面的时候，另一个页面可以很容易的跨站请求这个页面的内容。因为 cookie 默认被发了出去。</li><li>由于后端保存了所有用户的Session，后端每次都需要根据SessionId查出用户Session进行匹配，加大了服务器端的压力。</li></ol><h5 id="JWT"><a href="#JWT" class="headerlink" title="JWT:"></a>JWT:</h5><p>JWT 是一个开放标准(RFC 7519)，它定义了一种用于简洁，自包含的用于通信双方之间以 JSON 对象的形式安全传递信息的方法。JWT 可以使用 HMAC 算法或者是 RSA 的公钥密钥对进行签名。它具备两个特点：</p><ol><li><p>简洁(Compact)</p><p>可以通过URL, 参数或者在 HTTP header 发送，因为数据量小，传输速度快</p></li><li><p>自包含(Self-contained)</p><p>负载中包含了所有用户所需要的信息，避免了多次查询数据库</p><p>JWT一共由三部分组成，header（头部）、payload（负载）、signature（签名）通过‘.’进行拼接</p><p><img src="/2021/03/25/Flask-Vue-%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBJWT%E7%94%A8%E6%88%B7%E9%AA%8C%E8%AF%81/image-20210325163645225.png" alt="image-20210325163645225"></p><p>header(头部) 转Base64</p><p>payload(负载) 自定义信息内容, 不建议存储敏感信息(如密码) 转Base64</p><p>signature(签名) 一共三部分。转base64的header和转base64的payload拼接之后，然后使用header中声明的加密方式和secret加盐的方式加密字符串</p><ul><li><p>转Base64的header</p></li><li><p>转Base64的payload</p></li><li><p>secret(私钥)</p><p>最后一步签名的过程，实际上是对头部以及负载内容进行签名，防止内容被窜改。如果有人对头部以及负载的内容解码之后进行修改，再进行编码，最后加上之前的签名组合形成新的JWT的话，那么服务器端会判断出新的头部和负载形成的签名和JWT附带上的签名是不一样的。如果要对新的头部和负载进行签名，在不知道服务器加密时用的密钥的话，得出来的签名也是不一样的。</p></li><li><p>iss 签发者</p></li><li>sub 面向的用户</li><li>aud 接收jwt的一方</li><li>exp 过期时间(必须大于签发时间jat)</li><li>nbf 定义在什么时间之前，该jwt都是不可用的</li><li>jat 签发时间</li><li><p>jti 唯一身份标识，主要用来作为一次性token,从而回避重放攻击</p></li><li><p>alg 加密算法</p></li><li><p>typ 类型</p></li><li><p>差异比较</p></li></ul><p>Session方式存储用户id的最大弊病在于Session是存储在服务器端的，所以需要占用大量服务器内存，对于较大型应用而言可能还要保存许多的状态。一般而言，大型应用还需要借助一些KV数据库和一系列缓存机制来实现Session的存储。</p><p>JWT方式将用户状态分散到了客户端中，可以明显减轻服务端的内存压力。除了用户id之外，还可以存储其他的和用户相关的信息，例如该用户是否是管理员、用户所在的分组等。虽说JWT方式让服务器有一些计算压力（例如加密、编码和解码），但是这些压力相比磁盘存储而言可能就不算什么了。具体是否采用，需要在不同场景下用数据说话</p><ul><li>单点登陆</li></ul><p>Session方式来存储用户id，一开始用户的Session只会存储在一台服务器上。对于有多个子域名的站点，每个子域名至少会对应一台不同的服务器，例如：www.taobao.com，nv.taobao.com，nz.taobao.com，login.taobao.com。所以如果要实现在login.taobao.com登录后，在其他的子域名下依然可以取到Session，这要求我们在多台服务器上同步Session。使用JWT的方式则没有这个问题的存在，因为用户的状态已经被传送到了客户端。</p></li></ol></blockquote><h1 id="JWT认证流程"><a href="#JWT认证流程" class="headerlink" title="JWT认证流程"></a>JWT认证流程</h1><p><img src="/2021/03/25/Flask-Vue-%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBJWT%E7%94%A8%E6%88%B7%E9%AA%8C%E8%AF%81/image-20210325163819387.png" alt="image-20210325163819387"></p><ol><li>首先，前端通过Web表单将自己的用户名和密码发送到后端的接口。这一过程一般是一个HTTP POST请求。建议的方式是通过SSL加密的传输（https协议），从而避免敏感信息被嗅探。</li><li>后端核对用户名和密码成功后，将用户的id等其他信息作为JWT Payload（负载），将其与头部分别进行Base64编码拼接后签名，形成一个JWT。形成的JWT就是一个形同hhh.ppp.sss的字符串。</li><li>后端将JWT字符串作为登录成功的返回结果返回给前端。前端可以将返回的结果保存在localStorage或sessionStorage上，退出登录时前端删除保存的JWT即可。</li><li>前端在每次请求时将JWT放入HTTP Header中的Authorization位。(解决XSS和XSRF问题)</li><li>后端检查是否存在，如存在验证JWT的有效性。例如，检查签名是否正确；检查JWT是否过期；检查JWT的接收方是否是自己</li><li>验证通过后后端使用JWT中包含的用户信息进行其他逻辑操作，返回相应结果。</li></ol><hr><h1 id="Vue前端"><a href="#Vue前端" class="headerlink" title="Vue前端"></a>Vue前端</h1><h2 id="Vue-router"><a href="#Vue-router" class="headerlink" title="Vue-router"></a>Vue-router</h2><p>成功登录时，将后端返回的jwt存入sessionStorage</p><p>使用Vue-router在前端每次界面切换前都判断jwt，不符合要求则跳转至login登录界面</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 路由守护</span></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> accessToken = <span class="built_in">window</span>.sessionStorage.getItem(<span class="string">&#x27;accessToken&#x27;</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(accessToken) </span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment">// 重新登录后，转到之前的页面</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">Object</span>.keys(<span class="keyword">from</span>.query).length !== <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">let</span> redirect = <span class="keyword">from</span>.query.redirect</span><br><span class="line">        <span class="keyword">if</span>(to.path === redirect) <span class="comment">// 解决无限循环问题</span></span><br><span class="line">        &#123;</span><br><span class="line">          next()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          next(&#123;<span class="attr">path</span>:redirect&#125;) <span class="comment">// 重新登录后，转到之前的页面</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(accessToken &amp;&amp; to.path !== <span class="string">&#x27;/login&#x27;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 有token 但不是去 login页面</span></span><br><span class="line">    next()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(accessToken &amp;&amp; to.path === <span class="string">&#x27;/login&#x27;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//用户已经登陆，不让访问Login登录界面</span></span><br><span class="line">    next(&#123;<span class="attr">path</span>: <span class="keyword">from</span>.fullPath&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(!accessToken &amp;&amp; to.path !== <span class="string">&#x27;/login&#x27;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 未登录</span></span><br><span class="line">    next(<span class="string">&#x27;/login&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    next()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h2><p>axios 全局配置拦截器</p><p>request拦截器每次向后端请求携带header头Authorization信息</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// http request 拦截器</span></span><br><span class="line">axios.interceptors.request.use(</span><br><span class="line">  config =&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span>(sessionStorage.getItem(<span class="string">&quot;accessToken&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        config.headers.Authorization = sessionStorage.getItem(<span class="string">&quot;accessToken&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  &#125;,</span><br><span class="line">  err =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err);</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>response拦截器若接收到401错误，则是未登录，无权访问，则清除sessionStorage信息并跳转至login登录界面</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/ http response 拦截器</span><br><span class="line">axios.interceptors.response.use(</span><br><span class="line">  response =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;,</span><br><span class="line">  error =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(error.response)&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;axios:&#x27;</span> + error.response.status);</span><br><span class="line">      <span class="keyword">switch</span>(error.response.status)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">401</span>:</span><br><span class="line">          <span class="comment">// 返回401 清除token信息并跳转到登录页面</span></span><br><span class="line">          sessionStorage.clear() </span><br><span class="line">          router.replace(&#123;</span><br><span class="line">            path: <span class="string">&#x27;/login&#x27;</span>,</span><br><span class="line">            query: &#123;<span class="attr">redirect</span>: router.currentRoute.fullPath&#125;   <span class="comment">// 重新登录后，返回之前的页面</span></span><br><span class="line">          &#125;)</span><br><span class="line">          Message(&#123;<span class="attr">showClose</span>:<span class="literal">true</span>, <span class="attr">message</span>:<span class="string">&#x27;未登录，返回登陆界面&#x27;</span>, <span class="attr">type</span>:<span class="string">&#x27;error&#x27;</span>, <span class="attr">duration</span>:<span class="number">3000</span>&#125;)  </span><br><span class="line">   </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);   <span class="comment">// 返回接口的错误信息</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><hr><h1 id="Flask后端"><a href="#Flask后端" class="headerlink" title="Flask后端"></a>Flask后端</h1><ol><li><p>安装PyJWT pip install PyJWT</p></li><li><p>编写JWT生成函数与解密函数(util.py)</p><ol><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">key = <span class="string">&quot;123456&quot;</span> <span class="comment"># secret私钥,可通过配置文件导入</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_access_token</span>(<span class="params">username: <span class="built_in">str</span> = <span class="string">&quot;&quot;</span>, algorithm: <span class="built_in">str</span> = <span class="string">&#x27;HS256&#x27;</span>, exp: <span class="built_in">float</span> = <span class="number">2</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    生成access_token</span></span><br><span class="line"><span class="string">    :param username: 用户名(自定义部分)</span></span><br><span class="line"><span class="string">    :param algorithm: 加密算法</span></span><br><span class="line"><span class="string">    :param exp: 过期时间</span></span><br><span class="line"><span class="string">    :return:token</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    now = datetime.utcnow()</span><br><span class="line">    exp_datetime = now + timedelta(hours=exp)</span><br><span class="line">    access_payload = &#123;</span><br><span class="line">        <span class="string">&#x27;exp&#x27;</span>: exp_datetime,</span><br><span class="line">        <span class="string">&#x27;flag&#x27;</span>: <span class="number">0</span>,   <span class="comment">#标识是否为一次性token，0是，1不是</span></span><br><span class="line">        <span class="string">&#x27;iat&#x27;</span>: now,   <span class="comment"># 开始时间</span></span><br><span class="line">        <span class="string">&#x27;iss&#x27;</span>: <span class="string">&#x27;leon&#x27;</span>,   <span class="comment"># 签名</span></span><br><span class="line">        <span class="string">&#x27;username&#x27;</span>: username   <span class="comment">#用户名(自定义部分)</span></span><br><span class="line">    &#125;</span><br><span class="line">    access_token = jwt.encode(access_payload, key, algorithm=algorithm)</span><br><span class="line">    <span class="keyword">return</span> access_token</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decode_auth_token</span>(<span class="params">token: <span class="built_in">str</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    解密token</span></span><br><span class="line"><span class="string">    :param token:token字符串</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        payload = jwt.decode(token, key=key, algorithms=<span class="string">&#x27;HS256&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> (jwt.ExpiredSignatureError, jwt.InvalidTokenError, jwt.InvalidSignatureError):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">identify</span>(<span class="params">auth_header: <span class="built_in">str</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    用户鉴权</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> auth_header:</span><br><span class="line">        payload = decode_auth_token(auth_header)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> payload:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;username&quot;</span> <span class="keyword">in</span> payload <span class="keyword">and</span> <span class="string">&quot;flag&quot;</span> <span class="keyword">in</span> payload:</span><br><span class="line">            <span class="keyword">if</span> payload[<span class="string">&quot;flag&quot;</span>] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> payload[<span class="string">&quot;username&quot;</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>编写登录保护函数(util.py)</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login_required</span>(<span class="params">f</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    登录保护，验证用户是否登录</span></span><br><span class="line"><span class="string">    :param f:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @wraps(<span class="params">f</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        token = request.headers.get(<span class="string">&quot;Authorization&quot;</span>, default=<span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> token:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;not Login&#x27;</span>,<span class="string">&#x27;401 Permission Denied&#x27;</span></span><br><span class="line">        username = identify(token)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> username:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;not Login&#x27;</span>,<span class="string">&#x27;401 Permission Denied&#x27;</span>      <span class="comment"># return 响应体, 状态码, 响应头</span></span><br><span class="line">        <span class="keyword">return</span> f(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><p>tips: Flask的Response常用返回 return 响应体, 状态码, 响应头</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2021/03/25/Flask-Vue-%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBJWT%E7%94%A8%E6%88%B7%E9%AA%8C%E8%AF%81/image-20210325163605</summary>
      
    
    
    
    
    <category term="python" scheme="https://panlianghnu.github.io/tags/python/"/>
    
    <category term="Flask" scheme="https://panlianghnu.github.io/tags/Flask/"/>
    
    <category term="Vue" scheme="https://panlianghnu.github.io/tags/Vue/"/>
    
    <category term="JWT" scheme="https://panlianghnu.github.io/tags/JWT/"/>
    
  </entry>
  
  <entry>
    <title>直播小工具</title>
    <link href="https://panlianghnu.github.io/2021/03/15/%E7%9B%B4%E6%92%AD%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
    <id>https://panlianghnu.github.io/2021/03/15/%E7%9B%B4%E6%92%AD%E5%B0%8F%E5%B7%A5%E5%85%B7/</id>
    <published>2021-03-15T05:33:01.000Z</published>
    <updated>2021-03-15T07:13:48.289Z</updated>
    
    <content type="html"><![CDATA[<h1 id="直播小工具"><a href="#直播小工具" class="headerlink" title="直播小工具"></a>直播小工具</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近有充分的时间摸鱼…我捣鼓了一个看直播的小工具</p><p align="right">- inspired by Zlive</p><p>自从我手机端下载了<a href="https://app.zhibo.at">Z直播</a>，我就卸载了其他直播软件（斗鱼、虎牙），一个软件看各大平台直播实在是太好了。而且它还轻便，不用注册，没广告，没礼物，没全站喇叭……</p><p>可惜，<a href="https://app.zhibo.at">Z直播</a>并没有PC客户端，我就想着自己捣鼓一个程序看全网直播，不拘束于各大平台。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>优雅地看直播</p><ul><li><p>跨直播平台</p></li><li><p>无广告</p></li><li>高清流畅</li><li>没有礼物特效</li><li>无需注册账号</li></ul><h2 id="展示"><a href="#展示" class="headerlink" title="展示"></a>展示</h2><p>下面是GIF：</p><p><img src="/2021/03/15/%E7%9B%B4%E6%92%AD%E5%B0%8F%E5%B7%A5%E5%85%B7/优雅地看直播.gif" alt="优雅地看直播"></p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/panlianghnu/WatchLive_cross-platform.git</span><br><span class="line">cd WatchLive_cross-platform/</span><br></pre></td></tr></table></figure><h3 id="1、安装依赖"><a href="#1、安装依赖" class="headerlink" title="1、安装依赖"></a>1、安装依赖</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install</span><br></pre></td></tr></table></figure><h3 id="2、修改订阅"><a href="#2、修改订阅" class="headerlink" title="2、修改订阅"></a>2、修改订阅</h3><p>按照 “平台” “房间号” “标注” 的格式，每一行代表一个直播间，行内元素用空格分开</p><p>如图:</p><p><img src="/2021/03/15/%E7%9B%B4%E6%92%AD%E5%B0%8F%E5%B7%A5%E5%85%B7/image-20210315144140484.png" alt="image-20210315144140484"></p><h3 id="3、修改播放器"><a href="#3、修改播放器" class="headerlink" title="3、修改播放器"></a>3、修改播放器</h3><p>第 59 行，修改 open_app 的值，改成自己的支持流媒体输出的视频播放器的路径，比如你是 IINA 播放器，就写 open_app = “open -a /Applications/IINA.app”</p><p>如果不是 MacOS ，可能命令不是 open -a，需要自己修改</p><h3 id="4、运行"><a href="#4、运行" class="headerlink" title="4、运行"></a>4、运行</h3><p>在当前目录直接运行 python main.py 即可啦</p><p>可以像我一样在桌面放置一个 shell 文件，修改路径为自己的 shell 和 main.py</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/zsh</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># author:panliang</span></span></span><br><span class="line">python ~/real-url/main.py</span><br></pre></td></tr></table></figure><p>本工具仅在 python3 的环境测试</p><p>获取斗鱼的直播源，需 JavaScript 环境，可使用 node.js</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>流媒体地址获取参考 <a href="https://github.com/wbt5/real-url">real-url</a> </p><p>通过 <a href="https://github.com/wbt5/real-url">real-url</a> 获取直播间的真实播放源，然后通过一些可以播放流媒体的播放器打开播放源，达到不用注册、不用看广告、直接高清观看直播的目的</p><p>可以打开直播源的播放器很多：INNA、PotPlayer、VLC、DPlayer……</p><p><a href="https://github.com/panlianghnu/WatchLive_cross-platform">源代码</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;直播小工具&quot;&gt;&lt;a href=&quot;#直播小工具&quot; class=&quot;headerlink&quot; title=&quot;直播小工具&quot;&gt;&lt;/a&gt;直播小工具&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>杭电OJ</title>
    <link href="https://panlianghnu.github.io/2021/03/14/%E6%9D%AD%E7%94%B5OJ/"/>
    <id>https://panlianghnu.github.io/2021/03/14/%E6%9D%AD%E7%94%B5OJ/</id>
    <published>2021-03-14T09:05:52.000Z</published>
    <updated>2021-03-14T14:50:13.194Z</updated>
    
    <content type="html"><![CDATA[<h1 id="刷刷OJ放松一下"><a href="#刷刷OJ放松一下" class="headerlink" title="刷刷OJ放松一下"></a>刷刷OJ放松一下</h1><h2 id="1001-数列和"><a href="#1001-数列和" class="headerlink" title="1001-数列和"></a>1001-数列和</h2><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1001">原题链接</a></p><p>这个题目就是给一个正整数n，求 sum =  1 + 2 + 3 + … + n</p><p>我的第一反应就是循环相加或者递归相加复杂度太高，可能过不了。直接用求和公式即可</p><p>当我写下 sum = (n+1)*n/2 以为稳过的时候，提交后 err 了。。。想了很久代码应该没问题，去网上查发现这个题递归就能AC，崩溃！最后发现是中间结果爆 int 了，改成判断奇偶做就 AC 了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.c</span></span><br><span class="line"><span class="comment">//  OJ-HD-1004</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by panliang on 2021/3/12.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n)!=EOF) &#123;</span><br><span class="line">        n%<span class="number">2</span>==<span class="number">0</span>?</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n\n&quot;</span>,n/<span class="number">2</span>*(n+<span class="number">1</span>))</span><br><span class="line">        :</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n\n&quot;</span>,(n+<span class="number">1</span>)/<span class="number">2</span>*n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1002-大数相加"><a href="#1002-大数相加" class="headerlink" title="1002-大数相加"></a>1002-大数相加</h2><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1002">原题链接</a></p><p>这个题目就是不断输入两个正整数，然后求他们的和，数据很大很大，需要用高精度来做</p><p>用字符串保存数据，一步步模拟加法过程即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.c</span></span><br><span class="line"><span class="comment">//  OJ-HD-1002</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by panliang on 2021/3/12.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxsize 1010</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">plus</span><span class="params">(<span class="keyword">char</span>*,<span class="keyword">char</span>*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// two big positive integer plus</span></span><br><span class="line">    <span class="keyword">int</span> n,i=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">char</span> a[maxsize];</span><br><span class="line">        <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*maxsize);</span><br><span class="line">        <span class="keyword">char</span> b[maxsize];</span><br><span class="line">        <span class="built_in">memset</span>(b,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*maxsize);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>,a,b);</span><br><span class="line">        <span class="keyword">char</span>* c = plus(a,b);</span><br><span class="line">        <span class="comment">// a plus b</span></span><br><span class="line">        <span class="keyword">if</span>(i&gt;<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d:\n%s + %s = %s\n&quot;</span>,i,a,b,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>* a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> tmp[maxsize];</span><br><span class="line">    <span class="built_in">strcpy</span>(tmp,a);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len = <span class="built_in">strlen</span>(a);</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;i&lt;len;i++) &#123;</span><br><span class="line">        a[i] = tmp[len-i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">plus</span><span class="params">(<span class="keyword">char</span>* a,<span class="keyword">char</span>* b)</span></span>&#123;</span><br><span class="line">    reverse(a);</span><br><span class="line">    reverse(b);</span><br><span class="line">    <span class="keyword">char</span>* c = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*maxsize);</span><br><span class="line">    <span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*maxsize);</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;i&lt;maxsize;i++) &#123; <span class="comment">// 按位相加</span></span><br><span class="line">        <span class="keyword">if</span> (a[i]+b[i]) &#123; <span class="comment">// 如果不同时为&#x27;\0&#x27;</span></span><br><span class="line">            c[i] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (a[i]&gt;=<span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                c[i] += a[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (b[i]&gt;=<span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                c[i] += b[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理进位，两个数相加无需回溯考虑，最多也就19 =&gt; 9</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;maxsize<span class="number">-1</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(c[i]&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">            c[i] -= <span class="number">10</span>;</span><br><span class="line">            c[i+<span class="number">1</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(a); <span class="comment">// 程序健壮性</span></span><br><span class="line">    reverse(b); <span class="comment">// reverse只是方便处理相加，返回前应该复原</span></span><br><span class="line">    reverse(c);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1003-最大子序列和"><a href="#1003-最大子序列和" class="headerlink" title="1003-最大子序列和"></a>1003-最大子序列和</h2><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1003">原题链接</a></p><p>给一个序列，求一个子序列，要求这个子序列的和，是所有子序列的和中最大的那个。输出子序列的和、起始索引、终止索引</p><p>这个题目我的第一反应是二维动态规划，使用一个数组 dp[i][j] 表示 sum = arr[i]+…+arr[j]，然后数据太大爆内存了。。后来发现这个题目好像没有必要二维动态规划，只是求最大值而已，一维即可。</p><p>做法是遍历数组，需要5个变量作为中间变量</p><p>sum : 记录最大子序列的和，最终输出</p><p>left : 记录最大子序列的左索引，最终输出</p><p>right : 记录最大子序列的右索引，最终输出</p><p>tmp_sum : 保存中间序列的和，动态变化，不断和 sum 比较大小</p><p>tmp_left : 保存中间序列的左索引，如果中间序列的和是负数，则开新窗口，移动 tmp_left</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.c</span></span><br><span class="line"><span class="comment">//  OJ-HD-1003</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by panliang on 2021/3/12.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxsize 100010</span></span><br><span class="line"><span class="keyword">int</span> arr[maxsize];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">    <span class="keyword">int</span> cases=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;cases&lt;=t;cases++)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(arr,<span class="number">0</span>,<span class="keyword">sizeof</span>(arr));</span><br><span class="line">        <span class="keyword">int</span> len,i;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;len);</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;len;i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 求 arr 的最大子序列和</span></span><br><span class="line">        <span class="comment">// 二维动态规划必定爆内存，100010*100010*sizeof(int)</span></span><br><span class="line">        <span class="comment">// dp[i][j] = sum of arr[i] +...+ arr[j]</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>,sum=<span class="number">-1010</span>,tmp_sum=<span class="number">0</span>,tmp_left=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;len;i++) &#123;</span><br><span class="line">            tmp_sum += arr[i];</span><br><span class="line">            <span class="keyword">if</span> (tmp_sum &gt; sum) &#123;</span><br><span class="line">                sum = tmp_sum;</span><br><span class="line">                left = tmp_left;</span><br><span class="line">                right = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmp_sum &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                tmp_left = i+<span class="number">1</span>;</span><br><span class="line">                tmp_sum = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cases&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d:\n%d %d %d\n&quot;</span>,cases,sum,left+<span class="number">1</span>,right+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1004-Let-the-Balloon-Rise"><a href="#1004-Let-the-Balloon-Rise" class="headerlink" title="1004-Let the Balloon Rise"></a>1004-Let the Balloon Rise</h2><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1004">原题链接</a></p><p>输入N(0&lt;N&lt;=1000)个字符串，求出现次数最多的字符串</p><p>最简单的就是使用 map<string,int>，但是C语言标准库没有 string，也没有 map 。。。</string,int></p><p>我看N不大，没有用 hash，直接使用数组也过了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.c</span></span><br><span class="line"><span class="comment">//  OJ-HD-1004</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by panliang on 2021/3/14.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">&#125; colors[<span class="number">1010</span>];</span><br><span class="line"><span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertColor</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* toinsert)</span></span>&#123;</span><br><span class="line">    <span class="built_in">strcpy</span>(colors[len].str,toinsert);</span><br><span class="line">    colors[len++].num = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearColor</span><span class="params">()</span></span>&#123;</span><br><span class="line">    len=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleColor</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span>&#123; <span class="comment">// 找到则+1，没找到则 insert</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;len;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(colors[i].str, str) == <span class="number">0</span>) &#123;</span><br><span class="line">            colors[i].num++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    insertColor(str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">maxColor</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,tmpMax=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span>* res=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;len;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tmpMax &lt; colors[i].num) &#123;</span><br><span class="line">            tmpMax = colors[i].num;</span><br><span class="line">            res = colors[i].str;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// hashmap[] is the best way, but c has no stl</span></span><br><span class="line">    <span class="keyword">int</span> n,i;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n) &amp;&amp; n) &#123;</span><br><span class="line">        clearColor();</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> str[<span class="number">16</span>];</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">            handleColor(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,maxColor());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1005-Number-Sequence"><a href="#1005-Number-Sequence" class="headerlink" title="1005-Number Sequence"></a>1005-Number Sequence</h2><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1005">原题链接</a></p><p>f(1) = 1, f(2) = 1, f(n) = (A <em> f(n - 1) + B </em> f(n - 2)) mod 7.</p><p>给你 A B n， (1 &lt;= A, B &lt;= 1000, 1 &lt;= n &lt;= 100,000,000)，求 f(n)</p><p>这个题目涉及到 mod 运算，那么贴一个 mod 运算的性质</p><blockquote><p>模运算满足结合律、交换律、分配率，具体如下：</p><p>A. 结合律</p><p>((a+b)%p+c)%p=(a+(b+c)%p)%p</p><p>((ab)%p <em> c)%p= (a </em> (bc)%p)%p</p><p>B. 交换律</p><p>(a+b)%p=(b+a)%p</p><p>(ab)%p=(ba)%p</p><p>C. 分配率</p><p>(a+b)%p=(a%p+b%p)%p</p><p>((a+b)%pc)%p = ( (ac)%p + (b*c)%p )%p</p></blockquote><p>所以这个题目我可以先对输入的 A、B求mod，不会影响最终的结果，大幅缩小A、B的值会让中间的乘法运算更快，然后我交了一次，超时了。。。</p><p>我开始找数组的规律，可以发现 f(i) 只和 f(i-1) f(i-2) 有关，f(1) = f(2) = 1，所以只要当后面计算出来的结果也有连续的1，这个数字序列就进入了循环了，上代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.c</span></span><br><span class="line"><span class="comment">//  OJ-HD-1005</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by panliang on 2021/3/14.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//A number sequence is defined as follows:</span></span><br><span class="line"><span class="comment">//f(1) = 1, f(2) = 1, f(n) = (A * f(n - 1) + B * f(n - 2)) mod 7.</span></span><br><span class="line"><span class="comment">//Given A, B, and n, you are to calculate the value of f(n).</span></span><br><span class="line"><span class="comment">// 周期性函数,什么时候 one two 都变成1 ，就是一个周期到了</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b,n,i;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;n) &amp;&amp; (a+b+n)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span> || n==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        a = a%<span class="number">7</span>;</span><br><span class="line">        b = b%<span class="number">7</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp=<span class="number">0</span>,one=<span class="number">1</span>,two=<span class="number">1</span>;;</span><br><span class="line">        <span class="keyword">int</span> circle = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 新增一个数组，循环最多49次就会出现</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">3</span>;i&lt;=n;i++) &#123;</span><br><span class="line">            tmp = (a*two + b*one)%<span class="number">7</span>;  <span class="comment">// tmp = f(i)</span></span><br><span class="line">            one = two;                <span class="comment">// one = f(i-1)</span></span><br><span class="line">            two = tmp;                <span class="comment">// two = f(i)</span></span><br><span class="line">            <span class="keyword">if</span> (one == <span class="number">1</span> &amp;&amp; two == <span class="number">1</span>) &#123;  <span class="comment">// 周期 --&gt; f(i) = f(2)  f(i-1) = f(1)</span></span><br><span class="line">                circle = i<span class="number">-2</span>;</span><br><span class="line">                n = n%circle + circle; <span class="comment">// 加一个circle 防止落在0 , 大幅度缩小 n.... md还是超时...</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (circle) &#123;</span><br><span class="line">            <span class="keyword">if</span>(n==<span class="number">1</span> || n==<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (i=<span class="number">3</span>;i&lt;=n;i++) &#123;</span><br><span class="line">                tmp = (a*two + b*one)%<span class="number">7</span>;  <span class="comment">// tmp = f(i)</span></span><br><span class="line">                one = two;                <span class="comment">// one = f(i-1)</span></span><br><span class="line">                two = tmp;                <span class="comment">// two = f(i)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提交！</p><p>还是超时了😭</p><p>我去看看别人的博客发现了序列的循环不一定是整个循环，可能出现序列运行一段时间然后陷入循环，这个时候循环的部分不一定是以连续两个1开始。</p><p>知道了错误即可重新优化 n 的值</p><p>定义一个 hasShow[one][two] ，保存连续出现的两个值 one two 的索引（保存的是 one 的索引）</p><p>每次迭代计算新的 one two 时，标记 hasShow，直到命中 hasShow，即可确定循环在何处开始，训话你的大小是多少。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> hasShow[<span class="number">7</span>][<span class="number">7</span>];   <span class="comment">// hasShow[one][two] 代表 one two 排列已经出现，值为one出现的index</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b,n,i;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;n) &amp;&amp; (a+b+n)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span> || n==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        a = a%<span class="number">7</span>;</span><br><span class="line">        b = b%<span class="number">7</span>;</span><br><span class="line">        <span class="built_in">memset</span>(hasShow,<span class="number">0</span>,<span class="keyword">sizeof</span>(hasShow));</span><br><span class="line">        hasShow[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>; <span class="comment">// one=1 two=1 已经出现， index of one is 1</span></span><br><span class="line">        <span class="keyword">int</span> tmp=<span class="number">0</span>,one=<span class="number">1</span>,two=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> fall_in_cycle = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">3</span>;i&lt;=n;i++) &#123;</span><br><span class="line">            tmp = (a*two + b*one)%<span class="number">7</span>;  <span class="comment">// tmp = f(i)</span></span><br><span class="line">            one = two;                <span class="comment">// one = f(i-1)</span></span><br><span class="line">            two = tmp;                <span class="comment">// two = f(i)</span></span><br><span class="line">            <span class="keyword">if</span> (hasShow[one][two]) &#123;</span><br><span class="line">                <span class="comment">// cycle is (index of one - hasShow[one][two]) and now one is i-1</span></span><br><span class="line">                <span class="keyword">int</span> cycle = i<span class="number">-1</span> - hasShow[one][two];</span><br><span class="line">                <span class="comment">// 然后就可以定位 n 了，从 hasShow[one][two]开始,不断按照cycle循环</span></span><br><span class="line">                n = n - (hasShow[one][two]<span class="number">-1</span>);  <span class="comment">// 减去循环前的一段</span></span><br><span class="line">                <span class="keyword">int</span> index = n%cycle;  <span class="comment">//找到落在每个循环的 index  0 &lt;= index &lt;= cycle</span></span><br><span class="line">                n = (i<span class="number">-1</span>)<span class="number">-1</span> + index; <span class="comment">// 将 n 定位到循环中去</span></span><br><span class="line">                fall_in_cycle = cycle;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                hasShow[one][two] = i<span class="number">-1</span>; <span class="comment">// one 出现的 index</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 已经找到 n 的缩小值</span></span><br><span class="line">        one=two=<span class="number">1</span>;tmp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">3</span>;i&lt;=n;i++) &#123;</span><br><span class="line">            tmp = (a*two + b*one)%<span class="number">7</span>;  <span class="comment">// tmp = f(i)</span></span><br><span class="line">            one = two;                <span class="comment">// one = f(i-1)</span></span><br><span class="line">            two = tmp;                <span class="comment">// two = f(i)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2012-素数判断"><a href="#2012-素数判断" class="headerlink" title="2012-素数判断"></a>2012-素数判断</h2><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2012">原题链接</a></p><p>对于表达式n^2+n+41，当n在（x,y）范围内取整数值时（包括x,y）(-39&lt;=x&lt;y&lt;=50)，判定该表达式的值是否都为素数。</p><p>经典大素数判定问题，大一上的ACM选修课专门讲过…</p><p>如果我们对每一个数进行素数判断，而素数判断的复杂度又是 O(n)，那么复杂度就是 O(n^2)，而数据很大的情况绝对是超时的。所以我们采用填坑法，所有素数的倍数都不是素数，其他的数就是素数了，填坑法的复杂度只需要 O((logn)^2)，所以没被填的坑就是素数了，最后的判断就很简单了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.c</span></span><br><span class="line"><span class="comment">//  OJ-HD-2012</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by panliang on 2021/3/11.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> prime[<span class="number">2610</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initPrime</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    initPrime();</span><br><span class="line">    <span class="comment">// number = n^2+n+41</span></span><br><span class="line">    <span class="comment">// n = x ~ y</span></span><br><span class="line">    <span class="comment">// n is between 41 ~ 2591</span></span><br><span class="line">    <span class="keyword">int</span> x,y,n,number;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y) &amp;&amp;!(x==<span class="number">0</span>&amp;&amp;y==<span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">int</span> isPutSorry=<span class="number">0</span>;</span><br><span class="line">        n = x;</span><br><span class="line">        <span class="keyword">while</span>(n&lt;=y) &#123;</span><br><span class="line">            number = n*n+n+<span class="number">41</span>;</span><br><span class="line">            <span class="keyword">if</span> (!isPrime(number)) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Sorry\n&quot;</span>);</span><br><span class="line">                isPutSorry=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!isPutSorry)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;OK\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initPrime</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(prime,<span class="number">0</span>,<span class="keyword">sizeof</span>(prime));  <span class="comment">// 初始化为0 =&gt; 都是素数</span></span><br><span class="line">    <span class="comment">// 51*51 = 2601</span></span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">2</span>; <span class="comment">// 所有素数的倍数都不是素数</span></span><br><span class="line">    <span class="keyword">for</span> (;i&lt;=<span class="number">51</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> t=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (;t&lt;=i;t++) &#123;</span><br><span class="line">            prime[i*t] = <span class="number">1</span>;     <span class="comment">// 标记为1 =&gt; 不是素数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> prime[a]?<span class="number">0</span>:<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2025-查找最大元素"><a href="#2025-查找最大元素" class="headerlink" title="2025-查找最大元素"></a>2025-查找最大元素</h2><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2025">原题链接</a></p><p>对于输入的每个字符串，查找其中的最大字母，在该字母后面插入字符串“(max)”。</p><p>这是一个简单的 ascii 字符排序问题</p><p>处理输入的时候因为可能有空格，需要自己写一个 getLine()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.c</span></span><br><span class="line"><span class="comment">//  OJ-HD-2025</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by panliang on 2021/3/11.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getLine</span><span class="params">(<span class="keyword">char</span>*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> table[<span class="number">300</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">110</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        getLine(str);</span><br><span class="line">        <span class="keyword">if</span>(str[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">memset</span>(table,<span class="number">0</span>,<span class="keyword">sizeof</span>(table));</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (;i&lt;<span class="number">110</span>;i++) &#123;   <span class="comment">// 扫描输入字符串,打表</span></span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            table[str[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> maxchar = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">299</span>;i&gt;<span class="number">0</span>;i--)&#123;  <span class="comment">// 反向扫描table 找到 maxchar</span></span><br><span class="line">            <span class="keyword">if</span>(table[i] != <span class="number">0</span>)&#123;</span><br><span class="line">                maxchar = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">110</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[i] == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (str[i] == maxchar) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%c(max)&quot;</span>,str[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,str[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getLine</span><span class="params">(<span class="keyword">char</span> * str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">char</span> c = getchar();</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">&#x27;\n&#x27;</span> || c == EOF)&#123;</span><br><span class="line">            str[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        str[i++] = c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2058-The-sum-problem"><a href="#2058-The-sum-problem" class="headerlink" title="2058-The sum problem"></a>2058-The sum problem</h2><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2058">原题链接</a></p><p>给定一个序列 1，2，3，…N，你的工作是计算所有可能的子序列，子序列的和是M。</p><p>输入：N，M（ 1 &lt;= N, M &lt;= 1000000000 ）</p><p>需要输出所有可能的序列 [x,y] 使得 x+…+y = M</p><p>又是子序列和的题目，我第一反应就是用等差数列求和公式+滑动窗口来做，这样时间复杂度是O(n)，因为每次循环 a 和 b 都在单向移动，但是超时了。</p><p>这是滑动窗口的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n,m;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m) &amp;&amp; n+m)&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">1</span>,b=<span class="number">1</span>,sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(b&lt;n)&#123;</span><br><span class="line">      sum = (a+b)*(b-a+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span>(sum&lt;m)</span><br><span class="line">        b++;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(sum&gt;m)</span><br><span class="line">        a++;</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d,%d]&quot;</span>,a,b);</span><br><span class="line">        b++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>超时了之后我考虑优化滑动窗口。我想着让窗口从右往左滑动，这样窗口大小不会变小，想着这样可能不会有回溯的过程，，写了半天最后发现其实并没有提高效率，还是超时了。但是从窗口大小的角度思考让我得到了灵感！</p><p>假设有 n 个窗口能够满足序列和刚好是 M，那么这 n 个窗口的长度一定是越来越短的，因为窗口内的元素越来越大了</p><p>分析一下每个窗口应该是什么情况：</p><ul><li>如果这个窗口宽度为1，那么显然就是 M 本身，也就是输出 [M,M]</li><li>如果这个窗口宽度为2，那么显然是这样的：(M/2向下取整) + (M/2向上取整)</li><li>如果这个窗口宽度为3，那么显然是这样的：(M/3-1) + (M/3) + (M/3+1)</li><li>……</li></ul><p>显然窗口宽度和窗口内容是密切相关的</p><p>这样复杂度会显著降低了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.c</span></span><br><span class="line"><span class="comment">//  OJ-HD-2058</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by panliang on 2021/3/11.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxsize 200</span></span><br><span class="line"><span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">stack</span>[maxsize][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>[length][<span class="number">0</span>] = l;</span><br><span class="line">    <span class="built_in">stack</span>[length][<span class="number">1</span>] = r;</span><br><span class="line">    length++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isEmpty()) <span class="keyword">return</span>;</span><br><span class="line">    length--;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%d,%d]\n&quot;</span>,<span class="built_in">stack</span>[length][<span class="number">0</span>],<span class="built_in">stack</span>[length][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m) &amp;&amp; n &amp;&amp; m)&#123;</span><br><span class="line">        <span class="keyword">int</span> num=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(num&lt;m)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num%<span class="number">2</span> == <span class="number">1</span> &amp;&amp; m%num == <span class="number">0</span>)&#123;   <span class="comment">// num 为奇数 且能被m整除</span></span><br><span class="line">                <span class="keyword">int</span> center = m/num;</span><br><span class="line">                <span class="keyword">int</span> l = center-num/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(l&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> r = center+num/<span class="number">2</span>;</span><br><span class="line">                push(l,r);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(num%<span class="number">2</span> == <span class="number">0</span>)&#123;  <span class="comment">// num 为偶数</span></span><br><span class="line">                <span class="keyword">int</span> centerSmall = m/num;</span><br><span class="line">                <span class="keyword">int</span> l = centerSmall - num/<span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(l&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> r = centerSmall + num/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">int</span> sum = (l+r)*num/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(sum == m) push(l,r);</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// none</span></span><br><span class="line">            &#125;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!isEmpty())&#123;</span><br><span class="line">            pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了反过来输出结果，我写了一个栈。虽然对窗口大小由大到小遍历可以省略栈，但是会增加遍历的次数，窗口由小往大遍历的话我们就可以在 (这种情况) =&gt; {要从负数开始加到正数才等于M} 直接跳出循环，这时窗口更大是不可能了，窗口最左边已经到负数了，跳出循环可以显著降低循环次数。</p><p>这次终于AC了！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;刷刷OJ放松一下&quot;&gt;&lt;a href=&quot;#刷刷OJ放松一下&quot; class=&quot;headerlink&quot; title=&quot;刷刷OJ放松一下&quot;&gt;&lt;/a&gt;刷刷OJ放松一下&lt;/h1&gt;&lt;h2 id=&quot;1001-数列和&quot;&gt;&lt;a href=&quot;#1001-数列和&quot; class=&quot;head</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ML学习笔记-2</title>
    <link href="https://panlianghnu.github.io/2021/03/10/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/"/>
    <id>https://panlianghnu.github.io/2021/03/10/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/</id>
    <published>2021-03-10T07:10:34.000Z</published>
    <updated>2021-03-14T14:59:14.515Z</updated>
    
    <content type="html"><![CDATA[<p>学习算法可能有很多 feature、attribute</p><p>如何处理无穷多的 feature 而不爆内存，比如 support vector machine </p><p>监督学习就是对数据集标 label ，然后算法预测正确值</p><h1 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h1><h2 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h2><h3 id="聚类算法"><a href="#聚类算法" class="headerlink" title="聚类算法"></a>聚类算法</h3><p>聚类算法-clustering: 给许多没有label或相同label的数据，在data set 里面找到structure，分成几个 cluster，这就叫聚类算法</p><p>比如谷歌新闻每天收集成千上万的新闻，将他们组成一个个新闻专题，点击URL跳转到其他公司的网站</p><p>比如社交网络划分圈子，比如客户画像</p><blockquote><p>聚类算法和分类算法的比较</p><p>聚类分析是研究如何在没有训练的条件下把样本划分为若干类。<br>在分类中，对于目标数据库中存在哪些类是知道的，要做的就是将每一条记录分别属于哪一类标记出来。<br>聚类需要解决的问题是将已给定的若干无标记的模式聚集起来使之成为有意义的聚类，聚类是在<strong>预先不知道目标数据库到底有多少类</strong>的情况下，希望将所有的记录组成不同的类或者说聚类，并且使得在这种分类情况下，以某种度量（例如：距离）为标准的相似性，在同一聚类之间最小化，而在不同聚类之间最大化。<br>无监督学习不依赖预先定义的类或带类标记的训练实例，需要<strong>由聚类学习算法自动确定标记</strong></p><p>分类学习的实例或数据样本有类别标记。</p></blockquote><h3 id="鸡尾酒会问题"><a href="#鸡尾酒会问题" class="headerlink" title="鸡尾酒会问题"></a>鸡尾酒会问题</h3><p>两个人都在说话，传到两个距离不一的麦克风，用算法将叠加在一起的声音们分离出开。将多个音源的录音分离出声音。</p><p>吴恩达推荐 octave，作为机器学习编程环境</p><blockquote><p>矩阵乘法具有结合律但没有交换律</p><p>AxBxC = Ax(BxC)</p><p>AxB != BxA</p></blockquote><h2 id="多元线性回归"><a href="#多元线性回归" class="headerlink" title="多元线性回归"></a>多元线性回归</h2><h3 id="假设函数"><a href="#假设函数" class="headerlink" title="假设函数"></a>假设函数</h3><p><img src="/2021/03/10/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/image-20210311222721023.png" alt="image-20210311222721023"></p><p>x 是一个包含 features 的 vector，乘以各个待求系数的 vector，即为假设函数</p><h3 id="使用梯度下降解决多元线性回归"><a href="#使用梯度下降解决多元线性回归" class="headerlink" title="使用梯度下降解决多元线性回归"></a>使用梯度下降解决多元线性回归</h3><p><img src="/2021/03/10/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/image-20210311223151543.png" alt="image-20210311223151543"></p><p>不断地求 cost function 各个参数的偏导，然后向量减法调整参数的值</p><p><img src="/2021/03/10/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/image-20210311223225493.png" alt="image-20210311223225493"></p><p>怎么求偏导不重要，各种开源库</p><h3 id="特征缩放"><a href="#特征缩放" class="headerlink" title="特征缩放"></a>特征缩放</h3><p>假设x1是房屋面积(0~2000)，x2是卧室数量(0~5)</p><p>他们取值范围差别很大时，最终的梯度下降等高线会成为特别瘦长的椭圆，梯度下降会来回振荡(偏导可能不会指向 HIT )，下降的很慢</p><p><img src="/2021/03/10/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/image-20210311224754875.png" alt="image-20210311224754875"></p><p>尽量让 feature 的取值集中在 -1 ~ 1</p><p><img src="/2021/03/10/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/image-20210311224930834.png" alt="image-20210311224930834"></p><p>各个 feature 的数量级要一致</p><p>具体的操作为：</p><p><img src="/2021/03/10/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/image-20210311225057398.png" alt="image-20210311225057398"></p><p>特征缩放不需要很精确，只是让梯度下降快速一些</p><p>feature 的次方不同时，参数进行特征缩放很重要：</p><p><img src="/2021/03/10/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/image-20210311230909926.png" alt="image-20210311230909926"></p><h3 id="学习率选择"><a href="#学习率选择" class="headerlink" title="学习率选择"></a>学习率选择</h3><p>只要学习率足够小，cost function 会随着迭代不断下降，最终会收敛，但是算法效率会很慢</p><p>学习率太大，则可能不会每次 cost function 都下降，甚至无法收敛</p><h3 id="正规方程法（非迭代）"><a href="#正规方程法（非迭代）" class="headerlink" title="正规方程法（非迭代）"></a>正规方程法（非迭代）</h3><p>一次性求出参数的最佳值</p><p>算法：</p><p>cost function 是参数的 function，那么可以直接求出该 function 的最小值，以及 cost function 取最小时，参数等于多少。比如求导+令导数=0。或者求出所有偏导并令所有偏导等于0。偏微分可能很复杂</p><h2 id="梯度下降和正规方程法比较"><a href="#梯度下降和正规方程法比较" class="headerlink" title="梯度下降和正规方程法比较"></a>梯度下降和正规方程法比较</h2><p>梯度下降</p><ul><li><p>更普遍适用，即使有上百万 features 也可以正常运行</p></li><li><p>适合更复杂的学习算法</p></li></ul><p>正规方程法：</p><ul><li><p>不需要特征缩放，不需要选择学习率，不需要迭代，不用检查收敛，n 比较小时快得多</p></li><li><p>但是计算值的复杂度大概是 n^3，n 为 feature 数量，计算会比梯度下降慢很多，如果 n 大于万级，则不要使用正规方程法</p></li><li><p>不适合更复杂的学习算法，比如分类算法逻辑回归</p></li></ul><h2 id="向量化"><a href="#向量化" class="headerlink" title="向量化"></a>向量化</h2><p>计算假设函数时，使用向量有很多好处</p><p>模型预测的向量化</p><script type="math/tex; mode=display">h_\theta(x) = \sum_{j=0}^n \theta_j x_j \Rightarrow h_\theta(x) = \theta^Tx</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">prediction = <span class="number">0.0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    prediction = prediction + theta(i)*x(i)</span><br></pre></td></tr></table></figure><p>向量化后变成</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">theta = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">x = np.array([x1,x2,x3])</span><br><span class="line">prediction = np.matmul(theta.T, x) <span class="comment"># 转置巨震</span></span><br></pre></td></tr></table></figure><p>不需要自己写循环，而且更高效</p><p>Gradient descent 的向量化</p><p><img src="/2021/03/10/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/image-20210312165302732.png" alt="image-20210312165302732"></p><p>变成了简单的</p><script type="math/tex; mode=display">\theta = \theta - \alpha \delta</script><script type="math/tex; mode=display">\delta = \frac1m \sum_{i=1}^m (h_\theta x^{(i)}-y^{(i)})x^{(i)}</script><h2 id="逻辑回归-分类"><a href="#逻辑回归-分类" class="headerlink" title="逻辑回归(分类)"></a>逻辑回归(分类)</h2><p>最流行的学习算法</p><h3 id="二分类"><a href="#二分类" class="headerlink" title="二分类"></a>二分类</h3><p>比如可以简单的线性回归，设置一个阈值，大于输出1、小于输出0，但是这样做不准确，通常不是一个好主意，如图</p><p><img src="/2021/03/10/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/image-20210312171333206.png" alt="image-20210312171333206"></p><p>训练样本的错误率很高，无法很好拟合</p><p>逻辑回归：令 h(x) 处在0和1之间</p><script type="math/tex; mode=display">h_\theta(x) = g(\theta^Tx)</script><script type="math/tex; mode=display">g(z) = \frac1{1+e^{-z}}</script><p>这样就让 prediction 落在 [0,1] 了，function g is called logistics function</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;学习算法可能有很多 feature、attribute&lt;/p&gt;
&lt;p&gt;如何处理无穷多的 feature 而不爆内存，比如 support vector machine &lt;/p&gt;
&lt;p&gt;监督学习就是对数据集标 label ，然后算法预测正确值&lt;/p&gt;
&lt;h1 id=&quot;机器学习</summary>
      
    
    
    
    
    <category term="机器学习" scheme="https://panlianghnu.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>AOPEDF学习</title>
    <link href="https://panlianghnu.github.io/2021/03/03/AOPEDF%E5%AD%A6%E4%B9%A0/"/>
    <id>https://panlianghnu.github.io/2021/03/03/AOPEDF%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-03-03T11:26:04.000Z</published>
    <updated>2021-03-14T15:00:55.010Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实验复现"><a href="#实验复现" class="headerlink" title="实验复现"></a>实验复现</h2><h3 id="BUG1"><a href="#BUG1" class="headerlink" title="BUG1"></a>BUG1</h3><p>K-Fold交叉验证，参数多了一个 label[:,0]，n_folds 参数找不到（应该是 n_splits ?）</p><p><img src="/2021/03/03/AOPEDF%E5%AD%A6%E4%B9%A0/image-20210303192653242.png" alt="image-20210303192653242"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, n_splits=<span class="string">&#x27;warn&#x27;</span>, shuffle=<span class="literal">False</span>, random_state=<span class="literal">None</span></span>):</span></span><br><span class="line">  <span class="keyword">if</span> n_splits == <span class="string">&#x27;warn&#x27;</span>:</span><br><span class="line">    warnings.warn(NSPLIT_WARNING, FutureWarning)</span><br><span class="line">    n_splits = <span class="number">3</span></span><br><span class="line">    <span class="built_in">super</span>(StratifiedKFold, self).__init__(n_splits, shuffle, random_state)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;实验复现&quot;&gt;&lt;a href=&quot;#实验复现&quot; class=&quot;headerlink&quot; title=&quot;实验复现&quot;&gt;&lt;/a&gt;实验复现&lt;/h2&gt;&lt;h3 id=&quot;BUG1&quot;&gt;&lt;a href=&quot;#BUG1&quot; class=&quot;headerlink&quot; title=&quot;BUG1&quot;&gt;&lt;/a</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Vue学习1</title>
    <link href="https://panlianghnu.github.io/2021/03/02/Vue%E5%AD%A6%E4%B9%A01/"/>
    <id>https://panlianghnu.github.io/2021/03/02/Vue%E5%AD%A6%E4%B9%A01/</id>
    <published>2021-03-02T08:07:04.000Z</published>
    <updated>2021-03-25T08:42:18.990Z</updated>
    
    <content type="html"><![CDATA[<h1 id="VueJs"><a href="#VueJs" class="headerlink" title="VueJs"></a>VueJs</h1><h2 id="声明式渲染"><a href="#声明式渲染" class="headerlink" title="声明式渲染"></a>声明式渲染</h2><p>Vue 应用会将其挂载到一个 DOM 元素(比如DIV) 上，然后对其完全控制</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; message &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: <span class="string">&#x27;Hello Vue!&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>结果显示 Hello Vue！</p><p>不仅可以绑定到 DOM 的文本或 attribute，还可以绑定到 DOM 结构：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">&quot;seen&quot;</span>&gt;</span>可以看到吗<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;app.$data.seen=!app.$data.seen&quot;</span>&gt;</span>切换可见<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    seen: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当一个 Vue 实例被创建时，它将 <code>data</code> 对象中的所有的 property 加入到 Vue 的<strong>响应式系统</strong>中。当这些 property 的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。</p><p>当这些数据改变时，视图会进行重渲染。只有当 Vue 实例被创建时就已经存在于 <code>data</code> 中的 property 才是<strong>响应式</strong>的。也就是说如果你添加一个新的 property，比如：vm.newdata = ‘new’ ，则对 newdata 不触发渲染。如果你知道你会在晚些时候需要一个 property，但是一开始它为空或不存在，那么你仅<strong>需要设置一些初始值</strong>。data:{ newdata: ‘’ }</p><p>唯一的例外是使用 <code>Object.freeze()</code>，这会阻止修改现有的 property，也意味着响应系统无法再<em>追踪</em>变化。</p><p>Vue 实例还暴露了一些有用的实例 property 与方法，都以$开头，和用户自定义的 property 和 methods 区分：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#example&#x27;</span>,</span><br><span class="line">  data: data</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">vm.$data === data <span class="comment">// =&gt; true</span></span><br><span class="line">vm.$el === <span class="built_in">document</span>.getElementById(<span class="string">&#x27;example&#x27;</span>) <span class="comment">// =&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// $watch 是一个实例方法</span></span><br><span class="line">vm.$watch(<span class="string">&#x27;a&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">newValue, oldValue</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这个回调将在 `vm.a` 改变后调用</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="实例生命周期钩子-hook"><a href="#实例生命周期钩子-hook" class="headerlink" title="实例生命周期钩子(hook)"></a>实例生命周期钩子(hook)</h2><p><img src="/2021/03/02/Vue%E5%AD%A6%E4%B9%A01/lifecycle.png" alt="lifecycle"></p><p><img src="/2021/03/02/Vue%E5%AD%A6%E4%B9%A01/image-20210302163430490.png" alt="image-20210302163430490"></p><p>注意⚠️：钩子函数不要写成 ()=&gt;{} ，箭头函数没有 this</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>Vue.js 使用了基于 HTML 的模板语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。所有 Vue.js 的模板都是合法的 HTML，所以能被遵循规范的浏览器和 HTML 解析器解析。</p><p>在底层的实现上，<strong>Vue 将模板编译成虚拟 DOM 渲染函数</strong>。结合响应系统，Vue 能够<strong>智能地计算出最少需要重新渲染多少组件</strong>，并把 DOM 操作次数减到最少。</p><h3 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h3><h4 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h4><p>数据绑定最常见的形式就是使用“Mustache”语法 (双大括号) 的文本插值：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Message: &#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>无论何时，绑定的数据对象上 <code>msg</code> property 发生了改变，插值处的内容都会更新。</p><h4 id="原始-HTML"><a href="#原始-HTML" class="headerlink" title="原始 HTML"></a>原始 HTML</h4> 表达式会将 rawHtml 的值解析为文本，如果你希望它输出为 HTML，需要使用 v-html 指令：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data:&#123;<span class="attr">hello</span>:<span class="string">&quot;&lt;p style=&quot;</span>color:red<span class="string">&quot;&gt;hello&lt;/p&gt;&quot;</span>&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;hello&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-html</span>=<span class="string">&quot;hello&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>显示效果为:</p><p>\</p><p style="color:red">hello\</p><p></p><p style="color:red">hello</p><p>这个 <code>span</code> 的内容将会被替换成为 property 值 <code>hello</code>，直接作为 HTML——会忽略解析 property 值中的数据绑定。</p><blockquote><p>你的站点上动态渲染的任意 HTML 可能会非常危险，因为它很容易导致 <a href="https://en.wikipedia.org/wiki/Cross-site_scripting">XSS 攻击</a>。请只对可信内容使用 HTML 插值，<strong>绝不要</strong>对用户提供的内容使用插值。</p></blockquote><h4 id="Attribute"><a href="#Attribute" class="headerlink" title="Attribute"></a>Attribute</h4><p>Mustache 语法不能作用在 HTML attribute 上，需要使用 v-bind 指令</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">&quot;dynamicId&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>    <span class="comment">&lt;!-- 正确 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#123;&#123;dynamicId&#125;&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>         <span class="comment">&lt;!-- 错误 --&gt;</span></span><br></pre></td></tr></table></figure><h4 id="使用-JavaScript-表达式"><a href="#使用-JavaScript-表达式" class="headerlink" title="使用 JavaScript 表达式"></a>使用 JavaScript 表达式</h4><p>可以这样绑定 JS 的表达式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; number + 1 &#125;&#125;</span><br><span class="line">&#123;&#123; ok ? &#x27;YES&#x27; : &#x27;NO&#x27; &#125;&#125;  // 不要用 if()&#123;&#125;</span><br><span class="line">&#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">&quot;&#x27;list-&#x27; + id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>模板表达式都被放在沙盒中，只能访问<strong>全局变量的一个白名单</strong>，如 <code>Math</code> 和 <code>Date</code> 。你不应该在模板表达式中试图访问用户定义的全局变量。</p></blockquote><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p>指令 (Directives) 是带有 <code>v-</code> 前缀的特殊 attribute。指令 attribute 的值预期是单个表达式，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。</p><p>比如 v-if=”seen” ，当 seen 为 false，该 DOM 对象不会显示</p><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>一些指令能接受一个参数，在指令名称后以冒号表示。</p><p>比如 v-bind 指令：可以响应式更新 HTML attribute</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>比如 v-on 指令：用于监听  DOM 事件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span> </span><br><span class="line">// 鼠标点击会触发 vue 对象的 methods:dosomething()</span><br></pre></td></tr></table></figure><h4 id="动态参数"><a href="#动态参数" class="headerlink" title="动态参数"></a>动态参数</h4><blockquote><p>2.6.0 新增</p></blockquote><p>从 2.6.0 开始，可以用方括号括起来的 JavaScript 表达式作为一个指令的参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">注意，参数表达式的写法存在一些约束，如之后的“对动态参数表达式的约束”章节所述。</span><br><span class="line">--&gt;</span><br><span class="line">&lt;a v-bind:[attributeName]&#x3D;&quot;url&quot;&gt; ... &lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure><p>这里的 <code>attributeName</code> 会被作为一个 JavaScript 表达式进行动态求值，求得的值将会作为最终的参数来使用。例如，如果你的 Vue 实例有一个 <code>data</code> property <code>attributeName</code>，其值为 <code>&quot;href&quot;</code>，那么这个绑定将等价于 <code>v-bind:href</code>。</p><p>同样地，你可以使用动态参数为一个动态的事件名绑定处理函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a v-on:[eventName]&#x3D;&quot;doSomething&quot;&gt; ... &lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure><p>在这个示例中，当 <code>eventName</code> 的值为 <code>&quot;focus&quot;</code> 时，<code>v-on:[eventName]</code> 将等价于 <code>v-on:focus</code>。</p><p>在 DOM 中使用模板时 (直接在一个 HTML 文件里撰写模板)，还需要避免使用大写字符来命名键名，因为浏览器会把 attribute 名全部强制转为小写：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">在 DOM 中使用模板时这段代码会被转换为 `v-bind:[someattr]`。</span></span><br><span class="line"><span class="comment">除非在实例中有一个名为“someattr”的 property，否则代码不会工作。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:</span>[<span class="attr">someAttr</span>]=<span class="string">&quot;value&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><h3 id="缩写"><a href="#缩写" class="headerlink" title="缩写"></a>缩写</h3><p><code>v-</code> 前缀作为一种视觉提示，用来识别模板中 Vue 特定的 attribute。</p><p>Vue 为 <code>v-bind</code> 和 <code>v-on</code> 这两个最常用的指令，提供了特定简写：</p><h4 id="v-bind-缩写"><a href="#v-bind-缩写" class="headerlink" title="v-bind 缩写"></a>v-bind 缩写</h4><p>直接省略 v-bind。以冒号开头即可</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 完整语法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 缩写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:</span>[<span class="attr">key</span>]=<span class="string">&quot;url&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="v-on-缩写"><a href="#v-on-缩写" class="headerlink" title="v-on 缩写"></a>v-on 缩写</h4><p>直接省略 v-on。以 @ 开头即可</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 完整语法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 缩写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> @<span class="attr">click</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> @[<span class="attr">event</span>]=<span class="string">&quot;doSomething&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2>、但是不应该在模版内放入复杂逻辑，这时候应该在模板内放入“计算属性”，同样能达到数据变化=>计算属性变化=>重渲染计算属性：实例化 Vue 对象时，增加 computed: {}，写入对应的“计算属性”的 function 作为该属性的 getter()注意⚠️，computed 和 methods 是不一样的，computed 是作为 getter 函数并会响应式渲染<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Original message: &quot;&#123;&#123; message &#125;&#125;&quot;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Computed reversed message: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#example&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: <span class="string">&#x27;Hello&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    <span class="comment">// 计算属性的 getter</span></span><br><span class="line">    reversedMessage: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// `this` 指向 vm 实例</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.message.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在这个例子中，message 发生变化则会触发 reversedMessage 的变化，message 和 reversedMessage 的绑定在 Vue 对象初始化时进行。</p><blockquote><p>你可以像绑定普通 property 一样在模板中绑定计算属性。Vue 知道 <code>vm.reversedMessage</code> 依赖于 <code>vm.message</code>，因此当 <code>vm.message</code> 发生改变时，所有依赖 <code>vm.reversedMessage</code> 的绑定也会更新。而且最妙的是我们已经以声明的方式创建了这种依赖关系：计算属性的 getter 函数是没有副作用 (side effect) 的，这使它更易于测试和理解。</p></blockquote><h3 id="计算属性-vs-方法"><a href="#计算属性-vs-方法" class="headerlink" title="计算属性 vs 方法"></a>计算属性 vs 方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  reversedMessage: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.message.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做最终显示出来的结果是完全相同的。</p><p>但是性能有差别：</p><p>计算属性是有响应式缓存的，当依赖没有变化的时候，多次访问 reversedMessage 会立刻返回之前的计算结果，而不会再次执行函数。</p><p>相比之下，每当触发重新渲染时，调用方法将<strong>总会</strong>再次执行函数。</p><blockquote><p>我们为什么需要缓存？假设我们有一个性能开销比较大的计算属性 <strong>A</strong>，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 <strong>A</strong>。如果没有缓存，我们将不可避免的多次执行 <strong>A</strong> 的 getter！如果你不希望有缓存，请用方法来替代。</p></blockquote><h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h2><p>v-if 条件渲染元素，可以配合 v-else-if、v-else 使用</p><p>v-show 和 v-if 基本一样，都能控制元素是否显示</p><p>v-if 是真正的条件渲染，是惰性的。而 v-show 是始终渲染，只简单的 CSS 切换 display</p><p>v-if 的切换开销更大，初始化开销更小</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;seen=!seen&quot;</span>&gt;</span>切换可见<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">&quot;seen&quot;</span>&gt;</span>可以看到吗<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    seen: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="循环渲染-事件"><a href="#循环渲染-事件" class="headerlink" title="循环渲染/事件"></a>循环渲染/事件</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;todo in todos&quot;</span>&gt;</span>&#123;&#123;todo.text&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;reverseList&quot;</span>&gt;</span>反转<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    todos: [</span><br><span class="line">      &#123; <span class="attr">text</span>: <span class="string">&#x27;学习 javascript&#x27;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">text</span>: <span class="string">&#x27;学习 Vue&#x27;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">text</span>: <span class="string">&#x27;学习前端&#x27;</span> &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    reverseList: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> str <span class="keyword">in</span> app.todos) &#123;</span><br><span class="line">        app.todos[str].text = </span><br><span class="line">          app.todos[str].text.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在控制台可以输入 app.todos.push({ text:’hello world’ }) 可以看到渲染是实时的</p><p>反转按钮会触发 v-on:click 事件，对 List 的所有元素 reverse</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;VueJs&quot;&gt;&lt;a href=&quot;#VueJs&quot; class=&quot;headerlink&quot; title=&quot;VueJs&quot;&gt;&lt;/a&gt;VueJs&lt;/h1&gt;&lt;h2 id=&quot;声明式渲染&quot;&gt;&lt;a href=&quot;#声明式渲染&quot; class=&quot;headerlink&quot; title=&quot;声明式</summary>
      
    
    
    
    
    <category term="Vue" scheme="https://panlianghnu.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>简单树形P2P网络实现</title>
    <link href="https://panlianghnu.github.io/2021/02/19/%E7%AE%80%E5%8D%95%E6%A0%91%E5%BD%A2P2P%E7%BD%91%E7%BB%9C%E5%AE%9E%E7%8E%B0/"/>
    <id>https://panlianghnu.github.io/2021/02/19/%E7%AE%80%E5%8D%95%E6%A0%91%E5%BD%A2P2P%E7%BD%91%E7%BB%9C%E5%AE%9E%E7%8E%B0/</id>
    <published>2021-02-19T04:36:20.000Z</published>
    <updated>2021-03-19T15:26:36.654Z</updated>
    
    <content type="html"><![CDATA[<p>树形结构：</p><p>先写一个种子文件，种子文件里是一个根节点的URL（单点故障）<del>后面可以改成多个节点们</del></p><p>新的客户端接入该 P2P 网络</p><ul><li>先读取种子文件，找到根节点</li><li>根节点给客户端分配一个（多个）节点，并给其一个ID</li><li>客户端连接上这些节点</li><li>客户端监听 http、p2p 端口 <em>自己设置</em>，并告诉根节点</li></ul><p>根节点维护全局节点的信息，普通节点维护相连的节点的信息</p><p>每个节点退出时，向根节点发送退出消息，根节点维护节点列表</p><p>我写的比较简单，根节点只维护了node_ID列表，但是这样会有bug</p><ul><li>某个节点退出时，删除了该节点的子节点而子节点并未结束程序，新的子节点到来，旧的子节点结束时又发送退出消息，这个时候根节点会错误的将新来的子节点也删除。</li><li><p>bug出现原因：node_ID不能唯一标识节点</p></li><li><p>解决方法：根节点不止维护node_ID，还维护每个节点的端口号，因为端口号是向操作系统随机申请的，可以认为唯一代表某个节点，或者我们可以在节点申请getPeer的时候记录时间，用时间唯一标识节点，将维护一个node_ID列表变成维护一个time列表，可以fix这个bug，但是我懒得写了…</p></li></ul><p>测试</p><p>还是一样的 访问 http/ping</p><p>每个节点会把 “I am alive” 发送给相邻节点  =》根节点会收到所有节点的消息</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;树形结构：&lt;/p&gt;
&lt;p&gt;先写一个种子文件，种子文件里是一个根节点的URL（单点故障）&lt;del&gt;后面可以改成多个节点们&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;新的客户端接入该 P2P 网络&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先读取种子文件，找到根节点&lt;/li&gt;
&lt;li&gt;根节点给客户端分配一个（</summary>
      
    
    
    
    
    <category term="nodejs" scheme="https://panlianghnu.github.io/tags/nodejs/"/>
    
    <category term="P2P" scheme="https://panlianghnu.github.io/tags/P2P/"/>
    
  </entry>
  
  <entry>
    <title>基于WebSocket的聊天室</title>
    <link href="https://panlianghnu.github.io/2021/02/04/%E5%9F%BA%E4%BA%8EWebSocket%E7%9A%84%E8%81%8A%E5%A4%A9%E5%AE%A4/"/>
    <id>https://panlianghnu.github.io/2021/02/04/%E5%9F%BA%E4%BA%8EWebSocket%E7%9A%84%E8%81%8A%E5%A4%A9%E5%AE%A4/</id>
    <published>2021-02-04T01:57:56.000Z</published>
    <updated>2021-03-14T14:59:57.523Z</updated>
    
    <content type="html"><![CDATA[<p>源码见：<a href="https://github.com/panlianghnu/WebSocketChat">github</a></p><h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><h3 id="使用-‘express’-封装-http-请求，监听7777端口，返回前端页面"><a href="#使用-‘express’-封装-http-请求，监听7777端口，返回前端页面" class="headerlink" title="使用 ‘express’ 封装 http 请求，监听7777端口，返回前端页面"></a>使用 ‘express’ 封装 http 请求，监听7777端口，返回前端页面</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)()    <span class="comment">// 封装 http </span></span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>,<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">res.sendFile(__dirname + <span class="string">&#x27;/chat.html&#x27;</span>)   <span class="comment">// 返回页面</span></span><br><span class="line">&#125;)</span><br><span class="line">app.listen(<span class="number">7777</span>,<span class="string">&#x27;localhost&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="使用-nodejs-websocket-工具包处理聊天，监听8888端口"><a href="#使用-nodejs-websocket-工具包处理聊天，监听8888端口" class="headerlink" title="使用 nodejs-websocket 工具包处理聊天，监听8888端口"></a>使用 nodejs-websocket 工具包处理聊天，监听8888端口</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ws = <span class="built_in">require</span>(<span class="string">&#x27;nodejs-websocket&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> server = ws.createServer(<span class="function">(<span class="params">socket</span>) =&gt;</span> &#123;    <span class="comment">// 处理聊天</span></span><br><span class="line"><span class="keyword">var</span> username = socket.path</span><br><span class="line"><span class="built_in">console</span>.log(username + <span class="string">&#x27; 加入群聊&#x27;</span>)</span><br><span class="line">clientList.push(socket)</span><br><span class="line">broadcast(username + <span class="string">&#x27; 加入群聊&#x27;</span>)</span><br><span class="line"></span><br><span class="line">socket.on(<span class="string">&#x27;text&#x27;</span>,<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(username + <span class="string">&#x27;: &#x27;</span>+data)</span><br><span class="line">broadcast(username + <span class="string">&#x27;: &#x27;</span> + data)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">socket.on(<span class="string">&#x27;close&#x27;</span>,<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(username + <span class="string">&#x27; 退出群聊&#x27;</span>)</span><br><span class="line">deleteSocketFromList(socket)</span><br><span class="line">broadcast(username + <span class="string">&#x27; 退出群聊&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;).listen(<span class="number">8888</span>)</span><br></pre></td></tr></table></figure><p>客户端刚连接服务器时，服务器会用链表 clientList 保存这个 socket 连接，并进行广播 “xxx加入群聊”。</p><p>设置了两个事件</p><ul><li>text 事件，客户端向服务器发送消息时触发<ul><li>服务器向所有客户端广播该消息</li></ul></li><li>close 事件，客户端失去连接时触发<ul><li>服务器删除该 socket 对象，并广播给其他客户端</li></ul></li></ul><h3 id="广播的实现"><a href="#广播的实现" class="headerlink" title="广播的实现"></a>广播的实现</h3><p>遍历 socket ，调用 send 发送消息</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">broadcast</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;clientList.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(clientList[i] !== <span class="literal">null</span>)&#123;</span><br><span class="line">clientList[i].send(data)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><h3 id="定义-url-和-ws-对象"><a href="#定义-url-和-ws-对象" class="headerlink" title="定义 url 和 ws 对象"></a>定义 url 和 ws 对象</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">&quot;ws://localhost:8888/&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> ws = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h3 id="加入群聊，即初始化-websocket-对象，并绑定事件"><a href="#加入群聊，即初始化-websocket-对象，并绑定事件" class="headerlink" title="加入群聊，即初始化 websocket 对象，并绑定事件"></a>加入群聊，即初始化 websocket 对象，并绑定事件</h3><p>username 通过用户输入，调用 document.getElementById 得到内容</p><p>直接在连接时的 url 字符串后面拼接 username，后端识别 path 得到用户名</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">joinRoom</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ws) &#123;</span><br><span class="line">    alert(<span class="string">&quot;你已经在聊天室，不能再加入&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> username = <span class="built_in">document</span>.getElementById(<span class="string">&quot;user&quot;</span>).value;</span><br><span class="line">  ws = <span class="keyword">new</span> WebSocket(url + username);</span><br><span class="line">  <span class="comment">//与服务端建立连接触发</span></span><br><span class="line">  ws.onopen = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;与服务器成功建立连接&quot;</span>)</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//服务端推送消息触发</span></span><br><span class="line">  ws.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">ev</span>) </span>&#123;</span><br><span class="line">    talking(ev.data);     <span class="comment">// 接收数据，刷新页面</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//发生错误触发</span></span><br><span class="line">  ws.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;连接错误&quot;</span>)</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//正常关闭触发</span></span><br><span class="line">  ws.onclose = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;连接关闭&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendMsg</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!ws)&#123;</span><br><span class="line">    alert(<span class="string">&quot;你已掉线，请重新加入&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//消息发送</span></span><br><span class="line">  ws.send(<span class="built_in">document</span>.getElementById(<span class="string">&quot;sendMsg&quot;</span>).value);</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&quot;sendMsg&quot;</span>).value = <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先判断是否已经初始化 websocket 对象</p><h3 id="接收数据，刷新页面"><a href="#接收数据，刷新页面" class="headerlink" title="接收数据，刷新页面"></a>接收数据，刷新页面</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">talking</span>(<span class="params">content</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&quot;content&quot;</span>).append(content + <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">content 是一个 &lt;textarea/&gt; 对象</span><br></pre></td></tr></table></figure><h3 id="GUI"><a href="#GUI" class="headerlink" title="GUI"></a>GUI</h3><p><img src="/2021/02/04/%E5%9F%BA%E4%BA%8EWebSocket%E7%9A%84%E8%81%8A%E5%A4%A9%E5%AE%A4/image-20210219103207635.png" alt="image-20210219103207635"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;源码见：&lt;a href=&quot;https://github.com/panlianghnu/WebSocketChat&quot;&gt;github&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;后端&quot;&gt;&lt;a href=&quot;#后端&quot; class=&quot;headerlink&quot; title=&quot;后端&quot;&gt;&lt;/a&gt;后端&lt;</summary>
      
    
    
    
    
    <category term="websocket" scheme="https://panlianghnu.github.io/tags/websocket/"/>
    
    <category term="聊天室" scheme="https://panlianghnu.github.io/tags/%E8%81%8A%E5%A4%A9%E5%AE%A4/"/>
    
  </entry>
  
  <entry>
    <title>ML学习笔记-1</title>
    <link href="https://panlianghnu.github.io/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/"/>
    <id>https://panlianghnu.github.io/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/</id>
    <published>2021-01-03T08:45:14.000Z</published>
    <updated>2021-03-14T14:59:21.364Z</updated>
    
    <content type="html"><![CDATA[<h1 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h1><p>机器学习就是让机器自动找函数</p><p><img src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210101104434728.png" alt="image-20210101104434728"></p><p>Regression：输出数值</p><p>Classification：二分类、多类分类</p><p>Generation：生成有复杂结构的东西（如翻译，画二次元头像）</p><h2 id="如何告诉机器，想要什么样的函数"><a href="#如何告诉机器，想要什么样的函数" class="headerlink" title="如何告诉机器，想要什么样的函数"></a>如何告诉机器，想要什么样的函数</h2><p>Supervised learning  有监督学习，对每个 input，给出一个标准 output，需要对资料做 label</p><p>机器就可以对生成的函数做一个评估，有一个 loss function，用来计算 function 的好坏</p><p>Reinforcement learning  强化学习，比如阿尔法狗，让机器和自己、别人下棋，然后赢了，机器会知道这样下比较好，哪几步比较好还不是很清楚</p><blockquote><p>强化学习是智能体（Agent）以“试错”的方式进行学习，通过与环境进行交互获得的奖赏指导行为，目标是使智能体获得最大的奖赏，强化学习不同于连接主义学习中的监督学习，主要表现在强化信号上，强化学习中由环境提供的强化信号是对产生动作的好坏作一种评价(通常为标量信号)，而不是告诉强化学习系统RLS(reinforcement learning system)如何去产生正确的动作。由于外部环境提供的信息很少，RLS必须靠自身的经历进行学习。通过这种方式，RLS在行动-评价的环境中获得知识，改进行动方案以适应环境。</p></blockquote><h2 id="机器如何找到函数"><a href="#机器如何找到函数" class="headerlink" title="机器如何找到函数"></a>机器如何找到函数</h2><h3 id="1、给定函数范围"><a href="#1、给定函数范围" class="headerlink" title="1、给定函数范围"></a>1、给定函数范围</h3><p>linear function </p><p>network architecture  RNN循环神经网络  CNN卷积神经网络</p><h3 id="2、函数寻找方法"><a href="#2、函数寻找方法" class="headerlink" title="2、函数寻找方法"></a>2、函数寻找方法</h3><p>Gradient Descent 梯度下降</p><p><img src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210101111415435.png" alt="image-20210101111415435"></p><p>Anomaly detection 能不能知道 自己不知道</p><p>meta learning   让机器学习如何学习，让机器自己设计学习的方法</p><h2 id="Regression"><a href="#Regression" class="headerlink" title="Regression"></a>Regression</h2><p>输出数值（Scalar）</p><p>比如无人车驾驶：input 一些sensor ，输出方向盘角度</p><p>比如推荐系统：input A和商品B，输出A购买B的可能性</p><p>比如宝可梦：输入某只宝可梦，输出他进化后的CP值</p><p>三个步骤</p><p>1、找到一个model（A set of functions）比如线性model cp_new = b + w*cp_old</p><p><img src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210101162247930.png" alt="image-20210101162247930"></p><p>2、定义 Loss function，输入一个 function，输出一个 function 评估结果</p><p><img src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210101162204542.png" alt="image-20210101162204542"></p><p>这里采用的平方 loss function ，用真实数据减去预测数值再取平方</p><p>3、找一个最好的 function</p><p><img src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210101163034130.png" alt="image-20210101163034130"></p><p>穷举所有的 w 和 b，求出最好的 w 和 b</p><p>Gradient Descent，可以处理任何可以微分的 function</p><p><img src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210101163613411.png" alt="image-20210101163613411"></p><p>随机选取初始 w0，再初始w0这个位置，计算w参数对L的微分（切线斜率），若斜率为负，则右边 loss 较低，应该增加 w0，增加量为：微分值*(learning rate) </p><p>就这样不断地求 w，直到 w 到达 local optimal，但是会陷入局部最优（当然 linear set 没有局部最优）</p><p>如果有两个参数呢？</p><p><img src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210101164005142.png" alt="image-20210101164005142"></p><p><img src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210101164409136.png" alt="image-20210101164409136"></p><p>其实算出来的就是等高线的法线方向</p><p><img src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210101164451537.png" alt="image-20210101164451537"></p><p>这种情况就会陷入局部最优，但 linear regression 没有 local optimal</p><p>求出来 b 和 w 之后，我们关心新数据和预测函数的误差，发现比较大</p><p>重新设计 model</p><p>二次式：y = b + w1<em>Xcp + w2</em>*(Xcp)^2</p><p>一样的用刚才的算法去求最好的 b、w1、w2</p><p>三次式：y = b + w1<em>Xcp + w2\</em>(Xcp)^2 + w3*(Xcp)^3</p><p>四次式：。。。不断地拟合，loss function()的值不断变小，但是 test data 效果却更差，这波啊，这波是过拟合</p><p><img src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210103132844166.png" alt="image-20210103132844166"></p><p>如图，training data 效果特别好，但是显然不是一个合理的宝可梦CP预测的 function</p><p><img src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210103133116007.png" alt="image-20210103133116007"></p><p>越复杂的model、我们可以找到 training data 的loss function 最低的 function，但是在testing data 的结果是不一样的</p><p><img src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210103133206717.png" alt="image-20210103133206717"></p><p>testing 的结果反而变差了，拟合的并不是很好（Overfitting）</p><h3 id="overfitting"><a href="#overfitting" class="headerlink" title="overfitting"></a>overfitting</h3><p><img src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210103143405103.png" alt="image-20210103143405103"></p><p>model 并不是越复杂越好</p><p>当收集足够多的数据之后，发现并不是简单的和旧CP值有关</p><p><img src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210103133652548.png" alt="image-20210103133652548"></p><p>物种是有关键性影响的，重新设计 model ，将 物种（species）考虑进去</p><p><img src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210103133802784.png" alt="image-20210103133802784"></p><p><img src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210103133924202.png" alt="image-20210103133924202"></p><p>这也是一个线性拟合…为啥不分四个训练集呢。。感觉就像是把 Xcp这个 feature 分成四个 feature了，分别表示对四个种类的 cp 值</p><p>来个更复杂的 model</p><p><img src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210103134601138.png" alt="image-20210103134601138"></p><p>对 eevee 考虑的更加复杂一些，其实也不是很复杂，作业可能几百个参数。。。</p><p>然后算出来 loss 为1.4，testing data loss 102.3，显然 overfitting 了</p><h3 id="如何避免-overfitting"><a href="#如何避免-overfitting" class="headerlink" title="如何避免 overfitting"></a>如何避免 overfitting</h3><p>回到 regularization ，redesigned loss function </p><p>loss function 不应该只考虑误差平方和，还应该加上 wi (wi 为各级x的系数) 的平方和，为什么？</p><p><img src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210103145609976.png" alt="image-20210103145609976"></p><p>因为当 wi 比较小，则求出来的 function 比较平滑，输出对输入更加不敏感</p><p>更倾向于平滑的 function，因为越平滑，收到 noise 的影响越小</p><p>不断的调节 <em>λ</em> ，求出结果， <em>λ</em> 越大则考虑平滑越多</p><p>发现越平滑，考虑的err越少，则 training data 的结果越糟糕，但是 testing data 效果反而可能好一些，所以需要调节  <em>λ</em> 来决定 function 的平滑程度，（调节平滑不需要考虑 b）</p><p><img src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210103152631989.png" alt="image-20210103152631989"></p><p>总结：宝可梦的当前CP和物种决定几乎进化后的CP值（可能还有其他因素）</p><p>梯度下降，过度拟合和考虑平滑</p><h3 id="error-来自哪里"><a href="#error-来自哪里" class="headerlink" title="error 来自哪里"></a>error 来自哪里</h3><p>来自 bias 平均</p><p>来自 variance 方差</p><p><img src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210103154345098.png" alt="image-20210103154345098"></p><p><img src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210103154955082.png" alt="image-20210103154955082"></p><p>error 来自 bias，说明你没有瞄准好，导致估计值偏离真实值</p><p>error 来自 variance，说明你射的不够稳，还没有收敛/773.0</p><p><img src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210103155658459.png" alt="image-20210103155658459"></p><p>求各个模型的 f*（100组不同数据） ，发现简单的 model 是比较集中的，即 variance 比较小，不容易散开</p><p>model 比较复杂的话，function 散布就会很开，variance 比较开</p><p>为什么？</p><p>因为 model 比较复杂，受到不同的 data 影响比较大</p><p>bias：large bias，如何评测 f* 和 f^ 的 bias 差多少？</p><p><img src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210103160043302.png" alt="image-20210103160043302"></p><p>这里用红色表示各个 function 的结果，蓝色表示平均值，黑色表示正确答案，</p><p><img src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210103160242454.png" alt="image-20210103160242454"></p><p>可以看到，虽然这些 f<em> 不知道飘到哪里去了，但是平均起来看，f</em> 和 f^ 还是比较接近的，即 复杂的 model 的 bias 还是比较小的</p><p>所以，当你的 model 越来越复杂，bias 会越来越小，variance 会越来越大</p><p><img src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210103160649516.png" alt="image-20210103160649516"></p><h4 id="如何分辨现在是-underfitting-还是-overfitting？"><a href="#如何分辨现在是-underfitting-还是-overfitting？" class="headerlink" title="如何分辨现在是 underfitting 还是 overfitting？"></a>如何分辨现在是 underfitting 还是 overfitting？</h4><p>当你的 traning data 结果比较差的时候，是 underfitting</p><p>当你的 training data 结果比较好但是 testing data 结果很差的时候，大概是 overfitting</p><p><img src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210103160835816.png" alt="image-20210103160835816"></p><p>怎么做？</p><p>error from bias：重新设计 model、或者用一个更加复杂的 model，找更多 data 也没用</p><p>error from variance：</p><p><img src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210103161153542.png" alt="image-20210103161153542"></p><p>找更多 data、或者 generate 一些假 data 哈哈哈</p><p>或者 regularization：再加一些参数，比如曲线平滑度</p><p><img src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210103161601332.png" alt="image-20210103161601332"></p><p>但是这样子得到的数据可能会伤害你的 bias</p><blockquote><p>bias偏移量越大，模型越垃圾。而高阶model往往会造成其bias偏移量较小（参考高数泰勒展开）。从而导致高阶model（或者说是复杂model）的模型更贴合于数据的真实分布。但是当我们用新的测试集在高阶model上进行预测时，由于高阶model的形态过分贴合训练集数据且高阶model群较为繁杂，其在新的测试集数据上的拟合优度一定不会很好。</p></blockquote><h3 id="model-选择"><a href="#model-选择" class="headerlink" title="model 选择"></a>model 选择</h3><p>我们希望找一个 bias 和 variance 都比较小的 model</p><p>should not do：</p><p><img src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210103162039800.png" alt="image-20210103162039800"></p><p>你的 testing set 只是一个验证 training set 的 set，真实的 testing set 往往都是没有的</p><p>所以应该是这样做：用training data 选择 function，用 traning + validation 验证 model，这样才能真实反映 testing 的 bias（也就是不要提前考虑 testing data 的bias）</p><p><img src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210103162412021.png" alt="image-20210103162412021"></p><p>N 折交叉验证：</p><p><img src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210103162636812.png" alt="image-20210103162636812"></p><p>把 training data 分成 n 份，选一个作为 validation</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;机器学习&quot;&gt;&lt;a href=&quot;#机器学习&quot; class=&quot;headerlink&quot; title=&quot;机器学习&quot;&gt;&lt;/a&gt;机器学习&lt;/h1&gt;&lt;p&gt;机器学习就是让机器自动找函数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2021/01/03/ML%E5%AD%A6%E4%B9%</summary>
      
    
    
    
    
    <category term="机器学习" scheme="https://panlianghnu.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>简易区块链C语言实现</title>
    <link href="https://panlianghnu.github.io/2020/12/30/%E7%AE%80%E6%98%93%E5%8C%BA%E5%9D%97%E9%93%BEC%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/"/>
    <id>https://panlianghnu.github.io/2020/12/30/%E7%AE%80%E6%98%93%E5%8C%BA%E5%9D%97%E9%93%BEC%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-12-30T04:11:39.000Z</published>
    <updated>2021-03-14T14:59:39.787Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简易区块链C语言实现"><a href="#简易区块链C语言实现" class="headerlink" title="简易区块链C语言实现"></a>简易区块链C语言实现</h1><p>在CSDN的第四个任务：实现一个最简单的区块链，不带区块链网络、时间戳、merkle tree等</p><p>虽然说技术上难度不大，但是想要实现它，还真是一个不小的工程。。。</p><p>除了 SHA256 的计算部分，其余的代码都是自己实现的，写的不好还望见谅</p><h2 id="区块链数据结构："><a href="#区块链数据结构：" class="headerlink" title="区块链数据结构："></a>区块链数据结构：</h2><p><img src="/2020/12/30/%E7%AE%80%E6%98%93%E5%8C%BA%E5%9D%97%E9%93%BEC%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/image-20201229232408783.png" alt="image-20201229232408783"></p><p>如图所示，每个区块分为区块 head，和区块 body</p><p>区块头又分为 SHA_ALL、nonce、SHA_PREV、SHA_BLOCK</p><p>&gt;<br>&gt;</p><blockquote><p>SHA_BLOCK: 对区块的 body 部分进行一次 SHA256运算，保存在SHA_BLOCK</p><p>SHA_PREV: 保存上一个区块整体(head+body)的 SHA256 值</p><p>nonce: 随机数，意义仅仅只是让区块头（不包含SHA_ALL的部分）+区块体一起进行SHA256运算，使得最终的结果刚好出现 n 个前导0，n 可以设置，代表出块的难度，模拟POW共识算法（比特币采用POW），我看了比特币源码，比特币源码的 nonce 是采用的 long long ，那我这里采用 unsigned long，之前龙哥和我说256位的nonce，我跑了跑发现没有必要，nonce跑到10万就需要我电脑好几秒了。。。unsigned long（8字节） 最大值有<strong>18446744073709551615</strong>，根本跑不完好吗。。。</p><p>当然比特币的 nonce 虽然只有8字节，但这里并不是说比特币的区块取值每次只需要计算2^64种情况，比特币实际挖坑时，最终的哈希值前导 0 特别长，只遍历一次 nonce 是几乎不可能的情况，矿机需要不断地改变区块体里面的 coinbase 里的无意义的值，然后不断地去遍历 nonce ，才能试探出前导0多于 n 个的情况，这将耗费巨大的算力，也是比特币POW共识策略的体现</p><p>SHA_ALL: 存放在区块头的最上面，SHA_ALL 保存整个区块（不包含头最上面的这256比特）的SHA256计算结果，必须有 n 个前导0。它的意义在于，只要你修改了这个区块的任意部分，你就需要重新计算 HASH_BLOCK、重新计算 NONCE ，使得最终的 SHA_ALL 算出来要出现 n 个前导0，当 n 比较大，区块链比较长时，想要修改某区块并使整个区块链仍合法的工作量不可估量，这是区块链“不可篡改”的重要因素之一</p></blockquote><p>区块体就比较随意了，我这里只弄了一个字符串</p><p>这样就实现了一个最简单的区块链</p><p>具体代码实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> byte[<span class="number">104</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> sha_all[<span class="number">32</span>];       <span class="comment">// 256 bit sha_all</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> nonce;             <span class="comment">// 64 bit nonce</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> sha_prev[<span class="number">32</span>];      <span class="comment">// 256 bit sha_prev</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> sha_block[<span class="number">32</span>];     <span class="comment">// 256 bit sha_block</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125; block_chain_head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> body[<span class="number">1000</span>];</span><br><span class="line">&#125; block_chain_body;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    block_chain_head head;</span><br><span class="line">    block_chain_body body;</span><br><span class="line">&#125; block;</span><br></pre></td></tr></table></figure><p>这里补充一下C语言共用体的知识：</p><ul><li><p>我们知道结构体（Struct）是一种构造类型或复杂类型，它可以包含多个类型不同的成员。在C语言中，还有另外一种和结构体非常类似的语法，叫做<strong>共用体（Union）</strong>，它的定义格式为：</p><p>union 共用体名{<br>  成员列表<br>};</p><blockquote><p>共用体有时也被称为联合或者联合体，这也是 Union 这个单词的本意。</p></blockquote><p>结构体和共用体的区别在于：结构体的各个成员会占用不同的内存，互相之间没有影响；而共用体的所有成员占用同一段内存，修改一个成员会影响其余所有成员。</p><p>结构体占用的内存大于等于所有成员占用的内存的总和（成员之间可能会存在缝隙），共用体占用的内存等于最长的成员占用的内存。共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来成员的值覆盖掉。</p></li></ul><p>这里采用 Union + Struct 的数据结构，是为了录入数据+读取数据都比较方便直观。当我想要录入数据时，我只需要读字节流，将104个字节赋值给 byte 数组即可，当我想访问某些数据时，我又可以用结构体的方式直接访问成员变量，代码非常的简洁，可读性也高</p><p>题外话：</p><p>之前想着是用哈希值命名文件，区块头可以少一个 sha 字段，看起来好像没啥问题，但是实际实现的时候，用哈希值来命名区块，有一个很严重的 bug</p><p>我们使用最终的哈希值有n个前导0，这样来控制难度，文件名是一个字符串，0在字符串里表现为字符 ‘\0’ ，而这个字符被视为默认的字符串终止符，这个字符串你赋值给 const char* tmp，编译器会发现第一个字符就是字符串终止符，故而会把 tmp 这个字符串常量视为 “” 这样的空字符串保存在常量池，故而不能直接用这个哈希值来作为区块文件的文件名</p><p>同样的，但凡这个哈希值里面有 ‘\0’ ，我们都不能将它作为文件名，所以文件名我不采用哈希值，哈希值还是选择保存在区块头中</p><h2 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h2><p>一个简易的区块链，必须有下面几个功能：</p><ul><li>生成创世纪块</li><li>读取文件夹下的所有区块</li><li>查找创世纪块</li><li>查找区块链的最后一个区块</li><li>在区块链的尾部追加区块</li><li>对区块的SHA计算</li></ul><p>求SHA256:</p><p>我使用了别人实现的SHA256算法，参考：<a href="https://github.com/panlianghnu/Blockchain-programming-exercises/tree/master/1.Blockchain%20basic%20exercises/2.Cryptography%20and%20security%20technology/SHA256/C%20Code">SHA256-C语言实现</a></p><p>这个程序有一个bug，当我将区块头和尾合并，一起作为字节数组传入时，有时候求出来的SHA256值正常，有时候值是错误的，我检查好久发现他在加密实现的过程中对传入的比特数组做了 strlen() 运算。。。这直接导致了如果传入的数据有 unsigned char 0，将被识别为字符串终结符，strlen() 函数遇到tmp直接终止计算，导致传入的字符串长度识别不正常，故而时好时坏（特别是创世纪块中有大量的 unsigned char 0，一直算出错误的SHA，还难以发现），我手动算字符串长度并作为参数传入计算，算是修了这个bug</p><h4 id="生成创世纪块："><a href="#生成创世纪块：" class="headerlink" title="生成创世纪块："></a>生成创世纪块：</h4><p>先贴代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;    <span class="comment">// 创建创世纪块</span></span><br><span class="line">    block_chain_head* genesis = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(block_chain_head));</span><br><span class="line">    block_chain_body genesis_body;</span><br><span class="line">    <span class="built_in">strcpy</span>(genesis_body.body,<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(genesis-&gt;byte,<span class="number">0</span>,<span class="keyword">sizeof</span>(block_chain_head));    <span class="comment">// 先将区块字节头全部初始化为0</span></span><br><span class="line">    sha256_main(genesis_body.body,<span class="keyword">sizeof</span>(genesis_body.body),genesis-&gt;sha_block);   <span class="comment">// 哈希body</span></span><br><span class="line">    <span class="comment">// 随机 nonce ，对(块头+块体)再次哈希</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;开始随机nonce\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (genesis-&gt;nonce &lt; <span class="number">0xffffffffffffffff</span>) &#123;</span><br><span class="line">        <span class="comment">// 把块头块体 读入一个 BYTE 数组</span></span><br><span class="line">        BYTE text[<span class="number">10200</span>];</span><br><span class="line">        read_head_body(text,genesis,genesis_body);</span><br><span class="line">        BYTE buf[SHA256_BLOCK_SIZE];</span><br><span class="line">        <span class="keyword">size_t</span> size_of_text = <span class="keyword">sizeof</span>(block_chain_head)<span class="number">-32</span> + <span class="built_in">strlen</span>(genesis_body.body);</span><br><span class="line">        sha256_main(text,size_of_text,buf);    <span class="comment">// 计算 sha256   有bug??? (已解决)</span></span><br><span class="line">        <span class="comment">// 当text 含有 &#x27;\0&#x27; 时，出现bug</span></span><br><span class="line">        <span class="comment">// 所以添加变量 size_of_text (注意要减去32 sha_all)</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;当前nonce为: %lu     &quot;</span>,genesis-&gt;nonce);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;前8bit为:%02x\n&quot;</span>,buf[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span> (check_sha(buf)) &#123;   <span class="comment">// 检查是否为前导0</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;创世纪块nonce为: %lu\n&quot;</span>,genesis-&gt;nonce);</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span>* filename = <span class="string">&quot;Genesis.block&quot;</span>;</span><br><span class="line">            FILE *fp = fopen(filename,<span class="string">&quot;w&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line">            <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;SHA256_BLOCK_SIZE;i++) &#123;</span><br><span class="line">                genesis-&gt;sha_all[i] = buf[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="keyword">sizeof</span>(block_chain_head);i++) &#123;   <span class="comment">// 写入区块头</span></span><br><span class="line">                <span class="built_in">fprintf</span>(fp,<span class="string">&quot;%c&quot;</span>,genesis-&gt;byte[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(genesis_body.body);i++) &#123;  <span class="comment">// 写入区块体</span></span><br><span class="line">                <span class="built_in">fprintf</span>(fp,<span class="string">&quot;%c&quot;</span>,genesis_body.body[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        genesis-&gt;nonce++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就体现出联合体的优点了，直接可以通过 memset 对整个头初始化，却不影响我访问对应的结构题属性，计算 SHA256 时，我引用了别人的函数，sha256_main()，将对应的属性保存（创世纪块sha_prev = 0)，不断的计算nonce，由于采用了 unsigned long ，遍历只需要递增即可，注意每次递增 nonce，重新计算 SHA 的时候，一定要注意是从区块头的第32个字节开始往下读，一直把区块体的内容也读完，读出来的所有字节放入一个 BYTE text[SHA256_BLOCK_SIZE] 数组里，一起去求 SHA256，这样算出来的 SHA_ALL才是正确的，我这边难度设置的是前 16个 bit 为0，平均大概10秒能出一个块吧</p><h4 id="验证-genesis-文件："><a href="#验证-genesis-文件：" class="headerlink" title="验证 genesis 文件："></a>验证 genesis 文件：</h4><p>使用 Mac 的二进制编辑器Hex Fiend打开查看：</p><p><img src="/2020/12/30/%E7%AE%80%E6%98%93%E5%8C%BA%E5%9D%97%E9%93%BEC%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/image-20201229173435239.png" alt="image-20201229173435239"></p><p>可以看到，前32字节的 sha_all ，是一串乱码，是我们使用SHA256生成的整个文件的256bit 哈希值</p><p>接下来8个字节：</p><p><img src="/2020/12/30/%E7%AE%80%E6%98%93%E5%8C%BA%E5%9D%97%E9%93%BEC%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/image-20201229173836110.png" alt="image-20201229173836110"></p><p>再接下来32字节的 sha_prev 全为0，这是我们初始化生成的0，创世纪块没有前一个块嘛</p><p>再接下来32字节是 sha_block ，这是区块体的哈希值，可以看到也是一串乱码</p><p><img src="/2020/12/30/%E7%AE%80%E6%98%93%E5%8C%BA%E5%9D%97%E9%93%BEC%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/image-20201229174021198.png" alt="image-20201229174021198"></p><p>最后的部分就是区块 body 的内容了，创世纪块的body 内容我写的很简单，就是hello world，可以看到在右边已经把它解析出来了</p><h4 id="读取文件夹下的所有区块："><a href="#读取文件夹下的所有区块：" class="headerlink" title="读取文件夹下的所有区块："></a>读取文件夹下的所有区块：</h4><p>C语言标准库没有提供读取文件夹的函数，官方文档也没找到。。。</p><p><img src="/2020/12/30/%E7%AE%80%E6%98%93%E5%8C%BA%E5%9D%97%E9%93%BEC%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/image-20201230113237235.png" alt="image-20201230113237235"></p><p>我引用了 “dirent.h” 库来读文件夹，调用 readdir(dir) 和 entry-&gt;d_name 来匹配文件名</p><p>参考<a href="https://blog.csdn.net/wangqingchuan92/article/details/80109793">C语言读取文件夹</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read_dir_block</span><span class="params">(block block_list[],<span class="keyword">const</span> <span class="keyword">char</span>* filePath)</span></span>&#123; <span class="comment">// 读文件夹所有块文件</span></span><br><span class="line">    DIR *dir = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">entry</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((dir = opendir(filePath)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open dir failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((entry = readdir(dir))!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span>* filename = entry-&gt;d_name;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strstr</span>(filename,<span class="string">&quot;.block&quot;</span>)) &#123;      <span class="comment">// 匹配区块文件(以.block结尾)</span></span><br><span class="line">            read_block(&amp;block_list[num],filename);</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    closedir(dir);</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 string.h 库函数 strstr() 子串查找，匹配文件名包含 .block 的文件，调用 read_block() 去读取文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_block</span><span class="params">(block *blockitem,<span class="keyword">const</span> <span class="keyword">char</span>* filename)</span></span>&#123;   <span class="comment">// 读一个块</span></span><br><span class="line">    FILE *fp = fopen(filename,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!fp) &#123;</span><br><span class="line">        perror(<span class="string">&quot;File opening failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> c,i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((c = fgetc(fp)) != EOF) &#123; <span class="comment">// standard C I/O file reading loop</span></span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="keyword">sizeof</span>(block_chain_head)) &#123;</span><br><span class="line">            blockitem-&gt;head.byte[i] = c;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            blockitem-&gt;body.body[i-<span class="keyword">sizeof</span>(block_chain_head)] = c;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历每个字符，这里又体现出联合体的优势了，直接载入文件的字符流，读 sizeof(block_chain_head) 个字符即可录入头部数据，文件剩余字符全部录入 body 即可</p><p>如此便可读取目录下的所有区块文件，放入 block_list 中</p><h4 id="查找创世纪块："><a href="#查找创世纪块：" class="headerlink" title="查找创世纪块："></a>查找创世纪块：</h4><p>实现了读取目录下的所有区块之后，查找创世纪块变得尤其简单，只需要遍历所有的区块，找到某个 SHA_PREV 为全0的区块，即是创世纪块</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">block <span class="title">find_first_block</span><span class="params">()</span></span>&#123;</span><br><span class="line">    block block_list[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *filePath = <span class="string">&quot;.&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> size = read_dir_block(block_list,filePath);   <span class="comment">// 一共 size 个区块</span></span><br><span class="line">    block tmp;</span><br><span class="line">    <span class="built_in">memset</span>(tmp.head.byte, <span class="number">0</span>, <span class="keyword">sizeof</span>(block_chain_head));</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;no block file\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    BYTE hash[SHA256_BLOCK_SIZE] = &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;size;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> cmp = <span class="built_in">memcmp</span>(hash,block_list[i].head.sha_prev,SHA256_BLOCK_SIZE);</span><br><span class="line">        <span class="keyword">if</span>(cmp == <span class="number">0</span>)&#123;   <span class="comment">// equal， this is the first block</span></span><br><span class="line">            <span class="keyword">return</span> block_list[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我使用memcmp() 函数来比较 SHA_PREV 是否为全0，这是 memcmp 的官方文档：</p><p><img src="/2020/12/30/%E7%AE%80%E6%98%93%E5%8C%BA%E5%9D%97%E9%93%BEC%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/image-20201230114505328.png" alt="image-20201230114505328"></p><p>可以看到，memcmp将二者解释为无符号字符数组，一个个比较，全部相等会返回0，特别方便</p><p>所以在这里我直接定义一个32字节全0的字符数组，然后调用 memcmp 比较即可</p><h4 id="查找最后一个区块："><a href="#查找最后一个区块：" class="headerlink" title="查找最后一个区块："></a>查找最后一个区块：</h4><p>这个算是特别常用的一个功能了</p><p>在查找文件夹下所有区块和查找创世纪块的基础之上，我们就可以去做区块的拓扑排序了</p><p>查找最后一个区块也就变成了求区块的拓扑排序，返回拓扑排序的最后一个区块即可</p><p>求拓扑序列的代码很简单我就不展示了，基本上就是一个二重循环，匹配第 j 个区块的 SHA_PREV 和当前区块的 SHA_ALL ，然后在尾部添加即可</p><h4 id="尾部添加区块："><a href="#尾部添加区块：" class="headerlink" title="尾部添加区块："></a>尾部添加区块：</h4><p>有了查找最后一个区块，尾部添加区块也就特别简单了</p><p>只需要找到最后一个区块的 SHA_ALL ，新开一个区块，写入 SHA_PREV ，然后就和之前的生成创世纪块类似了，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">new_block</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* block_name ,<span class="keyword">char</span>* content)</span></span>&#123; <span class="comment">// 和 init 类似，在末尾添加</span></span><br><span class="line">    block last_block = find_last_block();</span><br><span class="line">    </span><br><span class="line">    block_chain_head* genesis = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(block_chain_head));</span><br><span class="line">    block_chain_body genesis_body;</span><br><span class="line">    <span class="built_in">strcpy</span>(genesis_body.body,content);</span><br><span class="line">    <span class="built_in">memset</span>(genesis-&gt;byte,<span class="number">0</span>,<span class="keyword">sizeof</span>(block_chain_head));    <span class="comment">// 先将区块头全部初始化为0</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;SHA256_BLOCK_SIZE;i++) &#123;</span><br><span class="line">        genesis-&gt;sha_prev[i] = last_block.head.sha_all[i];  <span class="comment">// 写入 sha_prev</span></span><br><span class="line">    &#125;</span><br><span class="line">    sha256_main(genesis_body.body,<span class="keyword">sizeof</span>(genesis_body.body),genesis-&gt;sha_block); <span class="comment">// sha_block</span></span><br><span class="line">    <span class="comment">// 随机 nonce ，对(块头+块体)再次哈希</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;开始随机nonce\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (genesis-&gt;nonce &lt; <span class="number">0xffffffffffffffff</span>) &#123;</span><br><span class="line">        <span class="comment">// 把块头块体 读入一个 BYTE 数组</span></span><br><span class="line">        BYTE text[<span class="number">10200</span>];</span><br><span class="line">        read_head_body(text,genesis,genesis_body);</span><br><span class="line">        BYTE buf[SHA256_BLOCK_SIZE];</span><br><span class="line">        <span class="keyword">size_t</span> size_of_text = <span class="keyword">sizeof</span>(block_chain_head)<span class="number">-32</span> + <span class="built_in">strlen</span>(genesis_body.body);</span><br><span class="line">        sha256_main(text,size_of_text,buf);    <span class="comment">// 计算 sha256   有bug??? (已解决)</span></span><br><span class="line">        <span class="comment">// 当text 含有 &#x27;\0&#x27; 时，出现bug</span></span><br><span class="line">        <span class="comment">// 所以添加变量 size_of_text (注意要减去32 sha_all)</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;当前nonce为: %lu     &quot;</span>,genesis-&gt;nonce);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;前8bit为:%02x\n&quot;</span>,buf[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span> (check_sha(buf)) &#123;   <span class="comment">// 检查是否为前导0</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;新区块nonce为: %lu\n&quot;</span>,genesis-&gt;nonce);</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span>* filename = <span class="built_in">strcat</span>(block_name, <span class="string">&quot;.block&quot;</span>);</span><br><span class="line">            FILE *fp = fopen(filename,<span class="string">&quot;w&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;SHA256_BLOCK_SIZE;i++) &#123;</span><br><span class="line">                genesis-&gt;sha_all[i] = buf[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="keyword">sizeof</span>(block_chain_head);i++) &#123;   <span class="comment">// 写入区块头</span></span><br><span class="line">                <span class="built_in">fprintf</span>(fp,<span class="string">&quot;%c&quot;</span>,genesis-&gt;byte[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(genesis_body.body);i++) &#123;  <span class="comment">// 写入区块体</span></span><br><span class="line">                <span class="built_in">fprintf</span>(fp,<span class="string">&quot;%c&quot;</span>,genesis_body.body[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        genesis-&gt;nonce++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>不要在意为什么新区块也叫 genesis 我懒得改了</del></p><p>除了区块的 filename 、SHA_PREV 、body 不一样，其他的操作完全和创世纪块一样</p><p>写新区块时，我需要给新区块后缀命名为 .block </p><p>c语言不能直接使用 + 运算符对字符串进行拼接，故使用strcat，跑到一半又报错了。。原因是strcat直接在字符数组尾部添加字符，晕，数组越界了。</p><p><img src="/2020/12/30/%E7%AE%80%E6%98%93%E5%8C%BA%E5%9D%97%E9%93%BEC%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/image-20201229223124304.png" alt="image-20201229223124304"></p><p>不得不再次感叹C语言的字符串处理真是太不方便了</p><p><img src="/2020/12/30/%E7%AE%80%E6%98%93%E5%8C%BA%E5%9D%97%E9%93%BEC%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/image-20201229224105511.png" alt="image-20201229224105511"></p><p>可以看到 block_one 的 sha_prev 的部分，变成了 genesis 的前32字节，也就是哈希值指向 genesis </p><p>新区块的产生基本和创世纪块一样，只是调用一下 find_last_block ，找到 sha_prev 的值即可，然后自行输入 block_name 和 block_body</p><p>再看 block_two 和 block_one</p><p><img src="/2020/12/30/%E7%AE%80%E6%98%93%E5%8C%BA%E5%9D%97%E9%93%BEC%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/image-20201229224428292.png" alt="image-20201229224428292"></p><p>相应的 sha_prev、  sha_all 字段都是一一对应起来的</p><p><img src="/2020/12/30/%E7%AE%80%E6%98%93%E5%8C%BA%E5%9D%97%E9%93%BEC%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/image-20201229224529388.png" alt="image-20201229224529388"></p><p>解析出来的 body 也是正常的</p><p>尾部新增区块完成！</p><h4 id="检验区块链合法"><a href="#检验区块链合法" class="headerlink" title="检验区块链合法"></a>检验区块链合法</h4><p>在 find_last_block() 函数的实现中，topo 序列只要能构造出来，说明sha_prev 和 sha_all 能够一一对上，该区块链是合法的，所以实现也和 find_last_block 基本一样。如果创世纪块找不到，则区块链不合法，从创世纪块后找 n个区块（n为区块总数目-1），一旦找不到区块的 sha_prev 指向当前 sha_all，则区块链不合法，具体实现在 check_block_chain() 函数里，得到拓扑序列之后，遍历这个序列，计算各个区块的 SHA_，任意区块的 SHA 计算错误则该区块链不合法</p><h4 id="建立区块链索引"><a href="#建立区块链索引" class="headerlink" title="建立区块链索引"></a>建立区块链索引</h4><p>find_last_block() 和 check_block_chain() 函数里都做过拓扑排序的操作，参考上面的函数即可</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>感谢能看到最后的小伙伴！代码我开源到 GitHub 了</p><p><a href="https://github.com/panlianghnu/block_chain">https://github.com/panlianghnu/block_chain</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简易区块链C语言实现&quot;&gt;&lt;a href=&quot;#简易区块链C语言实现&quot; class=&quot;headerlink&quot; title=&quot;简易区块链C语言实现&quot;&gt;&lt;/a&gt;简易区块链C语言实现&lt;/h1&gt;&lt;p&gt;在CSDN的第四个任务：实现一个最简单的区块链，不带区块链网络、时间戳、me</summary>
      
    
    
    
    
    <category term="c语言" scheme="https://panlianghnu.github.io/tags/c%E8%AF%AD%E8%A8%80/"/>
    
    <category term="区块链" scheme="https://panlianghnu.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>JS 单线程</title>
    <link href="https://panlianghnu.github.io/2020/12/22/JS-%E5%8D%95%E7%BA%BF%E7%A8%8B/"/>
    <id>https://panlianghnu.github.io/2020/12/22/JS-%E5%8D%95%E7%BA%BF%E7%A8%8B/</id>
    <published>2020-12-22T12:44:08.000Z</published>
    <updated>2021-03-14T14:59:30.211Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS-单线程"><a href="#JS-单线程" class="headerlink" title="JS 单线程"></a>JS 单线程</h1><p>JS执行是单线程</p><blockquote><p>单线程是指Js引擎执行Js时只分了一个线程给他执行，也就是执行js时是单线程的。</p></blockquote><p>那么问题来了，什么是线程？进程又是什么？</p><p>在分析浏览器的渲染过程之前，我们先了解一下什么是进程和线程：</p><p>（1）什么是进程？</p><p>进程是CPU进行资源分配的基本单位</p><p>（2）什么是线程？</p><p>线程是CPU调度的最小单位，是建立在进程的基础上运行的单位，共享进程的内存空间。</p><p>多进程<br>1、浏览器是多进程</p><p>2、不同类型的标签页都会开启一个新的进程</p><p>3、相同类型的标签页是会合并到一个进程</p><p>1、浏览器进程</p><p>（1）负责管理各个标签页的创建和销毁</p><p>（2）负责浏览器的页面显示和功能（前进，后退，收藏等）</p><p>（3）负责资源的管理与下载</p><p>2、第三方插件进程</p><p>（1）负责每个第三方插件的使用，每个第三方插件使用时候都会创建一个对应的进程</p><p>3、GPU进程</p><p>（1）负责3D绘制和硬件加速</p><p>4、浏览器渲染进程（咱们这回主要分析的）</p><p>1、浏览器内核，主要负责HTML，CSS，JS等文件的解析和执行</p><p>什么是浏览器内核？</p><p>浏览器内核就是浏览器渲染进程，从接收下载文件后再到呈现整个页面的过程，由浏览器渲染进程负责，主要流程如下：</p><p>1、解析HTML文件和CSS文件，加载图片等资源文件，渲染成用户看到的页面<br>2、执行解析js文件脚本代码</p><p>这里主要讲浏览器页面渲染过程，在该过程中浏览器渲染进程会开启多个线程协作完成，主要的线程以及作用如下：</p><p>1、GUI渲染线程<br>2、JS引擎线程<br>3、事件触发线程<br>4、定时器出发线程<br>5、异步HTTP请求线程</p><h2 id="JS引擎"><a href="#JS引擎" class="headerlink" title="JS引擎"></a>JS引擎</h2><p>1、JS内核，也称JS引擎（例如V8引擎），负责处理执行javascript脚本程序，<br>2、由于js是单线程（一个Tab页内中无论什么时候都只有一个JS线程在运行JS程序），依靠任务队列来进行js代码的执行，所以js引擎会一直等待着任务队列中任务的到来，然后加以处理。</p><blockquote><p>注意，JavaScript 只在一个线程上运行，不代表 JavaScript 引擎只有一个线程。事实上，JavaScript 引擎有多个线程，单个脚本只能在一个线程上运行（称为主线程），其他线程都是在后台配合</p></blockquote><p>为了利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作 DOM。所以，这个新标准并没有改变 JavaScript 单线程的本质。</p><h2 id="V8引擎的内部结构"><a href="#V8引擎的内部结构" class="headerlink" title="V8引擎的内部结构"></a>V8引擎的内部结构</h2><p>1、V8是一个非常复杂的项目，使用cloc统计可知，它竟然有超过100万行C++代码。<br>2、V8由许多子模块构成，其中这4个模块是最重要的：</p><ol><li>Parser：负责将JavaScript源码转换为Abstract Syntax Tree (AST)</li><li>Ignition：interpreter，即解释器，负责将AST转换为Bytecode，解释执行Bytecode；同时收集3. TurboFan优化编译所需的信息，比如函数参数的类型；</li><li>TurboFan：compiler，即编译器，利用Ignitio所收集的类型信息，将Bytecode转换为优化的汇编代码；</li><li>Orinoco：garbage collector，垃圾回收模块，负责将程序不再需要的内存空间回收；</li></ol><blockquote><p>再次强调：单线程是指Js引擎执行Js时只分了一个线程给他执行，也就是执行js时是单线程的。</p></blockquote><p><strong>既然JS是单线程的，那怎么实现异步的呢？</strong></p><p>单线程意味着什么：JavaScript 同时只能执行一个任务，其他任务都必须在后面排队等待。也就是说代码只能同步执行，必须执行上一行才能执行下一行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure><p>然而并不是，还有异步！！！</p><p>程序里面所有的任务，可以分成两类：同步任务（synchronous）和异步任务（asynchronous）。</p><p>同步任务是那些没有被引擎挂起、在主线程上排队执行的任务。只有前一个任务执行完毕，才能执行后一个任务。</p><p>异步任务是那些被引擎放在一边，不进入主线程、而进入任务队列的任务。只有引擎认为某个异步任务可以执行了（比如 Ajax 操作从服务器得到了结果），该任务（采用回调函数的形式）才会进入主线程执行。排在异步任务后面的代码，不用等待异步任务结束会马上运行，也就是说，异步任务不具有“堵塞”效应。</p><p>举例来说，Ajax 操作可以当作同步任务处理，也可以当作异步任务处理，由开发者决定。如果是同步任务，主线程就等着 Ajax 操作返回结果，再往下执行；如果是异步任务，主线程在发出 Ajax 请求以后，就直接往下执行，等到 Ajax 操作有了结果，主线程再执行对应的回调函数。</p><h2 id="任务队列和事件循环-（实现异步）"><a href="#任务队列和事件循环-（实现异步）" class="headerlink" title="任务队列和事件循环 （实现异步）"></a>任务队列和事件循环 （实现异步）</h2><p>JavaScript 运行时，除了一个正在运行的主线程，引擎还提供一个任务队列（task queue），里面是各种需要当前程序处理的异步任务。（实际上，根据异步任务的类型，存在多个任务队列。为了方便理解，这里假设只存在一个队列。）</p><p>首先，主线程会去执行所有的同步任务。等到同步任务全部执行完，就会去看任务队列里面的异步任务。如果满足条件，那么异步任务就重新进入主线程开始执行，这时它就变成同步任务了。等到执行完，下一个异步任务再进入主线程开始执行。一旦任务队列清空，程序就结束执行。</p><p>异步任务的写法通常是回调函数。一旦异步任务重新进入主线程，就会执行对应的回调函数。如果一个异步任务没有回调函数，就不会进入任务队列，也就是说，不会重新进入主线程，因为没有用回调函数指定下一步的操作。</p><p>JavaScript 引擎怎么知道异步任务有没有结果，能不能进入主线程呢？答案就是引擎在不停地检查，一遍又一遍，只要同步任务执行完了，引擎就会去检查那些挂起来的异步任务，是不是可以进入主线程了。这种循环检查的机制，就叫做事件循环（Event Loop）。维基百科的定义是：“事件循环是一个程序结构，用于等待和发送消息和事件（a programming construct that waits for and dispatches events or messages in a program）”。</p><p>代码是如何执行的？</p><p>宏任务(macro-task)、微任务(micro-task)</p><p>除了广义的同步任务和异步任务，JavaScript 单线程中的任务可以细分为宏任务和微任务。</p><p>macro-task包括：script(整体代码), setTimeout, setInterval, setImmediate, I/O, UI rendering。<br>micro-task包括：process.nextTick, Promises, Object.observe, MutationObserver。</p><p>有了宏任务和微任务的概念后，那 JS 的执行顺序是怎样的？是宏任务先还是微任务先？</p><p>第一次事件循环中，JavaScript 引擎会把整个 script 代码当成一个宏任务执行，执行完成之后，再检测本次循环中是否寻在微任务，存在的话就依次从微任务的任务队列中读取执行完所有的微任务，再读取宏任务的任务队列中的任务执行，再执行所有的微任务，如此循环。JS 的执行顺序就是每次事件循环中的宏任务-微任务。</p><p>页面刷新率？</p><p>每次微任务执行之后宏任务执行之前如果有UI操作页面会重新渲染，一般页面刷新率60HZ/秒，一帧是16.6毫秒，所以可以理解为事件循环每次轮询的时间大概是16.6毫秒</p><p>每一帧浏览器需要做什么？</p><p>我们所看到的网页，都是浏览器一帧一帧绘制出来的，通常认为FPS为60的时候是比较流畅的，而FPS为个位数的时候就属于用户可以感知到的卡顿了，那么在一帧里面浏览器都要做哪些事情呢</p><h2 id="渲染帧的流程"><a href="#渲染帧的流程" class="headerlink" title="渲染帧的流程"></a>渲染帧的流程</h2><p>渲染帧是指浏览器一次完整绘制过程，帧之间的时间间隔是 DOM 视图更新的最小间隔。 由于主流的屏幕刷新率都在 60Hz，那么渲染一帧的时间就必须控制在 16ms 才能保证不掉帧。 也就是说每一次渲染都要在 16ms 内页面才够流畅不会有卡顿感。 这段时间内浏览器需要完成如下事情：</p><ul><li>脚本执行（JavaScript）：脚本造成了需要重绘的改动，比如增删 DOM、请求动画等</li><li>样式计算（CSS Object Model）：级联地生成每个节点的生效样式。</li><li>布局（Layout）：计算布局，执行渲染算法</li><li>重绘（Paint）：各层分别进行绘制（比如 3D 动画）</li><li>合成（Composite）：合成各层的渲染结果</li></ul><p>最初 Webkit 使用定时器进行渲染间隔控制， 2014 年时开始 <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=337617">使用显示器的 vsync 信号控制渲染</a>（其实直接控制的是合成这一步）。 这意味着 16ms 内多次 commit 的 DOM 改动会合并为一次渲染。</p><h2 id="耗时-JS-会造成丢帧"><a href="#耗时-JS-会造成丢帧" class="headerlink" title="耗时 JS 会造成丢帧"></a>耗时 JS 会造成丢帧</h2><p>JavaScript 在并发编程上一个重要特点是“Run To Completion”。在事件循环的一次 Tick 中， 如果要执行的逻辑太多会一直阻塞下一个 Tick，所有异步过程都会被阻塞。 一个流畅的页面中，JavaScript 引擎中的执行队列可能是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">执行 JS -&gt; 空闲 -&gt; 绘制（16ms）-&gt; 执行 JS -&gt; 空闲 -&gt; 绘制（32ms）-&gt; ...</span><br></pre></td></tr></table></figure><p>如果在某个时刻有太多 JavaScript 要执行，就会丢掉一次帧的绘制：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">执行很多 JS...（20ms）-&gt; 空闲 -&gt; 绘制（32ms）-&gt; ...</span><br></pre></td></tr></table></figure><p>例如下面的脚本在保持 JavaScript 忙的状态（持续 5s）下每隔 1s 新增一行 DOM 内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;message&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var then &#x3D; Date.now()</span><br><span class="line">var i &#x3D; 0</span><br><span class="line">var el &#x3D; document.getElementById(&#39;message&#39;)</span><br><span class="line">while (true) &#123;</span><br><span class="line">  var now &#x3D; Date.now()</span><br><span class="line">  if (now - then &gt; 1000) &#123;</span><br><span class="line">    if (i++ &gt;&#x3D; 5) &#123;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">    el.innerText +&#x3D; &#39;hello!\n&#39;</span><br><span class="line">    console.log(i)</span><br><span class="line">    then &#x3D; now</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>可以观察到虽然每秒都会写一次 DOM，但在 5s 结束后才会全部渲染出来，明显耗时脚本阻塞了渲染。</p><p><img src="/2020/12/22/JS-%E5%8D%95%E7%BA%BF%E7%A8%8B/js-block-render.gif" alt="js block render"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JS-单线程&quot;&gt;&lt;a href=&quot;#JS-单线程&quot; class=&quot;headerlink&quot; title=&quot;JS 单线程&quot;&gt;&lt;/a&gt;JS 单线程&lt;/h1&gt;&lt;p&gt;JS执行是单线程&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;单线程是指Js引擎执行Js时只分了一个线程给他执行</summary>
      
    
    
    
    
    <category term="nodejs" scheme="https://panlianghnu.github.io/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>python 文字版RPG小游戏</title>
    <link href="https://panlianghnu.github.io/2020/12/17/python-%E6%96%87%E5%AD%97%E7%89%88RPG%E5%B0%8F%E6%B8%B8%E6%88%8F/"/>
    <id>https://panlianghnu.github.io/2020/12/17/python-%E6%96%87%E5%AD%97%E7%89%88RPG%E5%B0%8F%E6%B8%B8%E6%88%8F/</id>
    <published>2020-12-17T07:44:24.000Z</published>
    <updated>2021-03-14T15:00:24.037Z</updated>
    
    <content type="html"><![CDATA[<p>之前龙哥给我们布置了两个任务</p><p><a href="https://panlianghnu.github.io/2020/12/14/Coder-语言快速上手/">语言快速上手-学习任务</a> </p><p>这是第一个</p><p><img src="/2020/12/17/python-%E6%96%87%E5%AD%97%E7%89%88RPG%E5%B0%8F%E6%B8%B8%E6%88%8F/image-20201217155246062.png" alt="image-20201217155246062"></p><p>基本就是实现一个文字版本的RPG小游戏，刚好我今天在bilibili看到一个互动视频觉得很有意思，就想着把这个视频用文字的形式复现出来</p><p>视频链接：<a href="https://www.bilibili.com/video/BV1pZ4y1W7LK?from=search&amp;seid=15774110568370964830">【互动视频】卢本伟越狱记</a></p><p>这种互动视频有很多选项，每个选项都会影响之后的剧情，所以我使用一个栈来保存之前的选择，也方便每次互动时，玩家选错选项来有机会反悔回到上一步</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line">stack = []</span><br><span class="line">stack.append(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">len</span>(stack)&gt;<span class="number">0</span>:</span><br><span class="line">    case = stack[-<span class="number">1</span>]   <span class="comment">#  读最后一个case</span></span><br><span class="line">    <span class="keyword">if</span> case == <span class="number">0</span>:      <span class="comment">#  case0:等待开始游戏</span></span><br><span class="line">        print(<span class="string">&#x27;卢本伟越狱记&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;卢本伟开挂被抓了，你能帮助卢本伟成功越狱吗？（你需要扮演卢本伟完成越狱）&#x27;</span>)</span><br><span class="line">        start = <span class="built_in">input</span>(<span class="string">&quot;输入&#x27;start&#x27;开始游戏，输入其他结束\n&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> start != <span class="string">&#x27;start&#x27;</span>:</span><br><span class="line">            print(<span class="string">&quot;你输入了：&quot;</span>,start,<span class="string">&quot; 游戏结束...&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>: <span class="comment"># 游戏开始</span></span><br><span class="line">            stack.append(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> case == <span class="number">1</span>:      <span class="comment">#  case1:开始游戏</span></span><br><span class="line">        print(<span class="string">&quot;卢本伟被关在牢房，这时来了俩警察&quot;</span>)</span><br><span class="line">        print(<span class="string">&#x27;警察1:“you are free guy now...骗你的哈哈哈”&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;警察1:“你有个朋友给你寄了一个包裹，但是你不要想着轻举妄动，我们已经检查过里面了，是吧？”&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;警察2:“（心虚）是啊是啊，我当然检查过了，这是我的工作嘛”&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;两个警察把包裹留下就走了&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;卢本伟打开了包裹，发现一个生日蛋糕，生日蛋糕里面居然藏了东西，你会选择？&#x27;</span>)</span><br><span class="line">        tmp = <span class="built_in">input</span>(<span class="string">&#x27;A.锉刀 B.钻机 C.返回上一步 其他.结束游戏\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> tmp == <span class="string">&quot;A&quot;</span> :</span><br><span class="line">            stack.append(<span class="number">2</span>)   <span class="comment">#  case2: 选择锉刀</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> tmp == <span class="string">&quot;B&quot;</span> :</span><br><span class="line">            stack.append(<span class="number">3</span>)   <span class="comment">#  case3: 选择钻机</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> tmp == <span class="string">&quot;C&quot;</span> :</span><br><span class="line">            <span class="keyword">del</span> stack[-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span> : <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> case == <span class="number">2</span>:       <span class="comment"># case2：选择锉刀</span></span><br><span class="line">        print(<span class="string">&#x27;你选择了锉刀，卢本伟切割了监狱门，并打倒了守卫，这时有人追了过来&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;卢本伟灵机一动，躲进了一个小房间，但是这不是长久之计，必须找到方法越狱&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;卢本伟发现房间里有：A.手雷   B.椅子&#x27;</span>)</span><br><span class="line">        tmp = <span class="built_in">input</span>(<span class="string">&#x27;聪明的你会选择：A.手雷  B.椅子 C.返回上一步 其他.结束游戏\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> tmp == <span class="string">&quot;A&quot;</span> :</span><br><span class="line">            stack.append(<span class="number">4</span>)  <span class="comment"># case4: 选择手雷</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> tmp == <span class="string">&quot;B&quot;</span> :</span><br><span class="line">            stack.append(<span class="number">5</span>)  <span class="comment"># case5: 选择椅子</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> tmp == <span class="string">&quot;C&quot;</span> :</span><br><span class="line">            <span class="keyword">del</span> stack[-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span> : <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> case == <span class="number">4</span>:       <span class="comment"># case4: 选择手雷</span></span><br><span class="line">        print(<span class="string">&#x27;情急之下，卢本伟拿起了地上的手雷，准备和追来的警察拼死一搏&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;两个警察追过俩把门堵上，卢本伟失手把自己炸死了&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;game over&#x27;</span>)</span><br><span class="line">        tmp = <span class="built_in">input</span>(<span class="string">&#x27;输入A重开游戏，输入B返回上一步，输入其他结束游戏\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> tmp == <span class="string">&quot;A&quot;</span>:</span><br><span class="line">            stack = []</span><br><span class="line">            stack.append(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> tmp == <span class="string">&quot;B&quot;</span>:</span><br><span class="line">            <span class="keyword">del</span> stack[-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span> : <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> case == <span class="number">5</span>:       <span class="comment"># case5: 选择椅子</span></span><br><span class="line">        print(<span class="string">&#x27;聪明的卢本伟发现通过椅子可以钻进天花板的通风管道&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;这个时候问题来了，通风管道只能向左或向右&#x27;</span>)</span><br><span class="line">        tmp = <span class="built_in">input</span>(<span class="string">&#x27;你会选择？ A.向右 B.向左 C.返回上一步 其他.结束游戏\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> tmp == <span class="string">&quot;A&quot;</span> : </span><br><span class="line">            stack.append(<span class="number">6</span>)  <span class="comment"># case6: 选择向右</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> tmp == <span class="string">&quot;B&quot;</span> :</span><br><span class="line">            stack.append(<span class="number">7</span>)  <span class="comment"># case7: 选择向左</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> tmp == <span class="string">&quot;C&quot;</span> :</span><br><span class="line">            <span class="keyword">del</span> stack[-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span> : <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> case == <span class="number">6</span>:     <span class="comment"># 选择向右</span></span><br><span class="line">        print(<span class="string">&#x27;卢本伟顺着通风管道爬到了天台&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;在天台，卢本伟发现了 A.喷气背包 B.马桶塞&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;你会选择什么装备逃生？&#x27;</span>)</span><br><span class="line">        tmp = <span class="built_in">input</span>(<span class="string">&#x27;A.喷气背包 B.马桶塞 C.返回上一步 其他.结束游戏\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> tmp == <span class="string">&quot;A&quot;</span> : </span><br><span class="line">            stack.append(<span class="number">8</span>)  <span class="comment"># case8: 选择喷气背包</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> tmp == <span class="string">&quot;B&quot;</span> :</span><br><span class="line">            stack.append(<span class="number">9</span>)  <span class="comment"># case9: 选择马桶塞</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> tmp == <span class="string">&quot;C&quot;</span> :</span><br><span class="line">            <span class="keyword">del</span> stack[-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span> : <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> case == <span class="number">7</span>:     <span class="comment"># 选择向左</span></span><br><span class="line">        print(<span class="string">&#x27;警察们在会议室开会，而卢本伟不小心掉进了会议室，game over&#x27;</span>)</span><br><span class="line">        tmp = <span class="built_in">input</span>(<span class="string">&#x27;输入A重开游戏，输入B返回上一步，输入其他结束游戏\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> tmp == <span class="string">&quot;A&quot;</span>:</span><br><span class="line">            stack = []</span><br><span class="line">            stack.append(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> tmp == <span class="string">&quot;B&quot;</span>:</span><br><span class="line">            <span class="keyword">del</span> stack[-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span> : <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> case == <span class="number">8</span>:       <span class="comment"># case8: 选择喷气背包</span></span><br><span class="line">        print(<span class="string">&#x27;伞兵一号卢本伟准备就绪！！！&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;Oh这是个坏的喷气背包，卢本伟摔死了&#x27;</span>)</span><br><span class="line">        tmp = <span class="built_in">input</span>(<span class="string">&#x27;输入A重开游戏，输入B返回上一步，输入其他结束游戏\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> tmp == <span class="string">&quot;A&quot;</span>:</span><br><span class="line">            stack = []</span><br><span class="line">            stack.append(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> tmp == <span class="string">&quot;B&quot;</span>:</span><br><span class="line">            <span class="keyword">del</span> stack[-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span> : <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> case == <span class="number">9</span>:       <span class="comment"># case9: 选择马桶塞</span></span><br><span class="line">        print(<span class="string">&#x27;卢本伟左手一个马桶塞，右手一个马桶塞&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;凭借强大的臂力和马桶塞的吸力，卢本伟成功的飞檐走壁逃出监狱！！&#x27;</span>)</span><br><span class="line">        tmp = <span class="built_in">input</span>(<span class="string">&#x27;输入A重开游戏，输入B返回上一步，输入其他结束游戏\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> tmp == <span class="string">&quot;A&quot;</span>:</span><br><span class="line">            stack = []</span><br><span class="line">            stack.append(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> tmp == <span class="string">&quot;B&quot;</span>:</span><br><span class="line">            <span class="keyword">del</span> stack[-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span> : <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> case == <span class="number">3</span>:       <span class="comment"># case3: 选择钻机</span></span><br><span class="line">        print(<span class="string">&#x27;你选择了钻机，卢本伟使用钻机钻地，发现地下还有个房间&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;卢本伟想都没想直接跳进了下面的房间，环顾四周&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;房间里有一个井盖好像可以撬开，还有一个传送器上面写着“你会变得透明并可以穿墙”&#x27;</span>)</span><br><span class="line">        tmp = <span class="built_in">input</span>(<span class="string">&#x27;你会选择？ A.传送器 B.撬棍 C.返回上一步 其他.结束游戏\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> tmp == <span class="string">&quot;A&quot;</span> : </span><br><span class="line">            stack.append(<span class="number">10</span>)  <span class="comment"># case10: 选择传送器</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> tmp == <span class="string">&quot;B&quot;</span> :</span><br><span class="line">            stack.append(<span class="number">11</span>)  <span class="comment"># case11: 选择撬棍</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> tmp == <span class="string">&quot;C&quot;</span> :</span><br><span class="line">            <span class="keyword">del</span> stack[-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span> : <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> case == <span class="number">10</span>:</span><br><span class="line">        print(<span class="string">&#x27;你选择了传送器&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;卢本伟按下了传送器，他开始变得透明，墙无法阻挡他，但是地面也无法支撑他，卢本伟直接沉到了地心，死了&#x27;</span>)</span><br><span class="line">        tmp = <span class="built_in">input</span>(<span class="string">&#x27;输入A重开游戏，输入B返回上一步，输入其他结束游戏\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> tmp == <span class="string">&quot;A&quot;</span>:</span><br><span class="line">            stack = []</span><br><span class="line">            stack.append(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> tmp == <span class="string">&quot;B&quot;</span>:</span><br><span class="line">            <span class="keyword">del</span> stack[-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span> : <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> case == <span class="number">11</span>:</span><br><span class="line">        print(<span class="string">&#x27;你选择了撬棍&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;卢本伟撬开了井盖，钻进井盖发现掉到了一楼大厅走廊上&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;卢本伟被两个警察发现，警察们追着他跑&#x27;</span>)</span><br><span class="line">        tmp = <span class="built_in">input</span>(<span class="string">&#x27;这时你会？ A.往左跑 B.往右跑 C.返回上一步 其他.结束游戏\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> tmp == <span class="string">&quot;A&quot;</span>:</span><br><span class="line">            stack.append(<span class="number">12</span>)   <span class="comment"># case12: 往左跑</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> tmp == <span class="string">&quot;B&quot;</span>:</span><br><span class="line">            stack.append(<span class="number">13</span>)   <span class="comment"># case13: 往右跑</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> tmp == <span class="string">&quot;C&quot;</span>:</span><br><span class="line">            <span class="keyword">del</span> stack[-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span> : <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> case == <span class="number">12</span>:</span><br><span class="line">        print(<span class="string">&#x27;你选择向左逃跑&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;那两个警察追不上卢本伟，但是追的人越来越多&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;现在卢本伟被五个带枪的警察包围&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;但是凭借卢本伟的走位，他们一枪没中，甚至射死了自己人&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;卢本赶紧趁乱跑到门口抢了一辆警车跑了&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;越狱成功，game over...&#x27;</span>)</span><br><span class="line">        tmp = <span class="built_in">input</span>(<span class="string">&#x27;输入A重开游戏，输入B返回上一步，输入其他结束游戏\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> tmp == <span class="string">&quot;A&quot;</span>:</span><br><span class="line">            stack = []</span><br><span class="line">            stack.append(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> tmp == <span class="string">&quot;B&quot;</span>:</span><br><span class="line">            <span class="keyword">del</span> stack[-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span> : <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> case == <span class="number">13</span>:</span><br><span class="line">        print(<span class="string">&#x27;卢本伟边走位边逃跑的时候还就那个不小心一头簪死在柱子上&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;无敌的卢本伟倒下了&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;game over...&#x27;</span>)</span><br><span class="line">        tmp = <span class="built_in">input</span>(<span class="string">&#x27;输入A重开游戏，输入B返回上一步，输入其他结束游戏\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> tmp == <span class="string">&quot;A&quot;</span>:</span><br><span class="line">            stack = []</span><br><span class="line">            stack.append(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> tmp == <span class="string">&quot;B&quot;</span>:</span><br><span class="line">            <span class="keyword">del</span> stack[-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span> : <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>下面是剧情介绍（建议去上面的视频链接，更加清晰）：</p><p>&gt;<br>&gt;</p><blockquote><p>卢本伟越狱记</p><p>卢本伟开外挂被抓了，你能帮助卢本伟成功越狱吗？（你需要扮演卢本伟完成越狱）</p><p>卢本伟被关在监狱，来了俩警察</p><p>警察1:“you are free guy，骗你的”</p><p>警察1:“你有个朋友给你寄了一个包裹，但是你不要想着轻举妄动，我们已经检查过里面了，是吧？”</p><p>警察2:“（心虚）是啊是啊，我当然检查过了，这是我的工作嘛”</p><p>卢本伟打开了包裹，发现一个生日蛋糕，生日蛋糕里面居然藏了东西，你会选择？A.锉刀 B.钻机</p><p>A.锉刀：你选择了锉刀，卢本伟切割了监狱门，并打倒了守卫，这时有人追了过来</p><p>​        你躲进了一个小房间，房间里有：A.手雷   B.椅子</p><p>​    A.手雷：两个人来抓你，你把自己炸死了</p><p>​    B.椅子：你通过椅子，爬进了通风管道，向左向右？</p><p>​        A.右 你爬到了天台，天台上有：A.喷气背包 B.马桶塞</p><p>​            A.伞兵一号卢本伟准备就绪，Oh，这是个坏的喷气背包，你摔死了</p><p>​            B.你成功的通过马桶塞一步一步吸住墙壁越狱成功！</p><p>​        B.左 警察们在会议室开会，你不小心掉进了会议室，game over</p><p>B.钻机：你选择了钻机，使用钻机钻地，你发现地下还有个房间，</p><p>​    房间里有一个井盖好像可以撬开，还有一个传送器上面写着“你会变得透明并可以穿墙”</p><p>​    A.传送器  B.撬棍</p><p>​    A.你按下了传送器，墙无法阻挡你，地面也无法支撑你，你直接沉到了地球核心，死了</p><p>​    B.你撬开了井盖，掉到了走廊，两个警察追着你跑</p><p>​        A.往左 你被五个人围住，但是凭借着走位，他们一枪没中，你抢了一辆警车跑路了</p><p>​        B.往右 你撞上了柱子，无敌的你倒下了 </p></blockquote><p>游戏装备介绍：</p><p>传送器：</p><p><img src="/2020/12/17/python-%E6%96%87%E5%AD%97%E7%89%88RPG%E5%B0%8F%E6%B8%B8%E6%88%8F/image-20201217155929460.png" alt="image-20201217155929460"></p><p>马桶塞：</p><p><img src="/2020/12/17/python-%E6%96%87%E5%AD%97%E7%89%88RPG%E5%B0%8F%E6%B8%B8%E6%88%8F/image-20201217155949961.png" alt="image-20201217155949961"></p><p>步骤：</p><p><img src="/2020/12/17/python-%E6%96%87%E5%AD%97%E7%89%88RPG%E5%B0%8F%E6%B8%B8%E6%88%8F/UNADJUSTEDNONRAW_thumb_10c.png" alt="UNADJUSTEDNONRAW_thumb_10c"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;之前龙哥给我们布置了两个任务&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://panlianghnu.github.io/2020/12/14/Coder-语言快速上手/&quot;&gt;语言快速上手-学习任务&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;这是第一个&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/20</summary>
      
    
    
    
    
    <category term="python" scheme="https://panlianghnu.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python快速入门</title>
    <link href="https://panlianghnu.github.io/2020/12/15/Python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <id>https://panlianghnu.github.io/2020/12/15/Python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</id>
    <published>2020-12-15T02:49:20.000Z</published>
    <updated>2021-03-14T15:00:19.749Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python快速入门"><a href="#Python快速入门" class="headerlink" title="Python快速入门"></a>Python快速入门</h1><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h4 id="定义一个函数"><a href="#定义一个函数" class="headerlink" title="定义一个函数"></a>定义一个函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">functionname</span>(<span class="params"> parameters </span>):</span></span><br><span class="line">   function_suite</span><br><span class="line">   <span class="keyword">return</span> [expression]</span><br></pre></td></tr></table></figure><h4 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h4><p>python里一切都是对象，参数都是对象的引用</p><ul><li><p>不可变类型：如整数、浮点数、字符串、元组()</p></li><li><p>可变类型：如列表、字典、自定义对象</p></li></ul><p>不可变类型作为参数传入时，对参数的修改其实是修改另一个复制的对象</p><p>可变类型作为参数传入时，函数内的修改会影响到函数外</p><h4 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h4><p>传参数时，要么按照要求（参数顺序，数量）严格传入参数，要么使用关键字参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(climbStairs(climbStairs,<span class="number">5</span>))  <span class="comment"># 斐波那契</span></span><br><span class="line">print(climbStairs(n=<span class="number">5</span>,self=climbStairs))  <span class="comment"># 斐波那契</span></span><br></pre></td></tr></table></figure><p>使用关键字参数，就可以不严格按照顺序来传参，并且代码可读性更好</p><p>注意⚠️：关键字参数不能和普通传参混用，一个参数是关键字参数，其他也要是</p><h4 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printHello</span>(<span class="params">arg=<span class="string">&quot;hello&quot;</span></span>):</span></span><br><span class="line">    print(arg)</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>这个函数可以不输入参数，也可以输入一个参数来替换默认的”hello”</p><h4 id="不定长参数"><a href="#不定长参数" class="headerlink" title="不定长参数"></a>不定长参数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printAll</span>(<span class="params">arg1, *vartuple</span>):</span>  </span><br><span class="line">     <span class="comment"># *vartuple 表示不定长参数，0~n个都可以</span></span><br><span class="line">     <span class="comment"># 而 arg1 保证至少有一个参数传进来，该函数不至于输出空</span></span><br><span class="line">    print(arg1)</span><br><span class="line">    <span class="keyword">for</span> var <span class="keyword">in</span> vartuple:</span><br><span class="line">        print(var)</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure><h4 id="匿名函数（lambda）"><a href="#匿名函数（lambda）" class="headerlink" title="匿名函数（lambda）"></a>匿名函数（lambda）</h4><p>python 使用 lambda 来创建匿名函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># lambda arg1,arg2,arg3... : expression</span></span><br><span class="line"><span class="built_in">pow</span> = <span class="keyword">lambda</span> arg1,arg2 : arg1 ** arg2  </span><br><span class="line"><span class="comment"># pow变量指向 lambda 这个匿名函数</span></span><br><span class="line"><span class="comment"># lambda只是一个表达式，函数体比def简单很多，仅仅能在lambda表达式中封装有限的逻辑进去</span></span><br><span class="line"><span class="comment"># 不能访问自有参数列表之外或全局命名空间里的参数！！</span></span><br><span class="line"><span class="comment"># 不等同于C或C++的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率</span></span><br></pre></td></tr></table></figure><h4 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h4><p><strong>全局变量</strong></p><p>定义在函数外，可以在整个程序范围内访问</p><p><strong>局部变量</strong></p><p>定义在函数内，只能在函数内访问</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量没有类型，变量是任意对象的引用，变量的赋值不需要声明，python是动态类型+强类型的语言</p><h4 id="标准数据类型"><a href="#标准数据类型" class="headerlink" title="标准数据类型"></a>标准数据类型</h4><p>python 提供了6个标准数据类型 </p><p>注意⚠️：没有提供数组类型，建议用列表替代   <strong>a = [ 0 for i in range(1000) ] </strong></p><ul><li>Numbers              不可变</li><li>Strings                   不可变    序列</li><li>Tuple  (元组)         不可变    序列       （虽然元组的元素不可改变，但是元组可以包含可变对象）</li><li>List  [列表]                            序列</li><li>Dictionary  {字典} </li><li>Set  集合</li></ul><p><strong>Numbers :</strong></p><ul><li>int （有符号整数）</li><li><p>Long (python2.2 之后被移除，int 溢出会自动变为 long)</p></li><li><p>float （浮点数）</p></li><li>complex（复数）</li></ul><p><strong>Strings :</strong></p><p>字符串取值：</p><ul><li>从左到右 str[0] ~ str[len-1]</li><li>从右到左 str[-1] ~ str[-len]</li></ul><p>截取字符串：[头下表 : 尾下标]     <strong>这将返回一个新的对象</strong></p><p><img src="/2020/12/15/Python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20201215113418036.png" alt="image-20201215113418036"></p><p>Python列表截取还要第三个参数（步长）</p><p><img src="/2020/12/15/Python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20201215113930063.png" alt="image-20201215113930063"></p><p><strong>列表：</strong></p><p>列表可以完成大多数集合类的数据结构实现 <strong>最常用的类型</strong></p><p>它支持字符，数字，字符串甚至可以包含列表（即嵌套）</p><p>用 + 连接列表， 用 * 表示重复操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&#x27;12345&#x27;</span></span><br><span class="line">b = a[<span class="number">2</span>:] + a[<span class="number">4</span>:]</span><br><span class="line">print(b * <span class="number">2</span>)</span><br><span class="line">输出：<span class="number">34553455</span></span><br></pre></td></tr></table></figure><p>列表内置方法很多</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">append clear copy count extend</span><br><span class="line">index pop remove reverse sort</span><br></pre></td></tr></table></figure><p>列表的元素是可以删除的： del  a[2] </p><p>适用于列表的方法：</p><p>cmp(list1, list2) , 列表类型不同则没啥意义，类型相同则</p><ul><li>哪个列表短哪个列表就小，返回1或-1</li><li>一样长则元素小列表就小，返回1或-1</li><li>所有元素相同则返回0</li></ul><p>len(list)，获得列表长度</p><p>max(list)，返回列表元素最大值</p><p>min(list)，返回列表元素最小值</p><p>list(seq)，将元组转换为列表</p><p><strong>元组：</strong></p><p>可以理解为只读列表，不能二次赋值</p><p>元组用 () 标识</p><p>删除元组只能删除整个元组 del tup</p><p><strong>字典：</strong></p><p>字典(dictionary)是除列表以外python之中最灵活的内置数据结构类型</p><p>字典用 {} 标识</p><p>通过 dict[key] 来访问 value</p><p>字典的key 必须是不可变对象</p><p>可以删除 key-value 也能显示删除整个字典 : del dict[‘key’]  、 del dict</p><p>字典包括以下内置方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">clear get </span><br><span class="line">has_key(key)</span><br><span class="line">copy(浅复制) </span><br><span class="line">items <span class="comment"># 以列表返回可以遍历的 key-value 元组</span></span><br><span class="line">fromkeys(seq[,val])  <span class="comment"># 返回一个列表，keys为这个序列的值，val为默认值</span></span><br><span class="line">keys(返回所有key)</span><br><span class="line">values（返回所有值）</span><br><span class="line">upadte(dict2)   <span class="comment"># 把dict2的键值对更新到dict里</span></span><br><span class="line">pop(key)</span><br><span class="line">popitem()       <span class="comment"># 返回并删除字典中最后一对 key-value</span></span><br></pre></td></tr></table></figure><p><strong>数据类型转换</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">int(x [,base])</td><td style="text-align:center">将x转换为一个整数</td></tr><tr><td style="text-align:center">long(x [,base])</td><td style="text-align:center">将x转换为一个长整数</td></tr><tr><td style="text-align:center">float(x)</td><td style="text-align:center">将x转换到一个浮点数</td></tr><tr><td style="text-align:center">complex(real [,imag])</td><td style="text-align:center">创建一个复数</td></tr><tr><td style="text-align:center">str(x)</td><td style="text-align:center">将对象 x 转换为字符串</td></tr><tr><td style="text-align:center">repr(x)</td><td style="text-align:center">将对象 x 转换为表达式字符串</td></tr><tr><td style="text-align:center">eval(str)</td><td style="text-align:center">用来计算在字符串中的有效Python表达式,并返回一个对象</td></tr><tr><td style="text-align:center">tuple(s)</td><td style="text-align:center">将序列 s 转换为一个元组</td></tr><tr><td style="text-align:center">list(s)</td><td style="text-align:center">将序列 s 转换为一个列表</td></tr><tr><td style="text-align:center">set(s)</td><td style="text-align:center">转换为可变集合</td></tr><tr><td style="text-align:center">dict(d)</td><td style="text-align:center">创建一个字典。d 必须是一个序列 (key,value)元组。</td></tr><tr><td style="text-align:center">frozenset(s)</td><td style="text-align:center">转换为不可变集合</td></tr><tr><td style="text-align:center">chr(x)</td><td style="text-align:center">将一个整数转换为一个字符</td></tr><tr><td style="text-align:center">unichr(x)</td><td style="text-align:center">将一个整数转换为Unicode字符</td></tr><tr><td style="text-align:center">ord(x)</td><td style="text-align:center">将一个字符转换为它的整数值</td></tr><tr><td style="text-align:center">hex(x)</td><td style="text-align:center">将一个整数转换为一个十六进制字符串</td></tr><tr><td style="text-align:center">oct(x)</td><td style="text-align:center">将一个整数转换为一个八进制字符串</td></tr></tbody></table></div><h2 id="元组包含可变对象时"><a href="#元组包含可变对象时" class="headerlink" title="元组包含可变对象时"></a>元组包含可变对象时</h2><p>直接上代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">b = <span class="number">4</span></span><br><span class="line">c = (a,b) <span class="comment"># c为包含可变对象的元组</span></span><br><span class="line">print(c)</span><br><span class="line">a.append(<span class="number">3</span>)</span><br><span class="line">print(c)</span><br><span class="line">a = [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">print(c)</span><br><span class="line"></span><br><span class="line">打印结果：</span><br><span class="line">([<span class="number">1</span>, <span class="number">2</span>], <span class="number">4</span>)</span><br><span class="line">([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>)</span><br><span class="line">([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>可以看到，当 a.append(3)后，c[0]变化了。当 a = [5,6,7] 时，c[0]没变</p><p>所以，元组的元素不可变应该这样理解，生成元组时，元组里的所有元素都会被保存在数据区</p><ul><li><p>a = [5,6,7]，是像字符串赋值那样重新开辟了内存空间，让a指向新的内存，但是元组内的值还是指向原来的内存，所以这个情况元组的值是不会变化的</p></li><li><p>a.append(3)，a本身是没有变化的，但是a指向的内存里的值发生了变化，所以元组也”变化”了</p></li></ul><p>再来看一个情况</p><p><img src="/2020/12/15/Python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20201215225743487.png" alt="image-20201215225743487"></p><p>这个情况也是 a.append()。为什么c没有变化呢？</p><p>list底层是数组实现的，添加这么多元素后，a 指向的内存地址发生了变化，而元组内的值指向的内存地址是不会发生变化的，所以这个时候，a和元组内的”a” 不是一个a了</p><p><strong>所谓元组的不可变指的是元组所指向的内存中的内容不可变</strong></p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p><strong>算数运算：</strong></p><p>+ - * / %  </p><p>**(返回x的y次幂)</p><p>//（返回商的整数部分，python里整数除以整数也会转换成浮点数）</p><p><strong>比较运算：</strong></p><p>==  比较对象是否相等 (字符串可以用这个比较)</p><p>!=  比较对象是否不等   </p><blockquote><pre><code>&lt;      &gt;=      &lt;=</code></pre></blockquote><p><strong>位运算：</strong></p><p>&amp; 按位与</p><p>| 按位或</p><p>^ 按位异或</p><p>~ 按位取反</p><p>&lt;&lt; 左移 （不会溢出，自动变成long）</p><p>>&gt; 右移 （它是算数右移，-4右移变成-2）</p><p><strong>逻辑运算：</strong></p><p>and or not</p><p><strong>成员运算：</strong></p><p>in：如果在指定的序列中找到值返回 True，否则返回 False。</p><p>not in： 如果在指定的序列中没有找到值返回 True，否则返回 False。</p><p><strong>身份运算：</strong></p><p>用于判断变量是否指向同一个对象</p><p>is （和==不一样，==是判断值，is 判断对象）</p><p>is not</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = student(name=<span class="string">&quot;panliang&quot;</span>,age=<span class="number">4</span>)</span><br><span class="line">b = student(name=<span class="string">&quot;panliang&quot;</span>,age=<span class="number">4</span>)</span><br><span class="line"><span class="keyword">if</span> a == b:</span><br><span class="line">    print(<span class="string">&quot;a == b&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&quot;a != b&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> a <span class="keyword">is</span> b: </span><br><span class="line">    print(<span class="string">&quot;a is b&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&quot;a is not b&quot;</span>)</span><br></pre></td></tr></table></figure><p>打印结果：<img src="/2020/12/15/Python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20201215153923819.png" alt="image-20201215153923819"></p><p>可以看到，自定义对象不能用 == 比较（python字符串可以），就算他们的内容相同</p><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (condition):</span><br><span class="line">  statements</span><br></pre></td></tr></table></figure><p>contidion 可以是任何表达式，任何非零、或非空（null）的值均为true。</p><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> sequence:</span><br><span class="line">  statements</span><br></pre></td></tr></table></figure><p>遍历序列所有的元素   </p><p>注意⚠️：给列表赋值时，这样写是不行的 for i in seq 返回的是新的对象</p><p>for 循环经常和 range 函数配合使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">  statements</span><br></pre></td></tr></table></figure><p>range(n)会返回一个列表，i 会从0遍历到n-1</p><p>range也支持多个参数，比如反向遍历 range(n,0,-1)，遍历从n到1（不会到0）</p><p><strong>python3的range()函数返回的是一个可迭代对象（类型是对象），而不是列表（为了性能），所以打印range不会输出列表</strong></p><h4 id="循环的else"><a href="#循环的else" class="headerlink" title="循环的else"></a>循环的else</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>,<span class="number">20</span>):  <span class="comment"># 迭代 10 到 20 之间的数字</span></span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,num): <span class="comment"># 根据因子迭代</span></span><br><span class="line">      <span class="keyword">if</span> num%i == <span class="number">0</span>:      <span class="comment"># 确定第一个因子</span></span><br><span class="line">         j=num/i          <span class="comment"># 计算第二个因子</span></span><br><span class="line">         <span class="built_in">print</span> <span class="string">&#x27;%d 等于 %d * %d&#x27;</span> % (num,i,j)</span><br><span class="line">         <span class="keyword">break</span>            <span class="comment"># 跳出当前循环</span></span><br><span class="line">   <span class="keyword">else</span>:                  <span class="comment"># 循环的 else 部分</span></span><br><span class="line">      <span class="built_in">print</span> num, <span class="string">&#x27;是一个质数&#x27;</span></span><br><span class="line"><span class="comment"># 当循环没有通过break跳出来时， 会执行 else    while循环也类似</span></span><br></pre></td></tr></table></figure><h2 id="模块、输入和输出"><a href="#模块、输入和输出" class="headerlink" title="模块、输入和输出"></a>模块、输入和输出</h2><h4 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> sys.argv:</span><br><span class="line">  print(i)</span><br><span class="line">print(<span class="string">&#x27;\nPython路径为：&#x27;</span>,sys.path,<span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure><p>代码回输出所有通过命令行传入的参数</p><p>sys.path 包含了一个 Python 解释器自动查找所需模块的路径的列表（相当于环境变量）</p><p>import时，会自动执行被导入的包里的程序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">如果希望自己的程序不在被<span class="keyword">import</span>时执行，需要把自己的程序代码写在</span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">  print(<span class="string">&#x27;我自己在运行&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  print(<span class="string">&#x27;我来自另一模块&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="包"><a href="#包" class="headerlink" title="包"></a>包</h4><p>包是一种管理 Python 模块命名空间的形式，采用 package.module 就不会让不同包的模块混淆以及不同模块之间的全局变量互相影响</p><p>在导入一个包的时候，Python 会根据 sys.path 中的目录来寻找这个包中包含的子目录</p><p>目录只有包含一个叫做  __init__.py 的文件才会被认作是一个包，主要是为了避免一些滥俗的名字</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">可能的包结构</span><br><span class="line">sound/                          顶层包</span><br><span class="line">      __init__.py               初始化 sound 包</span><br><span class="line">      formats/                  文件格式转换子包</span><br><span class="line">              __init__.py</span><br><span class="line">              wavread.py</span><br><span class="line">              wavwrite.py</span><br><span class="line">              aiffread.py</span><br><span class="line">              aiffwrite.py</span><br><span class="line">              auread.py</span><br><span class="line">              auwrite.py</span><br><span class="line">              ...</span><br><span class="line">      effects/                  声音效果子包</span><br><span class="line">              __init__.py</span><br><span class="line">              echo.py</span><br><span class="line">              surround.py</span><br><span class="line">              reverse.py</span><br><span class="line">              ...</span><br><span class="line">      filters/                  filters 子包</span><br><span class="line">              __init__.py</span><br><span class="line">              equalizer.py</span><br><span class="line">              vocoder.py</span><br><span class="line">              karaoke.py</span><br><span class="line">              ...</span><br></pre></td></tr></table></figure><p>可以  imort sound.formats.auwrite 来导入 auwrite 模块</p><p>但是调用函数时，也需要sound.formats.auwrite.function</p><p>所以不妨这样 from sound.formats import auwrite</p><p>调用函数时，只需要 auwrite.function , 无需冗长前缀</p><p>甚至可以只导入一个函数或者变量：</p><p>from sound.effects.echo import echofilter</p><p>这种方法会导入子模块: echo，并且可以直接使用他的 echofilter() 函数</p><p>当使用 <strong>from package import item</strong> 时， import 语法会首先把 item 当作一个包定义的名称，如果没找到，再试图按照一个模块去导入。最后按照函数、类、变量这样去找。</p><p>如果还没找到，抛出一个 <strong>:exc:ImportError</strong> 异常。</p><p>反之，如果使用形如 <strong>import item.subitem.subsubitem</strong> 这种导入形式，除了最后一项，都必须是包，而最后一项则可以是模块或者是包，但是不可以是类，函数或者变量的名字。</p><p>从包里导入*，会找到目录下所有的子模块，都导入，但是在windows这类大小写不分的平台上工作很不好，需要包作者在 __init__.py 里的一个 all 列表变量写入导入的包名</p><h2 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h2><h4 id="标准输入输出"><a href="#标准输入输出" class="headerlink" title="标准输入输出"></a>标准输入输出</h4><p>Python提供了 input() 内置函数从标准输入读入一行文本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="built_in">input</span>(<span class="string">&quot;请输入:&quot;</span>)</span><br><span class="line">print(<span class="built_in">str</span>)</span><br></pre></td></tr></table></figure><h4 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">txt = <span class="built_in">open</span>(<span class="string">&#x27;addTowNum.py&#x27;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"><span class="built_in">str</span> = txt.read()</span><br><span class="line">print(<span class="built_in">str</span>)</span><br></pre></td></tr></table></figure><p>open有两个参数，一个是filename， 一个是文件打开模式（可以不写，默认模式为 r ）</p><p>file.read()有一个参数size，表示读取的数据数量（可以不写，默认读文件所有字符）</p><p>file.readline() 读文件一行</p><p>file.write(str) 将str写入文件，返回写入的字符数</p><div class="table-container"><table><thead><tr><th style="text-align:left">模式</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">r</td><td style="text-align:left">以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。</td></tr><tr><td style="text-align:left">rb</td><td style="text-align:left">以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。</td></tr><tr><td style="text-align:left">r+</td><td style="text-align:left">打开一个文件用于读写。文件指针将会放在文件的开头。</td></tr><tr><td style="text-align:left">rb+</td><td style="text-align:left">以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。</td></tr><tr><td style="text-align:left">w</td><td style="text-align:left">打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td></tr><tr><td style="text-align:left">wb</td><td style="text-align:left">以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td></tr><tr><td style="text-align:left">w+</td><td style="text-align:left">打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td></tr><tr><td style="text-align:left">wb+</td><td style="text-align:left">以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td></tr><tr><td style="text-align:left">a</td><td style="text-align:left">打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td></tr><tr><td style="text-align:left">ab</td><td style="text-align:left">以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td></tr><tr><td style="text-align:left">a+</td><td style="text-align:left">打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。</td></tr><tr><td style="text-align:left">ab+</td><td style="text-align:left">以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。</td></tr></tbody></table></div><p><img src="/2020/12/15/Python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/2112205-861c05b2bdbc9c28.png" alt="img"></p><p>file.close() 关闭文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;/tmp/foo.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">read_data = f.read()</span><br><span class="line">f.closed</span><br><span class="line">使用<span class="keyword">with</span> 比 <span class="keyword">try</span> <span class="keyword">finally</span> 简单</span><br></pre></td></tr></table></figure><h2 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h2><p>import time</p><h4 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h4><p>time.time()   用于获取当前时间戳（是一个浮点数，表示从1970年1月1日午夜，经过了多少秒）</p><p>无法表示1970年之后的、Unix和Windows只支持到2038年</p><p>非常适合用于计算时间差</p><h4 id="时间元组"><a href="#时间元组" class="headerlink" title="时间元组"></a>时间元组</h4><p>很多python函数用包含9个元素的元组来处理时间：</p><p>struct_time 元组</p><div class="table-container"><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">属性</th><th style="text-align:left">值</th></tr></thead><tbody><tr><td style="text-align:left">0</td><td style="text-align:left">tm_year</td><td style="text-align:left">2008</td></tr><tr><td style="text-align:left">1</td><td style="text-align:left">tm_mon</td><td style="text-align:left">1 到 12</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">tm_mday</td><td style="text-align:left">1 到 31</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">tm_hour</td><td style="text-align:left">0 到 23</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">tm_min</td><td style="text-align:left">0 到 59</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left">tm_sec</td><td style="text-align:left">0 到 61 (60或61 是闰秒)</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left">tm_wday</td><td style="text-align:left">0到6 (0是周一)</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left">tm_yday</td><td style="text-align:left">1 到 366(儒略历)</td></tr><tr><td style="text-align:left">8</td><td style="text-align:left">tm_isdst</td><td style="text-align:left">-1, 0, 1, -1是决定是否为夏令时的旗帜</td></tr></tbody></table></div><h4 id="时间戳转换为时间元组"><a href="#时间戳转换为时间元组" class="headerlink" title="时间戳转换为时间元组"></a>时间戳转换为时间元组</h4><p>只需要将浮点数传递给如 localtime 之类的函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line">localtime = time.localtime(time.time())</span><br><span class="line">print(<span class="string">&quot;本地时间为：&quot;</span>,localtime)</span><br><span class="line"></span><br><span class="line">本地时间为：time.struct_time(tm_year=<span class="number">2020</span>, tm_mon=<span class="number">12</span>, tm_mday=<span class="number">15</span>, tm_hour=<span class="number">17</span>, tm_min=<span class="number">11</span>, tm_sec=<span class="number">52</span>, tm_wday=<span class="number">1</span>, tm_yday=<span class="number">350</span>, tm_isdst=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h4 id="获取格式化时间"><a href="#获取格式化时间" class="headerlink" title="获取格式化时间"></a>获取格式化时间</h4><p>你可以获取时间元组，然后自定义输出</p><p>但是有一个函数可以很方便得将时间元组转换成字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line">localtime = time.localtime(time.time())</span><br><span class="line">asctime = time.asctime(localtime)</span><br><span class="line">print(asctime)</span><br><span class="line"></span><br><span class="line">Tue Dec <span class="number">15</span> <span class="number">17</span>:<span class="number">20</span>:<span class="number">16</span> <span class="number">2020</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Python快速入门&quot;&gt;&lt;a href=&quot;#Python快速入门&quot; class=&quot;headerlink&quot; title=&quot;Python快速入门&quot;&gt;&lt;/a&gt;Python快速入门&lt;/h1&gt;&lt;h2 id=&quot;函数&quot;&gt;&lt;a href=&quot;#函数&quot; class=&quot;headerli</summary>
      
    
    
    
    
    <category term="python" scheme="https://panlianghnu.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Anaconda安装</title>
    <link href="https://panlianghnu.github.io/2020/12/14/Anaconda%E5%AE%89%E8%A3%85/"/>
    <id>https://panlianghnu.github.io/2020/12/14/Anaconda%E5%AE%89%E8%A3%85/</id>
    <published>2020-12-14T09:58:36.000Z</published>
    <updated>2021-03-14T15:00:57.684Z</updated>
    
    <content type="html"><![CDATA[<p>Anaconda 是Mac电脑上的一个开源的Python发行版本。Conda是一个开源的包、环境管理器，可以用于在同一个机器上安装不同版本的软件包及其依赖，并能够在不同的环境之间切换。Anaconda包括Conda、Python以及一大堆安装好的工具包，比如：numpy、pandas等。</p><p>　　conda软件包</p><p>　　搜索我们基于云的资源库，查找并安装超过7500个数据科学和机器学习包。使用conda-install命令，您可以开始使用成千上万的开源Conda、R、Python和其他许多软件包。</p><p>　　管理环境</p><p>　　个人版是一个开源、灵活的解决方案，它提供了跨平台方式构建、分发、安装、更新和管理软件的实用工具。<strong>Conda可以轻松管理多个数据环境，这些环境可以单独维护和运行，互不干扰。</strong></p><h3 id="一、下载安装包"><a href="#一、下载安装包" class="headerlink" title="一、下载安装包"></a>一、下载安装包</h3><ul><li><a href="https://www.anaconda.com/distribution/#download-section">Anaconda安装包下载</a></li></ul><p><img src="/2020/12/14/Anaconda%E5%AE%89%E8%A3%85/image-20201214181301536.png" alt="image-20201214181301536"></p><ul><li>官网可能速度比较慢，我在<a href="http://www.pc6.com/mac/842752.html下的">http://www.pc6.com/mac/842752.html下的</a></li></ul><h3 id="二、开始安装"><a href="#二、开始安装" class="headerlink" title="二、开始安装"></a>二、开始安装</h3><p><img src="/2020/12/14/Anaconda%E5%AE%89%E8%A3%85/image-20201214180356537.png" alt="image-20201214180356537"></p><p>一直下一步就行了</p><h3 id="三、安装成功，设置conda环境变量"><a href="#三、安装成功，设置conda环境变量" class="headerlink" title="三、安装成功，设置conda环境变量"></a>三、安装成功，设置conda环境变量</h3><p>我这边不用配环境，默认配好了</p><p>查看验证 conda list</p><p><img src="/2020/12/14/Anaconda%E5%AE%89%E8%A3%85/image-20201214181117531.png" alt="image-20201214181117531"></p><hr><h3 id="conda常用操作命令"><a href="#conda常用操作命令" class="headerlink" title="conda常用操作命令"></a>conda常用操作命令</h3><h5 id="1、查看环境管理的全部命令帮助："><a href="#1、查看环境管理的全部命令帮助：" class="headerlink" title="1、查看环境管理的全部命令帮助："></a>1、查看环境管理的全部命令帮助：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda env -h</span><br><span class="line">或者</span><br><span class="line">conda</span><br></pre></td></tr></table></figure><h5 id="2、查看当前系统下的环境："><a href="#2、查看当前系统下的环境：" class="headerlink" title="2、查看当前系统下的环境："></a>2、查看当前系统下的环境：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda info -e</span><br><span class="line">或者</span><br><span class="line">conda-env list</span><br></pre></td></tr></table></figure><h5 id="3、创建环境："><a href="#3、创建环境：" class="headerlink" title="3、创建环境："></a>3、创建环境：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create env_name     </span><br></pre></td></tr></table></figure><p>【注】 (env_name)是环境名称,这条命令创建一个新的环境，存储位置在安装文件的隐藏文件/.conda文件夹里面</p><p><strong>创建指定python版本的环境：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create env_name python&#x3D;3.6   </span><br></pre></td></tr></table></figure><h5 id="4、激活进入某个环境"><a href="#4、激活进入某个环境" class="headerlink" title="4、激活进入某个环境"></a>4、激活进入某个环境</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">activate env_name</span><br></pre></td></tr></table></figure><h5 id="5、退出某个环境："><a href="#5、退出某个环境：" class="headerlink" title="5、退出某个环境："></a>5、退出某个环境：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deactivate env_name</span><br></pre></td></tr></table></figure><h5 id="6、复制某个环境："><a href="#6、复制某个环境：" class="headerlink" title="6、复制某个环境："></a>6、复制某个环境：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create new_env_name old_env_name</span><br></pre></td></tr></table></figure><h5 id="7、删除某个环境："><a href="#7、删除某个环境：" class="headerlink" title="7、删除某个环境："></a>7、删除某个环境：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda remove env_name</span><br></pre></td></tr></table></figure><h5 id="8、安装包："><a href="#8、安装包：" class="headerlink" title="8、安装包："></a>8、安装包：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda install xxx</span><br><span class="line">pip install xxx</span><br></pre></td></tr></table></figure><h5 id="9、指定的安装环境："><a href="#9、指定的安装环境：" class="headerlink" title="9、指定的安装环境："></a>9、指定的安装环境：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install -n env_name 包名</span><br></pre></td></tr></table></figure><h5 id="10、查看已安装的包："><a href="#10、查看已安装的包：" class="headerlink" title="10、查看已安装的包："></a>10、查看已安装的包：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda list</span><br></pre></td></tr></table></figure><h5 id="11、查看指定环境下的包："><a href="#11、查看指定环境下的包：" class="headerlink" title="11、查看指定环境下的包："></a>11、查看指定环境下的包：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda list -n 环境名</span><br></pre></td></tr></table></figure><h5 id="12、查找包："><a href="#12、查找包：" class="headerlink" title="12、查找包："></a>12、查找包：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda search 包名</span><br></pre></td></tr></table></figure><h5 id="13、更新包："><a href="#13、更新包：" class="headerlink" title="13、更新包："></a>13、更新包：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda update xxx</span><br></pre></td></tr></table></figure><h5 id="14、安装anaconda发行版中所有的包"><a href="#14、安装anaconda发行版中所有的包" class="headerlink" title="14、安装anaconda发行版中所有的包:"></a>14、安装anaconda发行版中所有的包:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install anaconda</span><br></pre></td></tr></table></figure><h5 id="15、卸载包："><a href="#15、卸载包：" class="headerlink" title="15、卸载包："></a>15、卸载包：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda remove xxx</span><br></pre></td></tr></table></figure><h4 id="三、管理conda"><a href="#三、管理conda" class="headerlink" title="三、管理conda"></a>三、管理conda</h4><h5 id="1、检查conda版本："><a href="#1、检查conda版本：" class="headerlink" title="1、检查conda版本："></a>1、检查conda版本：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda -V# 大写V</span><br></pre></td></tr></table></figure><h5 id="2、升级当前版本的conda："><a href="#2、升级当前版本的conda：" class="headerlink" title="2、升级当前版本的conda："></a>2、升级当前版本的conda：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda update conda</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Anaconda 是Mac电脑上的一个开源的Python发行版本。Conda是一个开源的包、环境管理器，可以用于在同一个机器上安装不同版本的软件包及其依赖，并能够在不同的环境之间切换。Anaconda包括Conda、Python以及一大堆安装好的工具包，比如：numpy、p</summary>
      
    
    
    
    
    <category term="python" scheme="https://panlianghnu.github.io/tags/python/"/>
    
    <category term="Anaconda" scheme="https://panlianghnu.github.io/tags/Anaconda/"/>
    
  </entry>
  
  <entry>
    <title>python简史</title>
    <link href="https://panlianghnu.github.io/2020/12/14/python%E7%AE%80%E5%8F%B2/"/>
    <id>https://panlianghnu.github.io/2020/12/14/python%E7%AE%80%E5%8F%B2/</id>
    <published>2020-12-14T09:35:24.000Z</published>
    <updated>2021-03-14T15:00:12.221Z</updated>
    
    <content type="html"><![CDATA[<p>本文作者：Vamei 出处：<a href="http://www.cnblogs.com/vamei">http://www.cnblogs.com/vamei</a></p><p>Python是我喜欢的语言，简洁，优美，容易使用。前两天，我很激昂的向朋友宣传Python的好处。</p><p>听过之后，朋友问我：好吧，我承认Python不错，但它为什么叫Python呢？</p><p>我不是很确定：呃，似乎是一个电视剧的名字。</p><p>朋友又问：那你说的Guido是美国人么？ (Guido von Rossum，Python的作者)</p><p>我再次不是很确定：他从google换到Dropbox工作，但他的名字像是荷兰人的 (有一个von在中间)。</p><p>所以，后面我花了些时间调查Python的历史。这是很好的学习。我看到了Python中许多功能的来源和Python的设计理念，比如哪些功能是历史遗留，哪些功能是重复，如何增加功能…… 而且，Python也是开源(open source)运动的一个成功案例。从Python的历史中，我们可以一窥开源开发的理念和成就。</p><h3 id="Python的起源"><a href="#Python的起源" class="headerlink" title="Python的起源"></a>Python的起源</h3><p>Python的作者，Guido von Rossum，确实是荷兰人。1982年，Guido从阿姆斯特丹大学(University of Amsterdam)获得了数学和计算机硕士学位。然而，尽管他算得上是一位数学家，但他更加享受计算机带来的乐趣。用他的话说，尽管拥有数学和计算机双料资质，他总趋向于做计算机相关的工作，并热衷于做任何和编程相关的活儿。</p><p><img src="/2020/12/14/python%E7%AE%80%E5%8F%B2/06100633-c2ce8755002945df846b5dad1dc25cdd.jpg" alt="img"></p><p>在那个时候，他接触并使用过诸如Pascal、C、 Fortran等语言。这些语言的基本设计原则是让机器能更快运行。在80年代，虽然IBM和苹果已经掀起了个人电脑浪潮，但这些个人电脑的配置很低 (在今天看来)。比如早期的Macintosh，只有8MHz的CPU主频和128KB的RAM，一个大的数组就能占满内存。所有的编译器的核心是做优化，以便让程序能够运行。为了增进效率，语言也迫使程序员像计算机一样思考，以便能写出更符合机器口味的程序。在那个时代，程序员恨不得用手榨取计算机每一寸的能力。有人甚至认为C语言的指针是在浪费内存。至于动态类型，内存自动管理，面向对象…… 别想了，那会让你的电脑陷入瘫痪。</p><p>然而，这种思考方式让Guido感到苦恼。Guido知道如何用C语言写出一个功能，但整个编写过程需要耗费大量的时间 (即使他已经准确的知道了如何实现)。他的另一个选择是shell。Bourne Shell作为UNIX系统的解释器(interpreter)已经长期存在。UNIX的管理员们常常用shell去写一些简单的脚本，以进行一些系统维护的工作，比如定期备份、文件系统管理等等。shell可以像胶水一样，将UNIX下的许多功能连接在一起。许多C语言下上百行的程序，在shell下只用几行就可以完成。然而，shell的本质是调用命令。它并不是一个真正的语言。比如说，shell没有数值型的数据类型，加法运算都很复杂。总之，shell不能全面的调动计算机的功能。</p><p>(关于shell，你可以参考<a href="http://www.cnblogs.com/vamei/archive/2012/09/19/2692452.html">Linux架构</a>和<a href="http://www.cnblogs.com/vamei/archive/2012/09/10/2676740.html">Linux命令行与命令</a>)</p><p>Guido希望有一种语言，这种语言能够像C语言那样，能够全面调用计算机的功能接口，又可以像shell那样，可以轻松的编程。ABC语言让Guido看到希望。ABC是由荷兰的CWI (Centrum Wiskunde &amp; Informatica, 数学和计算机研究所)开发的。Guido在CWI工作，并参与到ABC语言的开发。ABC语言以教学为目的。与当时的大部分语言不同，ABC语言的目标是“让用户感觉更好”。ABC语言希望让语言变得容易阅读，容易使用，容易记忆，容易学习，并以此来激发人们学习编程的兴趣。比如下面是一段来自Wikipedia的ABC程序，这个程序用于统计文本中出现的词(word)的总数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HOW TO RETURN words document:</span><br><span class="line">   PUT &#123;&#125; IN collection</span><br><span class="line">   FOR line IN document:</span><br><span class="line">      FOR word IN split line:</span><br><span class="line">         IF word not.in collection:</span><br><span class="line">            INSERT word IN collection</span><br><span class="line">   RETURN collection</span><br></pre></td></tr></table></figure><p>HOW TO用于定义一个函数。一个Python程序员应该很容易理解这段程序。ABC语言使用冒号(:)和缩进来表示程序块(C语言使用{}来表示程序块)。行尾没有分号。for和if结构中也没有括号()。如果将HOW TO改为def，将PUT行改为collection = []，将INSERT行改为collection.append(word)，这就几乎是一个标准的Python函数。上面的函数读起来就像一段自然的文字。</p><p>尽管已经具备了良好的可读性和易用性，ABC语言最终没有流行起来。在当时，ABC语言编译器需要比较高配置的电脑才能运行。而这些电脑的使用者通常精通计算机，他们更多考虑程序的效率，而非它的学习难度。除了硬件上的困难外，ABC语言的设计也存在一些致命的问题：</p><ul><li><strong>可拓展性差</strong>。ABC语言不是模块化语言。如果想在ABC语言中增加功能，比如对图形化的支持，就必须改动很多地方。</li><li><strong>不能直接进行IO</strong>。ABC语言不能直接操作文件系统。尽管你可以通过诸如文本流的方式导入数据，但ABC无法直接读写文件。输入输出的困难对于计算机语言来说是致命的。你能想像一个打不开车门的跑车么？</li><li><strong>过度革新</strong>。ABC用自然语言的方式来表达程序的意义，比如上面程序中的HOW TO (如何)。然而对于程序员来说，他们更习惯用function或者define来定义一个函数。同样，程序员也习惯了用等号(=)来分配变量。这尽管让ABC语言显得特别，但实际上增加了程序员的学习难度 (程序员大都掌握不止一种语言)。</li><li><strong>传播困难</strong>。ABC编译器很大，必须被保存在磁带(tape)上。当时Guido在访问的时候，就必须有一个大磁带来给别人安装ABC编译器。 这样，ABC语言就很难快速传播。</li></ul><p><img src="/2020/12/14/python%E7%AE%80%E5%8F%B2/06111717-51622dbe8fbb4e54ae64f834584180c0.gif" alt="img"></p><p>1989年，为了打发圣诞节假期，Guido开始写Python语言的编译/解释器。Python来自Guido所挚爱的电视剧Monty Python’s Flying Circus (BBC1960-1970年代播放的室内情景幽默剧，以当时的英国生活为素材)。他希望这个新的叫做Python的语言，能实现他的理念(一种C和shell之间，功能全面，易学易用，可拓展的语言)。Guido作为一个语言设计爱好者，已经有过设计语言的(不很成功)的尝试。这一次，也不过是一次纯粹的hacking行为。</p><h3 id="Python的诞生"><a href="#Python的诞生" class="headerlink" title="Python的诞生"></a>Python的诞生</h3><p>1991年，第一个Python编译器(同时也是解释器)诞生。它是用C语言实现的，并能够调用C库(.so文件)。从一出生，Python已经具有了：类(class)，函数(function)，异常处理(exception)，包括表(list)和词典(dictionary)在内的核心数据类型，以及模块(module)为基础的拓展系统。</p><p><img src="/2020/12/14/python%E7%AE%80%E5%8F%B2/06121511-82e43957fefe4c13ac06bd02a5e9d97a.png" alt="img"></p><p>最初的Python logo: 由Guido的兄弟Just von Rossum设计</p><p>Python语法很多来自C，但又受到ABC语言的强烈影响。来自ABC语言的一些规定直到今天还富有争议，比如强制缩进。但这些语法规定让Python容易读。另一方面，Python聪明的选择服从一些惯例(特别是C语言的惯例)。比如使用等号赋值，使用def来定义函数。Guido认为，如果“常识”上确立的东西，没有必要过度纠结。</p><p>Python从一开始就特别在意可拓展性(extensibility)。Python可以在多个层次上拓展。从高层上，你可以引入.py文件。在底层，你可以引用C语言的库。Python程序员可以快速的使用Python写.py文件作为拓展模块。但当性能是考虑的重要因素时，Python程序员可以深入底层，写C程序，编译为.so文件引入到Python中使用。Python就好像是使用钢构建房一样，先规定好大的框架。而程序员可以在此框架下相当自由的拓展或更改。</p><p>最初的Python完全由Guido本人开发。Python得到Guido同事的欢迎。他们迅速的反馈使用意见，并参与到Python的改进。Guido和一些同事构成Python的核心团队。他们将自己大部分的业余时间用于hack Python (也包括工作时间，因为他们将Python用于工作)。随后，Python拓展到CWI之外。Python将许多机器层面上的细节隐藏，交给编译器处理，并凸显出逻辑层面的编程思考。Python程序员可以花更多的时间用于思考程序的逻辑，而不是具体的实现细节 (Guido有一件T恤，写着：人生苦短，我用Python)。这一特征吸引了广大的程序员。Python开始流行。</p><p>我们不得不暂停我们的Python时间，转而看一看这时的计算机概况。1990年代初，个人计算机开始进入普通家庭。Intel发布了486处理器，windows发布window 3.0开始的一系列视窗系统。计算机的性能大大提高。程序员开始关注计算机的易用性 (比如图形化界面)。 <img src="/2020/12/14/python%E7%AE%80%E5%8F%B2/06121437-2bed48b285d746c2a147d1d63cc05483.png" alt="img"></p><p>Windows 3.0</p><p>由于计算机性能的提高，软件的世界也开始随之改变。硬件足以满足许多个人电脑的需要。硬件厂商甚至渴望高需求软件的出现，以带动硬件的更新换代。C++和Java相继流行。C++和Java提供了面向对象的编程范式，以及丰富的对象库。在牺牲了一定的性能的代价下，C++和Java大大提高了程序的产量。语言的易用性被提到一个新的高度。我们还记得，ABC失败的一个重要原因是硬件的性能限制。从这方面说，Python要比ABC幸运许多。</p><p>另一个悄然发生的改变是Internet。1990年代还是个人电脑的时代，windows和Intel挟PC以令天下，盛极一时。尽管Internet为主体的信息革命尚未到来，但许多程序员以及资深计算机用户已经在频繁使用Internet进行交流 (包括email和newsgroup)。Internet让信息交流成本大大下降。一种新的软件开发模式开始流行：开源 (open source)。程序员利用业余时间进行软件开发，并开放源代码。1991年，Linus在comp.os.minix新闻组上发布了Linux内核源代码，吸引大批hacker的加入。Linux和GNU相互合作，最终构成了一个充满活力的开源平台。</p><p>硬件性能不是瓶颈，Python又容易使用，所以许多人开始转向Python。Guido维护了一个maillist，Python用户就通过邮件进行交流。Python用户来自许多领域，有不同的背景，对Python也有不同的需求。Python相当的开放，又容易拓展，所以当用户不满足于现有功能，很容易对Python进行拓展或改造。随后，这些用户将改动发给Guido，并由Guido决定是否将新的特征加入到Python或者标准库中。如果代码能被纳入Python自身或者标准库，这将极大的荣誉。Python自身也因此变得更好。</p><p>(Guido不得不作出许多决定，这也是他被称为<a href="http://en.wikipedia.org/wiki/Benevolent_Dictator_For_Life">Benevolent Dictator For Life</a>的原因)</p><p>Python被称为“Battery Included”，是说它以及其标准库的功能强大。这些是整个社区的贡献。Python的开发者来自不同领域，他们将不同领域的优点带给Python。比如Python标准库中的正则表达(regular expression)是参考Perl，而lambda, map, filter, reduce函数参考Lisp。Python本身的一些功能以及大部分的标准库来自于社区。Python的社区不断扩大，进而拥有了自己的newsgroup，网站(python.org)，以及基金 (Python Software Foundation)。从Python 2.0开始，Python也从maillist的开发方式，转为完全开源的开发方式。社区气氛已经形成，工作被整个社区分担，Python也获得了更加高速的发展。</p><p>(由于Guido享有绝对的仲裁权，所以在Python早期maillist的开发时代，不少爱好者相当担心Guido的生命。他们甚至作出假设：如果Guido挂了的话，Python会怎样。见<a href="http://www.python.org/search/hypermail/python-1994q2/1040.html">If Guido was hit by a bus</a>)</p><p>到今天，Python的框架已经确立。Python语言以对象为核心组织代码(Everything is object)，支持多种编程范式(multi-paradigm)，采用动态类型(dynamic typing)，自动进行内存回收(garbage collection)。Python支持解释运行(interpret)，并能调用C库进行拓展。Python有强大的标准库 (battery included)。由于标准库的体系已经稳定，所以Python的生态系统开始拓展到第三方包。这些包，如Django, web.py, wxpython, numpy, matplotlib,PIL，将Python升级成了物种丰富的热带雨林。</p><p>今天Python已经进入到3.0的时代。由于Python 3.0向后不兼容，所以从2.0到3.0的过渡并不容易。另一方面，Python的性能依然值得改进，Python的运算性能低于C++和Java(见<a href="https://groups.google.com/forum/?fromgroups#!topic/unladen-swallow/TtvEBvVEZD4">Google的讨论</a>)。Python依然是一个在发展中的语言。我期待看到Python的未来。</p><h3 id="Python启示录"><a href="#Python启示录" class="headerlink" title="Python启示录"></a>Python启示录</h3><p>Python崇尚优美、清晰、简单，是一个优秀并广泛使用的语言 (TIOBE语言排行第八，Google的第三大开发语言，Dropbox的基础语言，豆瓣的服务器语言)。这个世界并不缺乏优秀的语言，但Python的发展史作为一个代表，带给我许多启示。</p><p>在Python的开发过程中，社区起到了重要的作用。Guido自认为自己不是全能型的程序员，所以他只负责制订框架。如果问题太复杂，他会选择绕过去，也就是cut the corner。这些问题最终由社区中的其他人解决。社区中的人才是异常丰富的，就连创建网站，筹集基金这样与开发稍远的事情，也有人乐意于处理。如今的项目开发越来越复杂，越来越庞大，合作以及开放的心态成为项目最终成功的关键。</p><p>Python从其他语言中学到了很多，无论是已经进入历史的ABC，还是依然在使用的C和Perl，以及许多没有列出的其他语言。可以说，Python的成功代表了它所有借鉴的语言的成功。同样，Ruby借鉴了Python，它的成功也代表了Python某些方面的成功。每个语言都是混合体，都有它优秀的地方，但也有各种各样的缺陷。同时，一个语言“好与不好”的评判，往往受制于平台、硬件、时代等等外部原因。程序员经历过许多语言之争。我想，为什么不以开放的心态和客观的分析，去区分一下每个语言的具体优点缺点，去区分内部和外部的因素。说不定哪一天发现，我不喜欢的某个语言中，正包含了我所需要的东西。</p><p>无论Python未来的命运如何，Python的历史已经是本很有趣的小说。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文作者：Vamei 出处：&lt;a href=&quot;http://www.cnblogs.com/vamei&quot;&gt;http://www.cnblogs.com/vamei&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Python是我喜欢的语言，简洁，优美，容易使用。前两天，我很激昂的向朋友宣传Pytho</summary>
      
    
    
    
    
    <category term="python" scheme="https://panlianghnu.github.io/tags/python/"/>
    
    <category term="转载" scheme="https://panlianghnu.github.io/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>MacOS安装python3并设置默认</title>
    <link href="https://panlianghnu.github.io/2020/12/14/MacOS%E5%AE%89%E8%A3%85python3%E5%B9%B6%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4/"/>
    <id>https://panlianghnu.github.io/2020/12/14/MacOS%E5%AE%89%E8%A3%85python3%E5%B9%B6%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4/</id>
    <published>2020-12-14T09:17:12.000Z</published>
    <updated>2020-12-14T09:18:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MacOS-安装Python3-8并设置为默认版本"><a href="#MacOS-安装Python3-8并设置为默认版本" class="headerlink" title="MacOS 安装Python3.8并设置为默认版本"></a>MacOS 安装Python3.8并设置为默认版本</h1><h3 id="1、安装Python版本管理工具"><a href="#1、安装Python版本管理工具" class="headerlink" title="1、安装Python版本管理工具"></a>1、安装Python版本管理工具</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install pyenv</span><br></pre></td></tr></table></figure><h3 id="2、添加环境变量（使用bash则添加环境变量到-bashrc-或-profile-或-bash-profile）"><a href="#2、添加环境变量（使用bash则添加环境变量到-bashrc-或-profile-或-bash-profile）" class="headerlink" title="2、添加环境变量（使用bash则添加环境变量到.bashrc 或.profile 或.bash_profile）"></a>2、添加环境变量（使用bash则添加环境变量到.bashrc 或.profile 或.bash_profile）</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=&quot;$(pyenv root)/shims:$PATH&quot;&#x27;</span> &gt;&gt; ~/.zshrc</span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure><h3 id="3、安装Python版本"><a href="#3、安装Python版本" class="headerlink" title="3、安装Python版本"></a>3、安装Python版本</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyenv install <span class="number">3.8</span>.<span class="number">5</span></span><br></pre></td></tr></table></figure><h3 id="4、设置默认版本（以后切换也用这个）"><a href="#4、设置默认版本（以后切换也用这个）" class="headerlink" title="4、设置默认版本（以后切换也用这个）"></a>4、设置默认版本（以后切换也用这个）</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyenv global <span class="number">3.8</span>.<span class="number">5</span></span><br></pre></td></tr></table></figure><h3 id="5、检查Python版本"><a href="#5、检查Python版本" class="headerlink" title="5、检查Python版本"></a>5、检查Python版本</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python <span class="literal">-V</span></span><br></pre></td></tr></table></figure><p><img src="/2020/12/14/MacOS%E5%AE%89%E8%A3%85python3%E5%B9%B6%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4/image-20201214171822380.png" alt="image-20201214171822380"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MacOS-安装Python3-8并设置为默认版本&quot;&gt;&lt;a href=&quot;#MacOS-安装Python3-8并设置为默认版本&quot; class=&quot;headerlink&quot; title=&quot;MacOS 安装Python3.8并设置为默认版本&quot;&gt;&lt;/a&gt;MacOS 安装Pyt</summary>
      
    
    
    
    
    <category term="python" scheme="https://panlianghnu.github.io/tags/python/"/>
    
    <category term="MacOS" scheme="https://panlianghnu.github.io/tags/MacOS/"/>
    
  </entry>
  
  <entry>
    <title>Coder - 语言快速上手</title>
    <link href="https://panlianghnu.github.io/2020/12/14/Coder-%E8%AF%AD%E8%A8%80%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"/>
    <id>https://panlianghnu.github.io/2020/12/14/Coder-%E8%AF%AD%E8%A8%80%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/</id>
    <published>2020-12-14T03:29:44.000Z</published>
    <updated>2021-03-14T15:00:45.666Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Coder-语言快速上手"><a href="#Coder-语言快速上手" class="headerlink" title="Coder - 语言快速上手"></a>Coder - 语言快速上手</h1><p>图灵完备：</p><p>有的语言不是图灵完备的：比如 windows 的 bat 批处理语言、Linux 的 shell、html。只能处理一些自动化的东西</p><p>图灵完备的语言：</p><ul><li>能控制数据、有输入输出、有逻辑处理等。所有图灵机能做的事情、都能用这个语言实现。图灵完备的语言可以互相替代，但是不一样的语言有不一样的优势</li></ul><p>快速学习一门语言：</p><ul><li><p>先了解这个语言的来历、原因、特点、开发环境</p></li><li><p>程序逻辑：变量定义、程序员的约定（驼峰等）、顺序语句、循环分支（看懂其他、自己会写一种就行）、try catch</p></li><li><p>变量加深理解</p><ul><li>强类型弱类型<ul><li>c弱类型（比如打印时需要指定%d、正确使用类型靠程序员自己）</li><li>python强类型（通过 var a = ‘a’，编程语言就知道它是一个字符）</li></ul></li><li>动态类型<ul><li>（声明变量时不用指定类型）比如python、go、swift</li></ul></li><li>静态类型<ul><li>（声明变量时需要指定类型）</li></ul></li><li>值类型 （基本类型）<ul><li>在栈里面直接定义变量（C/C++几乎全是值类型）</li></ul></li><li>引用类型 （封装类型）<ul><li>有的语言所有的变量都是引用（python和js几乎都是引用类型）</li></ul></li><li><strong>值类型和引用类型（影响 == ），但是有的引用类型语言处理了==</strong></li><li>时间和日期（如何处理、保存、计算、格式、方法）</li><li>字符串：<ul><li>理解内存</li><li>可变不可变</li><li>java有字符串常量池（有时候string a == b 是可以的）</li><li>正则表达式（匹配模式）</li></ul></li></ul></li><li><p>容器类型：各种方法、遍历、删除、复制（深浅）、容器序列化（xml、）    可以上项目</p></li><li>编程语言的抽象方法、类（继承封装多态）、接口、函数                                  可以写设计模式</li><li><p>函数式编程的特性</p></li><li><p>熟练度、生态、包管理工具（pip等）</p></li><li><p>语言的高级功能：比如 java 的高性能并发、网络支持、磁盘管理、携程等       professional</p></li></ul><h1 id="训练任务："><a href="#训练任务：" class="headerlink" title="训练任务："></a>训练任务：</h1><p>完成一个支持消息循环的交互程序：</p><ul><li>运行后不结束</li><li>标准输入输出</li><li>单线程就行</li><li>不需要UI</li><li>文字版RPG小游戏、需要6步以上的剧情</li></ul><p>第二个编程语言：</p><ul><li>精细控制</li><li>对二进制位进行操作</li><li>凯撒密码对数据加密<ul><li>输入加密的移位</li><li>输入加密字符串</li><li>生成加密的字符串（支持重定向）</li><li>还能解密</li></ul></li><li>做一个解密程序（破解凯撒密码、不知道加密的移位）。需要自己判断正确的字符串</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Coder-语言快速上手&quot;&gt;&lt;a href=&quot;#Coder-语言快速上手&quot; class=&quot;headerlink&quot; title=&quot;Coder - 语言快速上手&quot;&gt;&lt;/a&gt;Coder - 语言快速上手&lt;/h1&gt;&lt;p&gt;图灵完备：&lt;/p&gt;
&lt;p&gt;有的语言不是图灵完备的：比</summary>
      
    
    
    
    
    <category term="Language" scheme="https://panlianghnu.github.io/tags/Language/"/>
    
  </entry>
  
  <entry>
    <title>Git 学习笔记</title>
    <link href="https://panlianghnu.github.io/2020/12/13/Git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://panlianghnu.github.io/2020/12/13/Git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-12-13T12:58:37.000Z</published>
    <updated>2021-03-14T15:00:37.661Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git-学习"><a href="#Git-学习" class="headerlink" title="Git 学习"></a>Git 学习</h1><p>以往的 version control 是记录补丁（RCS），记录新文件和上一个文件的变化（比如新增了一行aaa、删除了一行bbbb），从而保证版本控制，可以回退，但是这样的 version control 只能管理文本，不能管理多媒体等其他文件</p><p>Git 不一样，每一次提交的文件，都是保存完整的文件，Git 版本库拥有每个版本文件的快照（SNAP），切换速度非常快，除了管理代码外，还可以管理多媒体等文件</p><p><strong>集中化的版本控制</strong></p><ul><li><p>让不同系统上的开发者协同工作</p></li><li><p>有一个单一的集中管理的服务器，保存所有文件的修订版本，大家从这台服务器拉取文件，或者提交更新</p></li><li><p>好处：</p></li></ul><ul><li>大家都能在一定程度上看到别人在做什么</li><li>管理一个CVCS比每个客户端都维护一个本地数据库来得容易</li></ul><ul><li>坏处：</li></ul><ul><li>单点故障</li></ul><p><strong>分布式版本控制</strong></p><ul><li>客户端不止提取最新版本的文件快照，而是把代码仓库完整地镜像下来，包括完整的历史记录</li><li>每一次的克隆，其实都是对代码仓库的完整备份</li><li>避免了单点故障，也不需要维护一个中央服务器</li><li>可以在同一项目中和不同的工作小组的人协作</li></ul><p>Git 是一个分布式的版本管理系统</p><h3 id="Git-特点"><a href="#Git-特点" class="headerlink" title="Git 特点"></a>Git 特点</h3><ul><li><strong>直接记录快照</strong>，而非差异比较（每当提交更新或者保存项目状态时，就会对当时的全部文件创建一个快照，并保存这个快照的索引。为了效率，没有修改的文件不会重新存储，而是保留一个链接指向之前存储的文件）</li><li>近乎所有操作都是<strong>本地执行</strong>（快！）没有网络延迟</li><li><strong>保证完整性</strong>，类似区块链，所有数据保存时都计算哈希，并且以哈希来引用！（SHA-1）</li><li><strong>几乎只有添加数据</strong>，（删除其实也是提交一个快照，所以我之前的阿里云密钥现在还在给我发段信！！！）</li><li>三种状态：committed、modified、staged<ul><li>committed：表示数据已经保存在本地数据库中</li><li>modified：表示数据已经修改、但还没有保存到数据库中</li><li>staged：表示对一个已修改的文件的当前版本作了标记，使之包含在下次提交的快照中（类似暂存吧）</li></ul></li><li>三个阶段：工作区、暂存区、Git 目录<ul><li>工作区是项目的某个版本的内容，提取出来放在磁盘上供你修改</li><li>暂存区是一个文件，保存下次将要提交的文件列表信息，一般在.git里面</li><li>Git 仓库目录：.git 文件夹，保存Git 的元数据和对象数据库，克隆就是克隆这个</li><li><img src="/2020/12/13/Git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA0NjQ0Nw==,size_16,color_FFFFFF,t_70-20201213205846326.png" alt="在这里插入图片描述"></li></ul></li></ul><h3 id="Git-基本工作流程"><a href="#Git-基本工作流程" class="headerlink" title="Git 基本工作流程"></a>Git 基本工作流程</h3><p>1、在工作区中修改文件</p><p>2、将想下次提交的更改选择性地暂存（别把配置文件提交！！！）</p><p>3、提交更新，将快照永久性地存储到 Git 目录</p><h3 id="建立Git-仓库"><a href="#建立Git-仓库" class="headerlink" title="建立Git 仓库"></a>建立Git 仓库</h3><ul><li>git init</li><li>git clone ( git clone 会复制所有的版本，然后将最新版本的文件放在工作区)</li></ul><h3 id="Git-add"><a href="#Git-add" class="headerlink" title="Git add"></a>Git add</h3><p>没有被 add 的文件，Git 会忽略它</p><p>所有被 Git add 的文件都会有副本</p><p>git add 是一个多功能命令</p><ul><li>没有被追踪的文件，使用 git add 会让 git 将这个文件加入管理范畴</li><li>已经追踪的文件，使用 git add 会将该文件放到暂存区</li><li>合并时，使用 git add 可以把有冲突的文件标记为已解决</li></ul><p><strong>可以理解为将内容添加到下一次提交中</strong></p><p>当你修改了文件并且 git add 后，保存在暂存区，之后又修改了这个文件</p><p>再次查看 git status</p><p><img src="/2020/12/13/Git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA0NjQ0Nw==,size_16,color_FFFFFF,t_70-20201213205846214.png" alt="在这里插入图片描述"></p><p>可以看到这个文件同时出现在 to be committed 和 not staged</p><p>所以，git add 并不是添加这个文件，而是添加的 SNAP （当时的文件）</p><p>git add 之后的修改并没有添加到暂存区</p><h3 id="Git-ignore"><a href="#Git-ignore" class="headerlink" title="Git ignore"></a>Git ignore</h3><p>我们想要忽略一些编译文件、日志文件等，又不想让他总提示我没追踪，就要git忽略它</p><p>编写一个文件 .gitignore</p><p>文件 .gitignore 的格式规范如下：<br>所有空行或者以 # 开头的行都会被 Git 忽略。<br>可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中。<br>匹配模式可以以（/）开头防止递归。<br>匹配模式可以以（/）结尾指定目录。<br>要忽略指定模式以外的文件或目录，可以在模式前加上叹号（!）取反。</p><p>所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。</p><p>星号（*）匹配零个或多个任意字符；[abc] 匹配任何一个列在方括号中的字符 （这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）；</p><p>问号（?）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符， 表示所有在这两个字符范围内的都可以匹配（比如 [0-9] 表示匹配所有 0 到 9 的数字）。</p><p>使用两个星号（<strong>）表示匹配任意中间目录，比如 a/</strong>/z 可以匹配 a/z 、 a/b/z 或 a/b/c/z 等。</p><p>一个仓库可能只根目录下有一个 .gitignore 文件。 然而，子目录下也可以有额外的 .gitignore 文件。子目录中的 .gitignore 文件中的规则只作用于它所在的目录中。</p><h3 id="Git-diff"><a href="#Git-diff" class="headerlink" title="Git diff"></a>Git diff</h3><p>git status 只能看到文件当前的状态</p><p>使用 git diff 查看：</p><ul><li>当前做的哪些更新尚未暂存？</li><li>有哪些更新已暂存并准备好下次提交？</li></ul><p><strong>只是使用文件补丁的格式给你展示，并不是底层使用文件补丁实现</strong></p><p>git diff 不加参数，比较的是工作目录中<strong>当前文件</strong>和<strong>暂存区快照</strong>的差异</p><p>git diff —staged ，比较的是<strong>暂存区快照</strong>和<strong>最后一次提交的文件</strong>的差异</p><p>经常 git add 之后 git diff 没有信息就是这个原因</p><h3 id="Git-commit"><a href="#Git-commit" class="headerlink" title="Git commit"></a>Git commit</h3><p>只会提交已经 add 的文件作为快照</p><p><strong>git commit -a</strong> ：将所有已经跟踪的文件一并提交（跳过 add 过程）</p><p> 这很方便，但是很有可能会提交一些你不想提交的文件（比如说配置文件）</p><p>git commit —amend : 上次提交漏掉了几个文件（马上git add）、或者提交信息写错了，用这个命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;asd&quot;</span><br><span class="line">git add forgotten_file</span><br><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><p> 最终只会有一个提交</p><h3 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h3><p>从 Git 中移除某个文件，就需要将它移出跟踪文件清单（也是从暂存区移出）</p><p>git rm ： 连带着在工作区也删除了（因为工作区只是 .git 的一个版本快照）</p><p>如果只是在工作目录删除文件，那只会作为一次操作记录，会出现 Changes not staged for commit</p><p>如果要删除之前修改过、已经放到暂存区的文件，需要使用 git rm -f ， 这样的数据不能被 Git 恢复</p><p>删除 git 暂存区的文件 而保留在磁盘： git rm —cached README</p><h3 id="移动文件-（不重要）"><a href="#移动文件-（不重要）" class="headerlink" title="移动文件 （不重要）"></a>移动文件 （不重要）</h3><p>git mv file_from file_to</p><p>git mv 相当于下面三个命令：</p><ul><li>mv file1 file2</li><li>git rm file1</li><li>git add file2</li></ul><h3 id="查看提交历史（重要）"><a href="#查看提交历史（重要）" class="headerlink" title="查看提交历史（重要）"></a>查看提交历史（重要）</h3><p>git log ：</p><ul><li>-n 显示最近 n 次提交</li><li>-p 按照补丁格式显示统计信息</li><li>–stat 显示简略统计信息</li><li>–pretty(很有用)，比如 git log —pretty=oneline ， 将信息展示为一行</li><li><img src="/2020/12/13/Git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA0NjQ0Nw==,size_16,color_FFFFFF,t_70-20201213205847355.png" alt="在这里插入图片描述"></li><li>–pretty=format 还有很多种参数</li></ul><h3 id="撤销操作（重要）"><a href="#撤销操作（重要）" class="headerlink" title="撤销操作（重要）"></a>撤销操作（重要）</h3><p>一、取消暂存的文件：</p><p> 不同的版本不一样，git status 会提示你，怎么取消暂存，我这边是 git restore —staged</p><p> <img src="/2020/12/13/Git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20201210225545985.png" alt="在这里插入图片描述"></p><p>二、撤销对文件对修改：</p><p> 不同的版本不一样，git status 会提示你，怎么取消修改，我这边是 git restore file</p><p> <img src="/2020/12/13/Git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20201210225553980.png" alt="在这里插入图片描述"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">“这是一个危险的命令。 你对那个文件在本地的任何修改都会消失</span><br><span class="line">Git 会用最近提交的版本覆盖掉它。 除非你确实清楚不想要对那个文件的本地修改了，否则请不要使用这个命令。”</span><br></pre></td></tr></table></figure><p>Git 中任何 已提交 的东西几乎总是可以恢复</p><h3 id="远程仓库使用（重要）"><a href="#远程仓库使用（重要）" class="headerlink" title="远程仓库使用（重要）"></a>远程仓库使用（重要）</h3><p>并不一定是 github 或者 gittee 才是远程仓库，任何不在本地的 git 仓库都是远程仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote    &#x2F;&#x2F; 查看已经配置的远程仓库</span><br><span class="line">git remote -v  &#x2F;&#x2F; 查看简写以及URL，会全部列出</span><br></pre></td></tr></table></figure><p><strong>查看远程仓库</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote show &lt;remote&gt; (常用)</span><br></pre></td></tr></table></figure><p><img src="/2020/12/13/Git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20201210225605488.png" alt="在这里插入图片描述"></p><p>可以看到远程有两个分支、一个main一个master</p><p><strong>添加远程仓库</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add  &quot;shortname&quot;  &quot;url&quot;</span><br></pre></td></tr></table></figure><h3 id="fetch-和-pull（重要）"><a href="#fetch-和-pull（重要）" class="headerlink" title="fetch 和 pull（重要）"></a>fetch 和 pull（重要）</h3><p>git fetch remote</p><p>会访问远程仓库，拉取所有你还没有的数据。拉取完后，会拥有所有分支的引用</p><p>如果 clone 了一个仓库，会自动添加远程仓库，默认为 origin</p><p>git fetch origin 会抓上一次抓取后新的推送的所有工作</p><p><strong>fetch 只会将数据下载到本地仓库，而不会自动合并</strong></p><p><strong>pull 在抓取数据后会尝试直接合并分支</strong> ，git pull 会从最初克隆的服务器上抓取数据并自动尝试合并</p><p>git pull 相当于三条命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git pull&#x2F;fetch &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;  (常用)</span><br><span class="line">git fetch origin master:tmp   &#x2F;&#x2F; 从远程拉一个分支到tmp分支</span><br><span class="line">git merge tmp                 &#x2F;&#x2F; 尝试合并当前分支和tmp分支</span><br><span class="line">git branch -d tmp             &#x2F;&#x2F; 删除tmp分支</span><br></pre></td></tr></table></figure><p>pull 自带的merge 不是很好用（有时候会发生错误），建议还是 git fetch origin master:tmp</p><h3 id="push"><a href="#push" class="headerlink" title="push"></a>push</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br></pre></td></tr></table></figure><p>如果省略远程分支名，则表示将本地分支推送与之存在”追踪关系”的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p><strong>push 前一定要先抓取、消除冲突，再 push。开始工作前也 fetch 一下，在最新的版本上开发</strong></p><h3 id="git-tag"><a href="#git-tag" class="headerlink" title="git tag"></a>git tag</h3><p>git tag 命令查看所有标签 也可以 git tag -l “v1.8*” 列出所有版本号为1.8开头的版本</p><p>git 有两种标签：</p><ul><li>轻量标签：只是某个特定 commit 的引用<ul><li>git tag v1.4</li></ul></li><li>附注标签：是Git 数据库中的一个完整对象，是可以被校验的，包含打标签的人的名字、邮箱、日期、还可以签名验证 、 创建附注标签很简单<ul><li>git tag -a v1.4 -m ”my version 1.4“</li></ul></li></ul><p><strong>标签要另外push才会到远程</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin v1.1</span><br></pre></td></tr></table></figure><p>注意⚠️：tag 是和某个 commit 直接绑定的，而非 branch</p><p>所以你切换分支了，还是可以看到这个 tag（ git show v1.2 )</p><p>所以你推到远程去， 不需要指定分支 而是直接 push origin v1.2</p><h3 id="版本回滚（重要）"><a href="#版本回滚（重要）" class="headerlink" title="版本回滚（重要）"></a>版本回滚（重要）</h3><p>首先通过 git log 或者 git tag 查看 xxx</p><p>git reset —hard xxx ( xxx为某个 commit 的hash 或者某个 tag )</p><p>回滚后看不到 git log 了怎么办？( tag还是能看见 ) git reflog</p><h3 id="git-分支（重要）"><a href="#git-分支（重要）" class="headerlink" title="git 分支（重要）"></a>git 分支（重要）</h3><p>将每个commit 理解为链表的节点、就很容易理解分支了</p><p>HEAD 指针，指向当前所在的本地分支，HEAD指向master，你就在master分支上</p><p>其实所有的 HEAD、master、dev、都是一个指向commit 的指针，只是不同的分支向不同的方向延续</p><p>git switch 切换分支、会改变你的工作目录</p><p><img src="/2020/12/13/Git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA0NjQ0Nw==,size_16,color_FFFFFF,t_70-20201213205847160.png" alt="在这里插入图片描述"></p><p>这种情况如果修改了同一个文件，merge会冲突，这个时候需要手动解决冲突，再 add 、 commit</p><p>git branch 查看（新建）分支（基本命令）</p><p>git branch -d 删除分支</p><p>稳定分支的指针总是在提交历史中落后一大截，而前沿分支的指针往往比较靠前。</p><p><img src="/2020/12/13/Git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20201210225623821.png" alt="在这里插入图片描述"></p><p><strong>删除远程分支</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push origin --delete serverfix</span><br><span class="line">To https:&#x2F;&#x2F;github.com&#x2F;schacon&#x2F;simplegit</span><br></pre></td></tr></table></figure><h3 id="变基"><a href="#变基" class="headerlink" title="变基"></a>变基</h3><p>整合分支最容易的就是 merge 命令，会将两个分支的最新快照、以及二者的最近共同祖先，三者合并，生成新的 commit</p><p>还有一种合并的方法：</p><p>变基： git switch c4 \ git rebase c5 将 C4 的修改 按顺序应用到 C5</p><p><img src="/2020/12/13/Git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA0NjQ0Nw==,size_16,color_FFFFFF,t_70-20201213205848106.png" alt="在这里插入图片描述"></p><p>提取C4的补丁和修改、在C3的基础上再应用一次</p><p>结果都是一样，但是变基使得提交历史更加整洁</p><p><strong>变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起</strong></p><p>变基的风险：</p><p><strong>如果提交存在于你的仓库之外，而别人可能基于这些提交进行开发，那么不要执行变基</strong></p><h3 id="大厂实际工作中-Git-流程"><a href="#大厂实际工作中-Git-流程" class="headerlink" title="大厂实际工作中 Git 流程"></a>大厂实际工作中 Git 流程</h3><h4 id="master-永远是正常稳定可用的主干分支"><a href="#master-永远是正常稳定可用的主干分支" class="headerlink" title="master 永远是正常稳定可用的主干分支"></a>master 永远是正常稳定可用的主干分支</h4><p>拉出一个 dev 分支，check out from master （master镜像）、类似防火墙</p><p>dev 是所有开发小组的一个共用分支</p><p>但是如果开发人员都向dev 提交，会频繁发生冲突</p><p>所以开发人员各再拉分支</p><p>开发人员要提交到dev之前，小组内先合一下</p><p>测试人员一般从 dev 拉代码测试、没问题了之后，运维把 dev 合并到 master</p><p>从 master 拉一些 Tag 、 Release 发布小更新 、 feature（加一些新的东西、不想影响原来的东西）</p><p>git 5、6成的时间都在解决冲突</p><p>大厂还有专门的 CMO ：配置管理员：解决各种冲突</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Git-学习&quot;&gt;&lt;a href=&quot;#Git-学习&quot; class=&quot;headerlink&quot; title=&quot;Git 学习&quot;&gt;&lt;/a&gt;Git 学习&lt;/h1&gt;&lt;p&gt;以往的 version control 是记录补丁（RCS），记录新文件和上一个文件的变化（比如新增了一行a</summary>
      
    
    
    
    
    <category term="git" scheme="https://panlianghnu.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>操作系统原理与程序逻辑训练</title>
    <link href="https://panlianghnu.github.io/2020/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E7%A8%8B%E5%BA%8F%E9%80%BB%E8%BE%91%E8%AE%AD%E7%BB%83/"/>
    <id>https://panlianghnu.github.io/2020/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E7%A8%8B%E5%BA%8F%E9%80%BB%E8%BE%91%E8%AE%AD%E7%BB%83/</id>
    <published>2020-12-13T12:57:34.000Z</published>
    <updated>2021-03-14T14:59:51.483Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C语言和操作系统的交互"><a href="#C语言和操作系统的交互" class="headerlink" title="C语言和操作系统的交互"></a>C语言和操作系统的交互</h2><p>C语言的main函数其实就是和操作系统的交互之一，执行程序前，操作系统将程序的二进制可执行代码加载到内存的代码段，同时会把函数名为main的函数作为程序的入口</p><p>Linux 的终端里：</p><p>命令1 &amp;&amp; 命令2</p><p>表示先执行命令1，成功了再执行命令2，如果命令1执行错误则不会执行命令2</p><p><strong>小技巧：可以用 echo $? 查看上一个命令执行的返回值</strong></p><p>而C语言的 int main() 需要有一个int 类型的返回值，这也涉及到和Linux 操作系统的交互</p><p>return 0 不是乱写，而是代表执行成功，程序正常退出，操作系统可以获得main 函数的返回值，通过 echo $? 打印到终端，通过main 函数的返回值，操作系统可以执行不同的逻辑</p><p>C语言的int main(int argv,char * argc[]) ，参数从终端读参数， argv代表参数个数，argc代表参数列表</p><p>这些是操作系统和C语言的交互</p><p>经典程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv [])</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;argc;i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;argc[%d] is %s\n&quot;</span>,i,argv[i]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E7%A8%8B%E5%BA%8F%E9%80%BB%E8%BE%91%E8%AE%AD%E7%BB%83/20201209094206212.png" alt="C语言命令后参数"><br>这个程序可以很直观的看到Linux 在调用C语言程序时，传入的各个参数</p><h2 id="Linux-标准输入输出流、错误流"><a href="#Linux-标准输入输出流、错误流" class="headerlink" title="Linux 标准输入输出流、错误流"></a>Linux 标准输入输出流、错误流</h2><p>stdin stdout stderr</p><p>stdin : 默认是键盘输入，可以通过流的重定向改变输入流</p><p>stdout：默认是显示器输出，也可以重定向到网卡、打印机等</p><p>stderr：错误流</p><p>echo $? 命令可以打印出当前程序的返回值</p><p>流在Linux 系统里被抽象成一个个文件，比如我要往打印机写东西，我就会打开“打印机”这个文件，往里面写东西</p><p>每启动一个包含<stdio.h>的程序，Linux会默认打开 stdin\ stdout\ stderr这三个文件</stdio.h></p><p>比如 :</p><p>printf(“hello”) = fprintf(stdout,“hello”)</p><p>scanf(“%d”,&amp;a) = fscanf(stdin,”%d”,&amp;a)</p><p>fprintf(stderr, “the value must &gt; 0”)</p><p>输出到 stderr 默认也是显示器，我以前在DevC++里输出到stderr， 是输出红色字体，ubuntu的终端好像没有对这个stderr进行特殊标记，只能通过重定向或者 echo $? 来知道确实是发生了错误</p><h2 id="Linux-流的重定向"><a href="#Linux-流的重定向" class="headerlink" title="Linux 流的重定向"></a>Linux 流的重定向</h2><p>0 是标准输入流</p><p>1 是标准输出流</p><p>2 是标准错误流</p><p>./a.out 1&gt;&gt; a.txt 代表对a.out 这个程序的 标准输出流 <strong>重定向</strong> 到 a.txt （1可以默认不写）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E7%A8%8B%E5%BA%8F%E9%80%BB%E8%BE%91%E8%AE%AD%E7%BB%83/20201209094636928.png" alt="hello world 输出流重定向"></p><p><img src="/2020/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E7%A8%8B%E5%BA%8F%E9%80%BB%E8%BE%91%E8%AE%AD%E7%BB%83/20201209094657899.png" alt="ls -l 输出流重定向"><br>可以看到 ls -l 的信息被输出到了文件 b.txt</p><p>其实双箭头和单箭头都可以作为流的重定向，他们有小小的区别</p><p>双箭头不会覆盖文件，会在文件末尾写值</p><p>单箭头则会覆盖文件 ./a.out &gt; a.txt</p><p>&lt; 是标准输入流的重定向<br><img src="/2020/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E7%A8%8B%E5%BA%8F%E9%80%BB%E8%BE%91%E8%AE%AD%E7%BB%83/20201209094812322.png" alt="流的重定向"><br>这三个重定向是可以组合使用的</p><h2 id="Linux-管道"><a href="#Linux-管道" class="headerlink" title="Linux 管道"></a>Linux 管道</h2><p>| 表示管道</p><p>比如： ls /etc/ | grep ab</p><p>表示，将 ls 产生的标准输出流，通过管道，传递给 grep（文本搜索的小程序）的标准输入流</p><p>看看实际操作：<br><img src="/2020/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E7%A8%8B%E5%BA%8F%E9%80%BB%E8%BE%91%E8%AE%AD%E7%BB%83/20201209094843144.png" alt="管道"></p><p>这就是grep 搜索 ls 的结果，找出结果里包含ab的行，输出到标准输出流</p><p><img src="/2020/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E7%A8%8B%E5%BA%8F%E9%80%BB%E8%BE%91%E8%AE%AD%E7%BB%83/20201209094914129.png" alt="找出包含ssh的进程"><br>这就是grep 搜索 ps 的结果，找出结果里包含ssh的进程，输出到标准输出流</p><h5 id="Linux-管道实战"><a href="#Linux-管道实战" class="headerlink" title="Linux 管道实战"></a>Linux 管道实战</h5><p>两个程序，一个输出sum和count，一个通过sum和count求平均值<br><img src="/2020/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E7%A8%8B%E5%BA%8F%E9%80%BB%E8%BE%91%E8%AE%AD%E7%BB%83/20201209100415817.png" alt="Linux管道实战"><br>这两个程序可以直接通过管道相连，让第一个程序的输出进入下一个程序的标准输入<br><img src="/2020/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E7%A8%8B%E5%BA%8F%E9%80%BB%E8%BE%91%E8%AE%AD%E7%BB%83/20201209100432148.png" alt="Linux 管道实战"><br>这次直接输出来的是平均数</p><p>很简单的将两个独立小工具变成更加复杂的工具使用</p><h2 id="Make-学习"><a href="#Make-学习" class="headerlink" title="Make 学习"></a>Make 学习</h2><p>在代码目录下 编写Makefile 文件</p><p># 代表注释</p><p>hello.out: max.o hello.c #这行代表hello.out 需要max.o 和 hello.c 两个文件</p><p> gcc max.o hello.c -o hello.out # 这行必须以table开头，表示实际的gcc命令</p><p>max.o: max.c</p><p> gcc -c max.c<br><img src="/2020/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E7%A8%8B%E5%BA%8F%E9%80%BB%E8%BE%91%E8%AE%AD%E7%BB%83/20201209100743504.png" alt="Make"><br>可以看到我的Makefile 里定义了main.out 和 compute.o 的编译方式，为了调试方便我加了 -g</p><p>现在make 试一下</p><p><img src="/2020/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E7%A8%8B%E5%BA%8F%E9%80%BB%E8%BE%91%E8%AE%AD%E7%BB%83/20201209101228554.png" alt="make"><br>可以看到运行make 后，生成了 main.out compute.o</p><p>运行也是没有问题的<br><img src="/2020/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E7%A8%8B%E5%BA%8F%E9%80%BB%E8%BE%91%E8%AE%AD%E7%BB%83/20201209101343486.png" alt="在这里插入图片描述"></p><h5 id="为什么使用make？"><a href="#为什么使用make？" class="headerlink" title="为什么使用make？"></a>为什么使用make？</h5><p>使用make ，可以让大型程序在小部分代码改动时，不至于全部重新编写</p><p>make 会在Makefile文件中查询需要的文件是否已经有了，如果某部分文件已经存在则会跳过</p><p>make可以大大的节省编译时间（已经编译了不需要重新编译的文件 make 会帮我们跳过），并且Makefile写好各文件的依赖规则，每次编译都能方便程序员直接调用（大型项目自己写gcc不可想象）</p><h2 id="GDB-调试"><a href="#GDB-调试" class="headerlink" title="GDB 调试"></a>GDB 调试</h2><p>先编译时加 -g 参数</p><p>执行 gdb ./main.out</p><p>b 12 标记断点</p><p>l 输出源代码</p><p>n 下一步</p><p>s 单步进入</p><p>p 打印参数数据、地址、函数等</p><p>bt 打印堆栈</p><p>f 进入栈帧</p><h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><p>指向函数的指针变量。 因此“函数指针”本身首先应是指针变量，只不过该指针变量指向函数。这正如用指针变量可指向整型变量、字符型、数组一样，这里是指向函数。C在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。有了指向函数的指针变量后，可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样。</p><p><strong>函数指针有两个用途：调用函数和做函数的参数</strong></p><p>&amp;a 是 得到a的地址</p><p>p 打印一个</p><p>x/3d 打印三个整数</p><p>x/3cb 打印三个字符，b是一个个打印</p><p>回调函数： 在调用一个函数（A函数）时，传入一个函数指针（B函数）作为参数，在A函数运行期间，调用了B函数，那么这就是一个回调。回调函数可以帮助我们实现很多功能</p><p>比如 C语言标准库就为我们实现了快速排序，但是标准库的快速排序它并不知道你要排序的数据是整数、还是字符，甚至是自己定义的结构体，如果是基本类型还好说，但如果是你要对自己定义的结构体排序的话，它并不知道你的结构体是如何进行排序的，这个时候你需要把排序的定义告诉它，即你需要实现一个比较大小的函数，将这个函数作为参数传递给这个标准库函数。这时就可以调用快速排序为你的结构体排序了。</p><p>可以看到有了回调，我们就不需要关心快速排序实现的细节，只需要将我们定义的比较函数传给排序函数，就可以帮助我们实现快速排序。</p><h3 id="操作系统内存管理"><a href="#操作系统内存管理" class="headerlink" title="操作系统内存管理"></a>操作系统内存管理</h3><p><img src="/2020/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E7%A8%8B%E5%BA%8F%E9%80%BB%E8%BE%91%E8%AE%AD%E7%BB%83/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA0NjQ0Nw==,size_16,color_FFFFFF,t_70-20201213205748706.png" alt="操作系统内存管理"></p><p>如图所示：操作系统内核使用的是高地址段，代码段是最低的地址段</p><p>系统内核是不允许被其他进程修改的</p><p>代码段用于保存运行的各个程序的二进制代码</p><p>代码段上面是数据段，用来存储一些全局变量、常量、字符串等</p><p><strong>堆</strong></p><p>数据段上面是堆内存空间，是程序动态申请的内存空间，堆内存比较大，所以程序如果要申请一个大数组什么的，需要调用malloc来申请一片堆内存，堆内存是需要自己去释放的（C语言），Java、go等语言有垃圾回收，不需要程序员来手动回收</p><p><strong>栈</strong></p><p>栈内存用于维护程序运行时环境，每调用一个函数，即会开辟一个新的栈帧（所以在递归调用时，如果递归深度太高会产生巨大的空间复杂度，甚至会出现段错误，核心转储</p><p>每个栈帧都有两个寄存器，一个栈指针寄存器（ESP寄存器，指向栈顶），一个栈的基地址（EBP，指向栈的底部），当然栈是往下长的，EBP的地址会大一些</p><p>每次调用函数即会在栈帧底部保存一个返回值（EBP的值），然后向下新开辟一个栈帧（让EBP往下指，ESP=EBP - 栈大小），(push ebp) (mov ebp, esp)</p><p>然后栈内存记录函数里新定义的各个变量</p><p>函数执行完，返回的时候，mov esp,ebp， 让esp = ebp，再pop ebp，栈顶弹出之前保存的返回值给ebp，这样就回到了上一个栈帧，返回值一般是eax寄存器传递</p><p><strong>程序调用时内存变化</strong></p><p>当操作系统调用执行一个程序时</p><p>将二进制代码（text）放入代码段</p><p>将二进制程序的常量、字符串、全局变量等 放入数据段</p><p>根据代码段，新开辟栈帧用于维护运行时环境，然后cpu根据PC寄存器取指令，执行指令</p><p>终端执行一个 ./main.out 时，函数的调用流程：</p><p>用户在终端敲击回车时，会触发CPU的中断，CPU会保存当前程序的各种寄存器的值，保存栈帧的信息等，放入进程结构体中（内存），操作系统陷入内核态，根据中断向量表和中断编号，找到对应的中断处理函数，发现现在要调用一个程序，于是操作系统将程序二进制可执行代码载入内存的代码段，常量、字符串等载入内存的数据段，为该程序申请时间片，把程序的状态修改为就绪状态，当程序执行时，新开辟（或者从进程结构体中读取之前的）栈帧，执行代码段段二进制代码</p><h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><p>昨天写了一些简单程序设计，打印正方形、空心正方形、等腰三角形、空心菱形、“回”字等</p><p>很久没写过这种程序了。。。刚开始写正方形、三角形都还好，基本上写一遍就过了，不会一直调试，反复测试才能过。后面到了复杂的菱形、“回”字，就需要大量的调试，不断的设计 i、j 的值。让 i、j、num这三个变量组成一个线性函数，设计一个二维的矩形</p><p>但是龙哥让我们把一些重复劳动抽象出来</p><p>比如写一个 printChar(char ch, int n) ; 打印 n 个字符，这个简单的函数就大大地提升了我们的开发效率，让我们不需要将注意力集中在打印几个字符上，我们只需要关注这个图形的规律，第几行先打印几个空格，再打印几个字符即可</p><p>程序设计确实应该是一个不断抽象的过程，如果main 函数里的每一行代码都设计到最后的结果，那以后再来看这份代码又看不懂了。开发的时候应该逻辑更清晰一些，哪几行代码干了什么事，什么函数负责干什么，main 函数里只负责很宏观的事情，实现细节应该抽象出来</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;C语言和操作系统的交互&quot;&gt;&lt;a href=&quot;#C语言和操作系统的交互&quot; class=&quot;headerlink&quot; title=&quot;C语言和操作系统的交互&quot;&gt;&lt;/a&gt;C语言和操作系统的交互&lt;/h2&gt;&lt;p&gt;C语言的main函数其实就是和操作系统的交互之一，执行程序前，操作系</summary>
      
    
    
    
    
    <category term="linux" scheme="https://panlianghnu.github.io/tags/linux/"/>
    
    <category term="c语言" scheme="https://panlianghnu.github.io/tags/c%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
</feed>
