<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>基于WebSocket的聊天室</title>
      <link href="2021/02/04/%E5%9F%BA%E4%BA%8EWebSocket%E7%9A%84%E8%81%8A%E5%A4%A9%E5%AE%A4/"/>
      <url>2021/02/04/%E5%9F%BA%E4%BA%8EWebSocket%E7%9A%84%E8%81%8A%E5%A4%A9%E5%AE%A4/</url>
      
        <content type="html"><![CDATA[<p>源码见：<a href="https://github.com/panlianghnu/WebSocketChat">github</a></p><h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><h3 id="使用-‘express’-封装-http-请求，监听7777端口，返回前端页面"><a href="#使用-‘express’-封装-http-请求，监听7777端口，返回前端页面" class="headerlink" title="使用 ‘express’ 封装 http 请求，监听7777端口，返回前端页面"></a>使用 ‘express’ 封装 http 请求，监听7777端口，返回前端页面</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)()    <span class="comment">// 封装 http </span></span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>,<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">res.sendFile(__dirname + <span class="string">&#x27;/chat.html&#x27;</span>)   <span class="comment">// 返回页面</span></span><br><span class="line">&#125;)</span><br><span class="line">app.listen(<span class="number">7777</span>,<span class="string">&#x27;localhost&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="使用-nodejs-websocket-工具包处理聊天，监听8888端口"><a href="#使用-nodejs-websocket-工具包处理聊天，监听8888端口" class="headerlink" title="使用 nodejs-websocket 工具包处理聊天，监听8888端口"></a>使用 nodejs-websocket 工具包处理聊天，监听8888端口</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ws = <span class="built_in">require</span>(<span class="string">&#x27;nodejs-websocket&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> server = ws.createServer(<span class="function">(<span class="params">socket</span>) =&gt;</span> &#123;    <span class="comment">// 处理聊天</span></span><br><span class="line"><span class="keyword">var</span> username = socket.path</span><br><span class="line"><span class="built_in">console</span>.log(username + <span class="string">&#x27; 加入群聊&#x27;</span>)</span><br><span class="line">clientList.push(socket)</span><br><span class="line">broadcast(username + <span class="string">&#x27; 加入群聊&#x27;</span>)</span><br><span class="line"></span><br><span class="line">socket.on(<span class="string">&#x27;text&#x27;</span>,<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(username + <span class="string">&#x27;: &#x27;</span>+data)</span><br><span class="line">broadcast(username + <span class="string">&#x27;: &#x27;</span> + data)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">socket.on(<span class="string">&#x27;close&#x27;</span>,<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(username + <span class="string">&#x27; 退出群聊&#x27;</span>)</span><br><span class="line">deleteSocketFromList(socket)</span><br><span class="line">broadcast(username + <span class="string">&#x27; 退出群聊&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;).listen(<span class="number">8888</span>)</span><br></pre></td></tr></table></figure><p>客户端刚连接服务器时，服务器会用链表 clientList 保存这个 socket 连接，并进行广播 “xxx加入群聊”。</p><p>设置了两个事件</p><ul><li>text 事件，客户端向服务器发送消息时触发<ul><li>服务器向所有客户端广播该消息</li></ul></li><li>close 事件，客户端失去连接时触发<ul><li>服务器删除该 socket 对象，并广播给其他客户端</li></ul></li></ul><h3 id="广播的实现"><a href="#广播的实现" class="headerlink" title="广播的实现"></a>广播的实现</h3><p>遍历 socket ，调用 send 发送消息</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">broadcast</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;clientList.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(clientList[i] !== <span class="literal">null</span>)&#123;</span><br><span class="line">clientList[i].send(data)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><h3 id="定义-url-和-ws-对象"><a href="#定义-url-和-ws-对象" class="headerlink" title="定义 url 和 ws 对象"></a>定义 url 和 ws 对象</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">&quot;ws://localhost:8888/&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> ws = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h3 id="加入群聊，即初始化-websocket-对象，并绑定事件"><a href="#加入群聊，即初始化-websocket-对象，并绑定事件" class="headerlink" title="加入群聊，即初始化 websocket 对象，并绑定事件"></a>加入群聊，即初始化 websocket 对象，并绑定事件</h3><p>username 通过用户输入，调用 document.getElementById 得到内容</p><p>直接在连接时的 url 字符串后面拼接 username，后端识别 path 得到用户名</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">joinRoom</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ws) &#123;</span><br><span class="line">    alert(<span class="string">&quot;你已经在聊天室，不能再加入&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> username = <span class="built_in">document</span>.getElementById(<span class="string">&quot;user&quot;</span>).value;</span><br><span class="line">  ws = <span class="keyword">new</span> WebSocket(url + username);</span><br><span class="line">  <span class="comment">//与服务端建立连接触发</span></span><br><span class="line">  ws.onopen = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;与服务器成功建立连接&quot;</span>)</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//服务端推送消息触发</span></span><br><span class="line">  ws.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">ev</span>) </span>&#123;</span><br><span class="line">    talking(ev.data);     <span class="comment">// 接收数据，刷新页面</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//发生错误触发</span></span><br><span class="line">  ws.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;连接错误&quot;</span>)</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//正常关闭触发</span></span><br><span class="line">  ws.onclose = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;连接关闭&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendMsg</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!ws)&#123;</span><br><span class="line">    alert(<span class="string">&quot;你已掉线，请重新加入&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//消息发送</span></span><br><span class="line">  ws.send(<span class="built_in">document</span>.getElementById(<span class="string">&quot;sendMsg&quot;</span>).value);</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&quot;sendMsg&quot;</span>).value = <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先判断是否已经初始化 websocket 对象</p><h3 id="接收数据，刷新页面"><a href="#接收数据，刷新页面" class="headerlink" title="接收数据，刷新页面"></a>接收数据，刷新页面</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">talking</span>(<span class="params">content</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&quot;content&quot;</span>).append(content + <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">content 是一个 &lt;textarea/&gt; 对象</span><br></pre></td></tr></table></figure><h3 id="GUI"><a href="#GUI" class="headerlink" title="GUI"></a>GUI</h3><p><img src= "/img/loading.gif" data-lazy-src="/2021/02/04/%E5%9F%BA%E4%BA%8EWebSocket%E7%9A%84%E8%81%8A%E5%A4%A9%E5%AE%A4/image-20210219103207635.png" alt="image-20210219103207635"></p>]]></content>
      
      
      
        <tags>
            
            <tag> websocket </tag>
            
            <tag> 聊天室 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/01/17/hello-world/"/>
      <url>2021/01/17/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ML学习笔记-1</title>
      <link href="2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/"/>
      <url>2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/</url>
      
        <content type="html"><![CDATA[<h1 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h1><p>机器学习就是让机器自动找函数</p><p><img src= "/img/loading.gif" data-lazy-src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210101104434728.png" alt="image-20210101104434728"></p><p>Regression：输出数值</p><p>Classification：二分类、多类分类</p><p>Generation：生成有复杂结构的东西（如翻译，画二次元头像）</p><h2 id="如何告诉机器，想要什么样的函数"><a href="#如何告诉机器，想要什么样的函数" class="headerlink" title="如何告诉机器，想要什么样的函数"></a>如何告诉机器，想要什么样的函数</h2><p>Supervised learning  有监督学习，对每个 input，给出一个标准 output，需要对资料做 label</p><p>机器就可以对生成的函数做一个评估，有一个 loss function，用来计算 function 的好坏</p><p>Reinforcement learning  强化学习，比如阿尔法狗，让机器和自己、别人下棋，然后赢了，机器会知道这样下比较好，哪几步比较好还不是很清楚</p><blockquote><p>强化学习是智能体（Agent）以“试错”的方式进行学习，通过与环境进行交互获得的奖赏指导行为，目标是使智能体获得最大的奖赏，强化学习不同于连接主义学习中的监督学习，主要表现在强化信号上，强化学习中由环境提供的强化信号是对产生动作的好坏作一种评价(通常为标量信号)，而不是告诉强化学习系统RLS(reinforcement learning system)如何去产生正确的动作。由于外部环境提供的信息很少，RLS必须靠自身的经历进行学习。通过这种方式，RLS在行动-评价的环境中获得知识，改进行动方案以适应环境。</p></blockquote><h2 id="机器如何找到函数"><a href="#机器如何找到函数" class="headerlink" title="机器如何找到函数"></a>机器如何找到函数</h2><h3 id="1、给定函数范围"><a href="#1、给定函数范围" class="headerlink" title="1、给定函数范围"></a>1、给定函数范围</h3><p>linear function </p><p>network architecture  RNN循环神经网络  CNN卷积神经网络</p><h3 id="2、函数寻找方法"><a href="#2、函数寻找方法" class="headerlink" title="2、函数寻找方法"></a>2、函数寻找方法</h3><p>Gradient Descent 梯度下降</p><p><img src= "/img/loading.gif" data-lazy-src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210101111415435.png" alt="image-20210101111415435"></p><p>Anomaly detection 能不能知道 自己不知道</p><p>meta learning   让机器学习如何学习，让机器自己设计学习的方法</p><h2 id="Regression"><a href="#Regression" class="headerlink" title="Regression"></a>Regression</h2><p>输出数值（Scalar）</p><p>比如无人车驾驶：input 一些sensor ，输出方向盘角度</p><p>比如推荐系统：input A和商品B，输出A购买B的可能性</p><p>比如宝可梦：输入某只宝可梦，输出他进化后的CP值</p><p>三个步骤</p><p>1、找到一个model（A set of functions）比如线性model cp_new = b + w*cp_old</p><p><img src= "/img/loading.gif" data-lazy-src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210101162247930.png" alt="image-20210101162247930"></p><p>2、定义 Loss function，输入一个 function，输出一个 function 评估结果</p><p><img src= "/img/loading.gif" data-lazy-src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210101162204542.png" alt="image-20210101162204542"></p><p>这里采用的平方 loss function ，用真实数据减去预测数值再取平方</p><p>3、找一个最好的 function</p><p><img src= "/img/loading.gif" data-lazy-src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210101163034130.png" alt="image-20210101163034130"></p><p>穷举所有的 w 和 b，求出最好的 w 和 b</p><p>Gradient Descent，可以处理任何可以微分的 function</p><p><img src= "/img/loading.gif" data-lazy-src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210101163613411.png" alt="image-20210101163613411"></p><p>随机选取初始 w0，再初始w0这个位置，计算w参数对L的微分（切线斜率），若斜率为负，则右边 loss 较低，应该增加 w0，增加量为：微分值*(learning rate) </p><p>就这样不断地求 w，直到 w 到达 local optimal，但是会陷入局部最优（当然 linear set 没有局部最优）</p><p>如果有两个参数呢？</p><p><img src= "/img/loading.gif" data-lazy-src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210101164005142.png" alt="image-20210101164005142"></p><p><img src= "/img/loading.gif" data-lazy-src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210101164409136.png" alt="image-20210101164409136"></p><p>其实算出来的就是等高线的法线方向</p><p><img src= "/img/loading.gif" data-lazy-src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210101164451537.png" alt="image-20210101164451537"></p><p>这种情况就会陷入局部最优，但 linear regression 没有 local optimal</p><p>求出来 b 和 w 之后，我们关心新数据和预测函数的误差，发现比较大</p><p>重新设计 model</p><p>二次式：y = b + w1<em>Xcp + w2</em>*(Xcp)^2</p><p>一样的用刚才的算法去求最好的 b、w1、w2</p><p>三次式：y = b + w1<em>Xcp + w2\</em>(Xcp)^2 + w3*(Xcp)^3</p><p>四次式：。。。不断地拟合，loss function()的值不断变小，但是 test data 效果却更差，这波啊，这波是过拟合</p><p><img src= "/img/loading.gif" data-lazy-src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210103132844166.png" alt="image-20210103132844166"></p><p>如图，training data 效果特别好，但是显然不是一个合理的宝可梦CP预测的 function</p><p><img src= "/img/loading.gif" data-lazy-src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210103133116007.png" alt="image-20210103133116007"></p><p>越复杂的model、我们可以找到 training data 的loss function 最低的 function，但是在testing data 的结果是不一样的</p><p><img src= "/img/loading.gif" data-lazy-src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210103133206717.png" alt="image-20210103133206717"></p><p>testing 的结果反而变差了，拟合的并不是很好（Overfitting）</p><h3 id="overfitting"><a href="#overfitting" class="headerlink" title="overfitting"></a>overfitting</h3><p><img src= "/img/loading.gif" data-lazy-src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210103143405103.png" alt="image-20210103143405103"></p><p>model 并不是越复杂越好</p><p>当收集足够多的数据之后，发现并不是简单的和旧CP值有关</p><p><img src= "/img/loading.gif" data-lazy-src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210103133652548.png" alt="image-20210103133652548"></p><p>物种是有关键性影响的，重新设计 model ，将 物种（species）考虑进去</p><p><img src= "/img/loading.gif" data-lazy-src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210103133802784.png" alt="image-20210103133802784"></p><p><img src= "/img/loading.gif" data-lazy-src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210103133924202.png" alt="image-20210103133924202"></p><p>这也是一个线性拟合…为啥不分四个训练集呢。。感觉就像是把 Xcp这个 feature 分成四个 feature了，分别表示对四个种类的 cp 值</p><p>来个更复杂的 model</p><p><img src= "/img/loading.gif" data-lazy-src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210103134601138.png" alt="image-20210103134601138"></p><p>对 eevee 考虑的更加复杂一些，其实也不是很复杂，作业可能几百个参数。。。</p><p>然后算出来 loss 为1.4，testing data loss 102.3，显然 overfitting 了</p><h3 id="如何避免-overfitting"><a href="#如何避免-overfitting" class="headerlink" title="如何避免 overfitting"></a>如何避免 overfitting</h3><p>回到 regularization ，redesigned loss function </p><p>loss function 不应该只考虑误差平方和，还应该加上 wi (wi 为各级x的系数) 的平方和，为什么？</p><p><img src= "/img/loading.gif" data-lazy-src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210103145609976.png" alt="image-20210103145609976"></p><p>因为当 wi 比较小，则求出来的 function 比较平滑，输出对输入更加不敏感</p><p>更倾向于平滑的 function，因为越平滑，收到 noise 的影响越小</p><p>不断的调节 <em>λ</em> ，求出结果， <em>λ</em> 越大则考虑平滑越多</p><p>发现越平滑，考虑的err越少，则 training data 的结果越糟糕，但是 testing data 效果反而可能好一些，所以需要调节  <em>λ</em> 来决定 function 的平滑程度，（调节平滑不需要考虑 b）</p><p><img src= "/img/loading.gif" data-lazy-src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210103152631989.png" alt="image-20210103152631989"></p><p>总结：宝可梦的当前CP和物种决定几乎进化后的CP值（可能还有其他因素）</p><p>梯度下降，过度拟合和考虑平滑</p><h3 id="error-来自哪里"><a href="#error-来自哪里" class="headerlink" title="error 来自哪里"></a>error 来自哪里</h3><p>来自 bias 平均</p><p>来自 variance 方差</p><p><img src= "/img/loading.gif" data-lazy-src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210103154345098.png" alt="image-20210103154345098"></p><p><img src= "/img/loading.gif" data-lazy-src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210103154955082.png" alt="image-20210103154955082"></p><p>error 来自 bias，说明你没有瞄准好，导致估计值偏离真实值</p><p>error 来自 variance，说明你射的不够稳，还没有收敛/773.0</p><p><img src= "/img/loading.gif" data-lazy-src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210103155658459.png" alt="image-20210103155658459"></p><p>求各个模型的 f*（100组不同数据） ，发现简单的 model 是比较集中的，即 variance 比较小，不容易散开</p><p>model 比较复杂的话，function 散布就会很开，variance 比较开</p><p>为什么？</p><p>因为 model 比较复杂，受到不同的 data 影响比较大</p><p>bias：large bias，如何评测 f* 和 f^ 的 bias 差多少？</p><p><img src= "/img/loading.gif" data-lazy-src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210103160043302.png" alt="image-20210103160043302"></p><p>这里用红色表示各个 function 的结果，蓝色表示平均值，黑色表示正确答案，</p><p><img src= "/img/loading.gif" data-lazy-src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210103160242454.png" alt="image-20210103160242454"></p><p>可以看到，虽然这些 f* 不知道飘到哪里去了，但是平均起来看，f* 和 f^ 还是比较接近的，即 复杂的 model 的 bias 还是比较小的</p><p>所以，当你的 model 越来越复杂，bias 会越来越小，variance 会越来越大</p><p><img src= "/img/loading.gif" data-lazy-src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210103160649516.png" alt="image-20210103160649516"></p><h4 id="如何分辨现在是-underfitting-还是-overfitting？"><a href="#如何分辨现在是-underfitting-还是-overfitting？" class="headerlink" title="如何分辨现在是 underfitting 还是 overfitting？"></a>如何分辨现在是 underfitting 还是 overfitting？</h4><p>当你的 traning data 结果比较差的时候，是 underfitting</p><p>当你的 training data 结果比较好但是 testing data 结果很差的时候，大概是 overfitting</p><p><img src= "/img/loading.gif" data-lazy-src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210103160835816.png" alt="image-20210103160835816"></p><p>怎么做？</p><p>error from bias：重新设计 model、或者用一个更加复杂的 model，找更多 data 也没用</p><p>error from variance：</p><p><img src= "/img/loading.gif" data-lazy-src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210103161153542.png" alt="image-20210103161153542"></p><p>找更多 data、或者 generate 一些假 data 哈哈哈</p><p>或者 regularization：再加一些参数，比如曲线平滑度</p><p><img src= "/img/loading.gif" data-lazy-src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210103161601332.png" alt="image-20210103161601332"></p><p>但是这样子得到的数据可能会伤害你的 bias</p><blockquote><p>bias偏移量越大，模型越垃圾。而高阶model往往会造成其bias偏移量较小（参考高数泰勒展开）。从而导致高阶model（或者说是复杂model）的模型更贴合于数据的真实分布。但是当我们用新的测试集在高阶model上进行预测时，由于高阶model的形态过分贴合训练集数据且高阶model群较为繁杂，其在新的测试集数据上的拟合优度一定不会很好。</p></blockquote><h3 id="model-选择"><a href="#model-选择" class="headerlink" title="model 选择"></a>model 选择</h3><p>我们希望找一个 bias 和 variance 都比较小的 model</p><p>should not do：</p><p><img src= "/img/loading.gif" data-lazy-src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210103162039800.png" alt="image-20210103162039800"></p><p>你的 testing set 只是一个验证 training set 的 set，真实的 testing set 往往都是没有的</p><p>所以应该是这样做：用training data 选择 function，用 traning + validation 验证 model，这样才能真实反映 testing 的 bias（也就是不要提前考虑 testing data 的bias）</p><p><img src= "/img/loading.gif" data-lazy-src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210103162412021.png" alt="image-20210103162412021"></p><p>N 折交叉验证：</p><p><img src= "/img/loading.gif" data-lazy-src="/2021/01/03/ML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/image-20210103162636812.png" alt="image-20210103162636812"></p><p>把 training data 分成 n 份，选一个作为 validation</p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简易区块链C语言实现</title>
      <link href="2020/12/30/%E7%AE%80%E6%98%93%E5%8C%BA%E5%9D%97%E9%93%BEC%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/"/>
      <url>2020/12/30/%E7%AE%80%E6%98%93%E5%8C%BA%E5%9D%97%E9%93%BEC%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="简易区块链C语言实现"><a href="#简易区块链C语言实现" class="headerlink" title="简易区块链C语言实现"></a>简易区块链C语言实现</h1><p>在CSDN的第四个任务：实现一个最简单的区块链，不带区块链网络、时间戳、merkle tree等</p><p>虽然说技术上难度不大，但是想要实现它，还真是一个不小的工程。。。</p><p>除了 SHA256 的计算部分，其余的代码都是自己实现的，写的不好还望见谅</p><h2 id="区块链数据结构："><a href="#区块链数据结构：" class="headerlink" title="区块链数据结构："></a>区块链数据结构：</h2><p><img src= "/img/loading.gif" data-lazy-src="/2020/12/30/%E7%AE%80%E6%98%93%E5%8C%BA%E5%9D%97%E9%93%BEC%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/image-20201229232408783.png" alt="image-20201229232408783"></p><p>如图所示，每个区块分为区块 head，和区块 body</p><p>区块头又分为 SHA_ALL、nonce、SHA_PREV、SHA_BLOCK</p><blockquote><p>SHA_BLOCK: 对区块的 body 部分进行一次 SHA256运算，保存在SHA_BLOCK</p><p>SHA_PREV: 保存上一个区块整体(head+body)的 SHA256 值</p><p>nonce: 随机数，意义仅仅只是让区块头（不包含SHA_ALL的部分）+区块体一起进行SHA256运算，使得最终的结果刚好出现 n 个前导0，n 可以设置，代表出块的难度，模拟POW共识算法（比特币采用POW），我看了比特币源码，比特币源码的 nonce 是采用的 long long ，那我这里采用 unsigned long，之前龙哥和我说256位的nonce，我跑了跑发现没有必要，nonce跑到10万就需要我电脑好几秒了。。。unsigned long（8字节） 最大值有<strong>18446744073709551615</strong>，根本跑不完好吗。。。</p><p>当然比特币的 nonce 虽然只有8字节，但这里并不是说比特币的区块取值每次只需要计算2^64种情况，比特币实际挖坑时，最终的哈希值前导 0 特别长，只遍历一次 nonce 是几乎不可能的情况，矿机需要不断地改变区块体里面的 coinbase 里的无意义的值，然后不断地去遍历 nonce ，才能试探出前导0多于 n 个的情况，这将耗费巨大的算力，也是比特币POW共识策略的体现</p><p>SHA_ALL: 存放在区块头的最上面，SHA_ALL 保存整个区块（不包含头最上面的这256比特）的SHA256计算结果，必须有 n 个前导0。它的意义在于，只要你修改了这个区块的任意部分，你就需要重新计算 HASH_BLOCK、重新计算 NONCE ，使得最终的 SHA_ALL 算出来要出现 n 个前导0，当 n 比较大，区块链比较长时，想要修改某区块并使整个区块链仍合法的工作量不可估量，这是区块链“不可篡改”的重要因素之一</p></blockquote><p>区块体就比较随意了，我这里只弄了一个字符串</p><p>这样就实现了一个最简单的区块链</p><p>具体代码实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> byte[<span class="number">104</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> sha_all[<span class="number">32</span>];       <span class="comment">// 256 bit sha_all</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> nonce;             <span class="comment">// 64 bit nonce</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> sha_prev[<span class="number">32</span>];      <span class="comment">// 256 bit sha_prev</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> sha_block[<span class="number">32</span>];     <span class="comment">// 256 bit sha_block</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125; block_chain_head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> body[<span class="number">1000</span>];</span><br><span class="line">&#125; block_chain_body;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    block_chain_head head;</span><br><span class="line">    block_chain_body body;</span><br><span class="line">&#125; block;</span><br></pre></td></tr></table></figure><p>这里补充一下C语言共用体的知识：</p><ul><li><p>我们知道结构体（Struct）是一种构造类型或复杂类型，它可以包含多个类型不同的成员。在C语言中，还有另外一种和结构体非常类似的语法，叫做<strong>共用体（Union）</strong>，它的定义格式为：</p><p>union 共用体名{<br>  成员列表<br>};</p><blockquote><p>共用体有时也被称为联合或者联合体，这也是 Union 这个单词的本意。</p></blockquote><p>结构体和共用体的区别在于：结构体的各个成员会占用不同的内存，互相之间没有影响；而共用体的所有成员占用同一段内存，修改一个成员会影响其余所有成员。</p><p>结构体占用的内存大于等于所有成员占用的内存的总和（成员之间可能会存在缝隙），共用体占用的内存等于最长的成员占用的内存。共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来成员的值覆盖掉。</p></li></ul><p>这里采用 Union + Struct 的数据结构，是为了录入数据+读取数据都比较方便直观。当我想要录入数据时，我只需要读字节流，将104个字节赋值给 byte 数组即可，当我想访问某些数据时，我又可以用结构体的方式直接访问成员变量，代码非常的简洁，可读性也高</p><p>题外话：</p><p>之前想着是用哈希值命名文件，区块头可以少一个 sha 字段，看起来好像没啥问题，但是实际实现的时候，用哈希值来命名区块，有一个很严重的 bug</p><p>我们使用最终的哈希值有n个前导0，这样来控制难度，文件名是一个字符串，0在字符串里表现为字符 ‘\0’ ，而这个字符被视为默认的字符串终止符，这个字符串你赋值给 const char* tmp，编译器会发现第一个字符就是字符串终止符，故而会把 tmp 这个字符串常量视为 “” 这样的空字符串保存在常量池，故而不能直接用这个哈希值来作为区块文件的文件名</p><p>同样的，但凡这个哈希值里面有 ‘\0’ ，我们都不能将它作为文件名，所以文件名我不采用哈希值，哈希值还是选择保存在区块头中</p><h2 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h2><p>一个简易的区块链，必须有下面几个功能：</p><ul><li>生成创世纪块</li><li>读取文件夹下的所有区块</li><li>查找创世纪块</li><li>查找区块链的最后一个区块</li><li>在区块链的尾部追加区块</li><li>对区块的SHA计算</li></ul><p>求SHA256:</p><p>我使用了别人实现的SHA256算法，参考：<a href="https://github.com/panlianghnu/Blockchain-programming-exercises/tree/master/1.Blockchain%20basic%20exercises/2.Cryptography%20and%20security%20technology/SHA256/C%20Code">SHA256-C语言实现</a></p><p>这个程序有一个bug，当我将区块头和尾合并，一起作为字节数组传入时，有时候求出来的SHA256值正常，有时候值是错误的，我检查好久发现他在加密实现的过程中对传入的比特数组做了 strlen() 运算。。。这直接导致了如果传入的数据有 unsigned char 0，将被识别为字符串终结符，strlen() 函数遇到tmp直接终止计算，导致传入的字符串长度识别不正常，故而时好时坏（特别是创世纪块中有大量的 unsigned char 0，一直算出错误的SHA，还难以发现），我手动算字符串长度并作为参数传入计算，算是修了这个bug</p><h4 id="生成创世纪块："><a href="#生成创世纪块：" class="headerlink" title="生成创世纪块："></a>生成创世纪块：</h4><p>先贴代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;    <span class="comment">// 创建创世纪块</span></span><br><span class="line">    block_chain_head* genesis = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(block_chain_head));</span><br><span class="line">    block_chain_body genesis_body;</span><br><span class="line">    <span class="built_in">strcpy</span>(genesis_body.body,<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(genesis-&gt;byte,<span class="number">0</span>,<span class="keyword">sizeof</span>(block_chain_head));    <span class="comment">// 先将区块字节头全部初始化为0</span></span><br><span class="line">    sha256_main(genesis_body.body,<span class="keyword">sizeof</span>(genesis_body.body),genesis-&gt;sha_block);   <span class="comment">// 哈希body</span></span><br><span class="line">    <span class="comment">// 随机 nonce ，对(块头+块体)再次哈希</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;开始随机nonce\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (genesis-&gt;nonce &lt; <span class="number">0xffffffffffffffff</span>) &#123;</span><br><span class="line">        <span class="comment">// 把块头块体 读入一个 BYTE 数组</span></span><br><span class="line">        BYTE text[<span class="number">10200</span>];</span><br><span class="line">        read_head_body(text,genesis,genesis_body);</span><br><span class="line">        BYTE buf[SHA256_BLOCK_SIZE];</span><br><span class="line">        <span class="keyword">size_t</span> size_of_text = <span class="keyword">sizeof</span>(block_chain_head)<span class="number">-32</span> + <span class="built_in">strlen</span>(genesis_body.body);</span><br><span class="line">        sha256_main(text,size_of_text,buf);    <span class="comment">// 计算 sha256   有bug??? (已解决)</span></span><br><span class="line">        <span class="comment">// 当text 含有 &#x27;\0&#x27; 时，出现bug</span></span><br><span class="line">        <span class="comment">// 所以添加变量 size_of_text (注意要减去32 sha_all)</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;当前nonce为: %lu     &quot;</span>,genesis-&gt;nonce);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;前8bit为:%02x\n&quot;</span>,buf[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span> (check_sha(buf)) &#123;   <span class="comment">// 检查是否为前导0</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;创世纪块nonce为: %lu\n&quot;</span>,genesis-&gt;nonce);</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span>* filename = <span class="string">&quot;Genesis.block&quot;</span>;</span><br><span class="line">            FILE *fp = fopen(filename,<span class="string">&quot;w&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line">            <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;SHA256_BLOCK_SIZE;i++) &#123;</span><br><span class="line">                genesis-&gt;sha_all[i] = buf[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="keyword">sizeof</span>(block_chain_head);i++) &#123;   <span class="comment">// 写入区块头</span></span><br><span class="line">                <span class="built_in">fprintf</span>(fp,<span class="string">&quot;%c&quot;</span>,genesis-&gt;byte[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(genesis_body.body);i++) &#123;  <span class="comment">// 写入区块体</span></span><br><span class="line">                <span class="built_in">fprintf</span>(fp,<span class="string">&quot;%c&quot;</span>,genesis_body.body[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        genesis-&gt;nonce++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就体现出联合体的优点了，直接可以通过 memset 对整个头初始化，却不影响我访问对应的结构题属性，计算 SHA256 时，我引用了别人的函数，sha256_main()，将对应的属性保存（创世纪块sha_prev = 0)，不断的计算nonce，由于采用了 unsigned long ，遍历只需要递增即可，注意每次递增 nonce，重新计算 SHA 的时候，一定要注意是从区块头的第32个字节开始往下读，一直把区块体的内容也读完，读出来的所有字节放入一个 BYTE text[SHA256_BLOCK_SIZE] 数组里，一起去求 SHA256，这样算出来的 SHA_ALL才是正确的，我这边难度设置的是前 16个 bit 为0，平均大概10秒能出一个块吧</p><h4 id="验证-genesis-文件："><a href="#验证-genesis-文件：" class="headerlink" title="验证 genesis 文件："></a>验证 genesis 文件：</h4><p>使用 Mac 的二进制编辑器Hex Fiend打开查看：</p><p><img src= "/img/loading.gif" data-lazy-src="/2020/12/30/%E7%AE%80%E6%98%93%E5%8C%BA%E5%9D%97%E9%93%BEC%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/image-20201229173435239.png" alt="image-20201229173435239"></p><p>可以看到，前32字节的 sha_all ，是一串乱码，是我们使用SHA256生成的整个文件的256bit 哈希值</p><p>接下来8个字节：</p><p><img src= "/img/loading.gif" data-lazy-src="/2020/12/30/%E7%AE%80%E6%98%93%E5%8C%BA%E5%9D%97%E9%93%BEC%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/image-20201229173836110.png" alt="image-20201229173836110"></p><p>再接下来32字节的 sha_prev 全为0，这是我们初始化生成的0，创世纪块没有前一个块嘛</p><p>再接下来32字节是 sha_block ，这是区块体的哈希值，可以看到也是一串乱码</p><p><img src= "/img/loading.gif" data-lazy-src="/2020/12/30/%E7%AE%80%E6%98%93%E5%8C%BA%E5%9D%97%E9%93%BEC%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/image-20201229174021198.png" alt="image-20201229174021198"></p><p>最后的部分就是区块 body 的内容了，创世纪块的body 内容我写的很简单，就是hello world，可以看到在右边已经把它解析出来了</p><h4 id="读取文件夹下的所有区块："><a href="#读取文件夹下的所有区块：" class="headerlink" title="读取文件夹下的所有区块："></a>读取文件夹下的所有区块：</h4><p>C语言标准库没有提供读取文件夹的函数，官方文档也没找到。。。</p><p><img src= "/img/loading.gif" data-lazy-src="/2020/12/30/%E7%AE%80%E6%98%93%E5%8C%BA%E5%9D%97%E9%93%BEC%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/image-20201230113237235.png" alt="image-20201230113237235"></p><p>我引用了 “dirent.h” 库来读文件夹，调用 readdir(dir) 和 entry-&gt;d_name 来匹配文件名</p><p>参考<a href="https://blog.csdn.net/wangqingchuan92/article/details/80109793">C语言读取文件夹</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read_dir_block</span><span class="params">(block block_list[],<span class="keyword">const</span> <span class="keyword">char</span>* filePath)</span></span>&#123; <span class="comment">// 读文件夹所有块文件</span></span><br><span class="line">    DIR *dir = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">entry</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((dir = opendir(filePath)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open dir failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((entry = readdir(dir))!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span>* filename = entry-&gt;d_name;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strstr</span>(filename,<span class="string">&quot;.block&quot;</span>)) &#123;      <span class="comment">// 匹配区块文件(以.block结尾)</span></span><br><span class="line">            read_block(&amp;block_list[num],filename);</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    closedir(dir);</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 string.h 库函数 strstr() 子串查找，匹配文件名包含 .block 的文件，调用 read_block() 去读取文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_block</span><span class="params">(block *blockitem,<span class="keyword">const</span> <span class="keyword">char</span>* filename)</span></span>&#123;   <span class="comment">// 读一个块</span></span><br><span class="line">    FILE *fp = fopen(filename,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!fp) &#123;</span><br><span class="line">        perror(<span class="string">&quot;File opening failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> c,i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((c = fgetc(fp)) != EOF) &#123; <span class="comment">// standard C I/O file reading loop</span></span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="keyword">sizeof</span>(block_chain_head)) &#123;</span><br><span class="line">            blockitem-&gt;head.byte[i] = c;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            blockitem-&gt;body.body[i-<span class="keyword">sizeof</span>(block_chain_head)] = c;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历每个字符，这里又体现出联合体的优势了，直接载入文件的字符流，读 sizeof(block_chain_head) 个字符即可录入头部数据，文件剩余字符全部录入 body 即可</p><p>如此便可读取目录下的所有区块文件，放入 block_list 中</p><h4 id="查找创世纪块："><a href="#查找创世纪块：" class="headerlink" title="查找创世纪块："></a>查找创世纪块：</h4><p>实现了读取目录下的所有区块之后，查找创世纪块变得尤其简单，只需要遍历所有的区块，找到某个 SHA_PREV 为全0的区块，即是创世纪块</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">block <span class="title">find_first_block</span><span class="params">()</span></span>&#123;</span><br><span class="line">    block block_list[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *filePath = <span class="string">&quot;.&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> size = read_dir_block(block_list,filePath);   <span class="comment">// 一共 size 个区块</span></span><br><span class="line">    block tmp;</span><br><span class="line">    <span class="built_in">memset</span>(tmp.head.byte, <span class="number">0</span>, <span class="keyword">sizeof</span>(block_chain_head));</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;no block file\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    BYTE hash[SHA256_BLOCK_SIZE] = &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;size;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> cmp = <span class="built_in">memcmp</span>(hash,block_list[i].head.sha_prev,SHA256_BLOCK_SIZE);</span><br><span class="line">        <span class="keyword">if</span>(cmp == <span class="number">0</span>)&#123;   <span class="comment">// equal， this is the first block</span></span><br><span class="line">            <span class="keyword">return</span> block_list[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我使用memcmp() 函数来比较 SHA_PREV 是否为全0，这是 memcmp 的官方文档：</p><p><img src= "/img/loading.gif" data-lazy-src="/2020/12/30/%E7%AE%80%E6%98%93%E5%8C%BA%E5%9D%97%E9%93%BEC%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/image-20201230114505328.png" alt="image-20201230114505328"></p><p>可以看到，memcmp将二者解释为无符号字符数组，一个个比较，全部相等会返回0，特别方便</p><p>所以在这里我直接定义一个32字节全0的字符数组，然后调用 memcmp 比较即可</p><h4 id="查找最后一个区块："><a href="#查找最后一个区块：" class="headerlink" title="查找最后一个区块："></a>查找最后一个区块：</h4><p>这个算是特别常用的一个功能了</p><p>在查找文件夹下所有区块和查找创世纪块的基础之上，我们就可以去做区块的拓扑排序了</p><p>查找最后一个区块也就变成了求区块的拓扑排序，返回拓扑排序的最后一个区块即可</p><p>求拓扑序列的代码很简单我就不展示了，基本上就是一个二重循环，匹配第 j 个区块的 SHA_PREV 和当前区块的 SHA_ALL ，然后在尾部添加即可</p><h4 id="尾部添加区块："><a href="#尾部添加区块：" class="headerlink" title="尾部添加区块："></a>尾部添加区块：</h4><p>有了查找最后一个区块，尾部添加区块也就特别简单了</p><p>只需要找到最后一个区块的 SHA_ALL ，新开一个区块，写入 SHA_PREV ，然后就和之前的生成创世纪块类似了，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">new_block</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* block_name ,<span class="keyword">char</span>* content)</span></span>&#123; <span class="comment">// 和 init 类似，在末尾添加</span></span><br><span class="line">    block last_block = find_last_block();</span><br><span class="line">    </span><br><span class="line">    block_chain_head* genesis = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(block_chain_head));</span><br><span class="line">    block_chain_body genesis_body;</span><br><span class="line">    <span class="built_in">strcpy</span>(genesis_body.body,content);</span><br><span class="line">    <span class="built_in">memset</span>(genesis-&gt;byte,<span class="number">0</span>,<span class="keyword">sizeof</span>(block_chain_head));    <span class="comment">// 先将区块头全部初始化为0</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;SHA256_BLOCK_SIZE;i++) &#123;</span><br><span class="line">        genesis-&gt;sha_prev[i] = last_block.head.sha_all[i];  <span class="comment">// 写入 sha_prev</span></span><br><span class="line">    &#125;</span><br><span class="line">    sha256_main(genesis_body.body,<span class="keyword">sizeof</span>(genesis_body.body),genesis-&gt;sha_block); <span class="comment">// sha_block</span></span><br><span class="line">    <span class="comment">// 随机 nonce ，对(块头+块体)再次哈希</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;开始随机nonce\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (genesis-&gt;nonce &lt; <span class="number">0xffffffffffffffff</span>) &#123;</span><br><span class="line">        <span class="comment">// 把块头块体 读入一个 BYTE 数组</span></span><br><span class="line">        BYTE text[<span class="number">10200</span>];</span><br><span class="line">        read_head_body(text,genesis,genesis_body);</span><br><span class="line">        BYTE buf[SHA256_BLOCK_SIZE];</span><br><span class="line">        <span class="keyword">size_t</span> size_of_text = <span class="keyword">sizeof</span>(block_chain_head)<span class="number">-32</span> + <span class="built_in">strlen</span>(genesis_body.body);</span><br><span class="line">        sha256_main(text,size_of_text,buf);    <span class="comment">// 计算 sha256   有bug??? (已解决)</span></span><br><span class="line">        <span class="comment">// 当text 含有 &#x27;\0&#x27; 时，出现bug</span></span><br><span class="line">        <span class="comment">// 所以添加变量 size_of_text (注意要减去32 sha_all)</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;当前nonce为: %lu     &quot;</span>,genesis-&gt;nonce);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;前8bit为:%02x\n&quot;</span>,buf[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span> (check_sha(buf)) &#123;   <span class="comment">// 检查是否为前导0</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;新区块nonce为: %lu\n&quot;</span>,genesis-&gt;nonce);</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span>* filename = <span class="built_in">strcat</span>(block_name, <span class="string">&quot;.block&quot;</span>);</span><br><span class="line">            FILE *fp = fopen(filename,<span class="string">&quot;w&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;SHA256_BLOCK_SIZE;i++) &#123;</span><br><span class="line">                genesis-&gt;sha_all[i] = buf[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="keyword">sizeof</span>(block_chain_head);i++) &#123;   <span class="comment">// 写入区块头</span></span><br><span class="line">                <span class="built_in">fprintf</span>(fp,<span class="string">&quot;%c&quot;</span>,genesis-&gt;byte[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(genesis_body.body);i++) &#123;  <span class="comment">// 写入区块体</span></span><br><span class="line">                <span class="built_in">fprintf</span>(fp,<span class="string">&quot;%c&quot;</span>,genesis_body.body[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        genesis-&gt;nonce++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>不要在意为什么新区块也叫 genesis 我懒得改了</del></p><p>除了区块的 filename 、SHA_PREV 、body 不一样，其他的操作完全和创世纪块一样</p><p>写新区块时，我需要给新区块后缀命名为 .block </p><p>c语言不能直接使用 + 运算符对字符串进行拼接，故使用strcat，跑到一半又报错了。。原因是strcat直接在字符数组尾部添加字符，晕，数组越界了。</p><p><img src= "/img/loading.gif" data-lazy-src="/2020/12/30/%E7%AE%80%E6%98%93%E5%8C%BA%E5%9D%97%E9%93%BEC%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/image-20201229223124304.png" alt="image-20201229223124304"></p><p>不得不再次感叹C语言的字符串处理真是太不方便了</p><p><img src= "/img/loading.gif" data-lazy-src="/2020/12/30/%E7%AE%80%E6%98%93%E5%8C%BA%E5%9D%97%E9%93%BEC%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/image-20201229224105511.png" alt="image-20201229224105511"></p><p>可以看到 block_one 的 sha_prev 的部分，变成了 genesis 的前32字节，也就是哈希值指向 genesis </p><p>新区块的产生基本和创世纪块一样，只是调用一下 find_last_block ，找到 sha_prev 的值即可，然后自行输入 block_name 和 block_body</p><p>再看 block_two 和 block_one</p><p><img src= "/img/loading.gif" data-lazy-src="/2020/12/30/%E7%AE%80%E6%98%93%E5%8C%BA%E5%9D%97%E9%93%BEC%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/image-20201229224428292.png" alt="image-20201229224428292"></p><p>相应的 sha_prev、  sha_all 字段都是一一对应起来的</p><p><img src= "/img/loading.gif" data-lazy-src="/2020/12/30/%E7%AE%80%E6%98%93%E5%8C%BA%E5%9D%97%E9%93%BEC%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/image-20201229224529388.png" alt="image-20201229224529388"></p><p>解析出来的 body 也是正常的</p><p>尾部新增区块完成！</p><h4 id="检验区块链合法"><a href="#检验区块链合法" class="headerlink" title="检验区块链合法"></a>检验区块链合法</h4><p>在 find_last_block() 函数的实现中，topo 序列只要能构造出来，说明sha_prev 和 sha_all 能够一一对上，该区块链是合法的，所以实现也和 find_last_block 基本一样。如果创世纪块找不到，则区块链不合法，从创世纪块后找 n个区块（n为区块总数目-1），一旦找不到区块的 sha_prev 指向当前 sha_all，则区块链不合法，具体实现在 check_block_chain() 函数里，得到拓扑序列之后，遍历这个序列，计算各个区块的 SHA_，任意区块的 SHA 计算错误则该区块链不合法</p><h4 id="建立区块链索引"><a href="#建立区块链索引" class="headerlink" title="建立区块链索引"></a>建立区块链索引</h4><p>find_last_block() 和 check_block_chain() 函数里都做过拓扑排序的操作，参考上面的函数即可</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>感谢能看到最后的小伙伴！代码我开源到 GitHub 了</p><p><a href="https://github.com/panlianghnu/block_chain">https://github.com/panlianghnu/block_chain</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> c语言 </tag>
            
            <tag> 区块链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS 单线程</title>
      <link href="2020/12/22/JS-%E5%8D%95%E7%BA%BF%E7%A8%8B/"/>
      <url>2020/12/22/JS-%E5%8D%95%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="JS-单线程"><a href="#JS-单线程" class="headerlink" title="JS 单线程"></a>JS 单线程</h1><p>JS执行是单线程</p><blockquote><p>单线程是指Js引擎执行Js时只分了一个线程给他执行，也就是执行js时是单线程的。</p></blockquote><p>那么问题来了，什么是线程？进程又是什么？</p><p>在分析浏览器的渲染过程之前，我们先了解一下什么是进程和线程：</p><p>（1）什么是进程？</p><p>进程是CPU进行资源分配的基本单位</p><p>（2）什么是线程？</p><p>线程是CPU调度的最小单位，是建立在进程的基础上运行的单位，共享进程的内存空间。</p><p>多进程<br>1、浏览器是多进程</p><p>2、不同类型的标签页都会开启一个新的进程</p><p>3、相同类型的标签页是会合并到一个进程</p><p>1、浏览器进程</p><p>（1）负责管理各个标签页的创建和销毁</p><p>（2）负责浏览器的页面显示和功能（前进，后退，收藏等）</p><p>（3）负责资源的管理与下载</p><p>2、第三方插件进程</p><p>（1）负责每个第三方插件的使用，每个第三方插件使用时候都会创建一个对应的进程</p><p>3、GPU进程</p><p>（1）负责3D绘制和硬件加速</p><p>4、浏览器渲染进程（咱们这回主要分析的）</p><p>1、浏览器内核，主要负责HTML，CSS，JS等文件的解析和执行</p><p>什么是浏览器内核？</p><p>浏览器内核就是浏览器渲染进程，从接收下载文件后再到呈现整个页面的过程，由浏览器渲染进程负责，主要流程如下：</p><p>1、解析HTML文件和CSS文件，加载图片等资源文件，渲染成用户看到的页面<br>2、执行解析js文件脚本代码</p><p>这里主要讲浏览器页面渲染过程，在该过程中浏览器渲染进程会开启多个线程协作完成，主要的线程以及作用如下：</p><p>1、GUI渲染线程<br>2、JS引擎线程<br>3、事件触发线程<br>4、定时器出发线程<br>5、异步HTTP请求线程</p><h2 id="JS引擎"><a href="#JS引擎" class="headerlink" title="JS引擎"></a>JS引擎</h2><p>1、JS内核，也称JS引擎（例如V8引擎），负责处理执行javascript脚本程序，<br>2、由于js是单线程（一个Tab页内中无论什么时候都只有一个JS线程在运行JS程序），依靠任务队列来进行js代码的执行，所以js引擎会一直等待着任务队列中任务的到来，然后加以处理。</p><blockquote><p>注意，JavaScript 只在一个线程上运行，不代表 JavaScript 引擎只有一个线程。事实上，JavaScript 引擎有多个线程，单个脚本只能在一个线程上运行（称为主线程），其他线程都是在后台配合</p></blockquote><p>为了利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作 DOM。所以，这个新标准并没有改变 JavaScript 单线程的本质。</p><h2 id="V8引擎的内部结构"><a href="#V8引擎的内部结构" class="headerlink" title="V8引擎的内部结构"></a>V8引擎的内部结构</h2><p>1、V8是一个非常复杂的项目，使用cloc统计可知，它竟然有超过100万行C++代码。<br>2、V8由许多子模块构成，其中这4个模块是最重要的：</p><ol><li>Parser：负责将JavaScript源码转换为Abstract Syntax Tree (AST)</li><li>Ignition：interpreter，即解释器，负责将AST转换为Bytecode，解释执行Bytecode；同时收集3. TurboFan优化编译所需的信息，比如函数参数的类型；</li><li>TurboFan：compiler，即编译器，利用Ignitio所收集的类型信息，将Bytecode转换为优化的汇编代码；</li><li>Orinoco：garbage collector，垃圾回收模块，负责将程序不再需要的内存空间回收；</li></ol><blockquote><p>再次强调：单线程是指Js引擎执行Js时只分了一个线程给他执行，也就是执行js时是单线程的。</p></blockquote><p><strong>既然JS是单线程的，那怎么实现异步的呢？</strong></p><p>单线程意味着什么：JavaScript 同时只能执行一个任务，其他任务都必须在后面排队等待。也就是说代码只能同步执行，必须执行上一行才能执行下一行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure><p>然而并不是，还有异步！！！</p><p>程序里面所有的任务，可以分成两类：同步任务（synchronous）和异步任务（asynchronous）。</p><p>同步任务是那些没有被引擎挂起、在主线程上排队执行的任务。只有前一个任务执行完毕，才能执行后一个任务。</p><p>异步任务是那些被引擎放在一边，不进入主线程、而进入任务队列的任务。只有引擎认为某个异步任务可以执行了（比如 Ajax 操作从服务器得到了结果），该任务（采用回调函数的形式）才会进入主线程执行。排在异步任务后面的代码，不用等待异步任务结束会马上运行，也就是说，异步任务不具有“堵塞”效应。</p><p>举例来说，Ajax 操作可以当作同步任务处理，也可以当作异步任务处理，由开发者决定。如果是同步任务，主线程就等着 Ajax 操作返回结果，再往下执行；如果是异步任务，主线程在发出 Ajax 请求以后，就直接往下执行，等到 Ajax 操作有了结果，主线程再执行对应的回调函数。</p><h2 id="任务队列和事件循环-（实现异步）"><a href="#任务队列和事件循环-（实现异步）" class="headerlink" title="任务队列和事件循环 （实现异步）"></a>任务队列和事件循环 （实现异步）</h2><p>JavaScript 运行时，除了一个正在运行的主线程，引擎还提供一个任务队列（task queue），里面是各种需要当前程序处理的异步任务。（实际上，根据异步任务的类型，存在多个任务队列。为了方便理解，这里假设只存在一个队列。）</p><p>首先，主线程会去执行所有的同步任务。等到同步任务全部执行完，就会去看任务队列里面的异步任务。如果满足条件，那么异步任务就重新进入主线程开始执行，这时它就变成同步任务了。等到执行完，下一个异步任务再进入主线程开始执行。一旦任务队列清空，程序就结束执行。</p><p>异步任务的写法通常是回调函数。一旦异步任务重新进入主线程，就会执行对应的回调函数。如果一个异步任务没有回调函数，就不会进入任务队列，也就是说，不会重新进入主线程，因为没有用回调函数指定下一步的操作。</p><p>JavaScript 引擎怎么知道异步任务有没有结果，能不能进入主线程呢？答案就是引擎在不停地检查，一遍又一遍，只要同步任务执行完了，引擎就会去检查那些挂起来的异步任务，是不是可以进入主线程了。这种循环检查的机制，就叫做事件循环（Event Loop）。维基百科的定义是：“事件循环是一个程序结构，用于等待和发送消息和事件（a programming construct that waits for and dispatches events or messages in a program）”。</p><p>代码是如何执行的？</p><p>宏任务(macro-task)、微任务(micro-task)</p><p>除了广义的同步任务和异步任务，JavaScript 单线程中的任务可以细分为宏任务和微任务。</p><p>macro-task包括：script(整体代码), setTimeout, setInterval, setImmediate, I/O, UI rendering。<br>micro-task包括：process.nextTick, Promises, Object.observe, MutationObserver。</p><p>有了宏任务和微任务的概念后，那 JS 的执行顺序是怎样的？是宏任务先还是微任务先？</p><p>第一次事件循环中，JavaScript 引擎会把整个 script 代码当成一个宏任务执行，执行完成之后，再检测本次循环中是否寻在微任务，存在的话就依次从微任务的任务队列中读取执行完所有的微任务，再读取宏任务的任务队列中的任务执行，再执行所有的微任务，如此循环。JS 的执行顺序就是每次事件循环中的宏任务-微任务。</p><p>页面刷新率？</p><p>每次微任务执行之后宏任务执行之前如果有UI操作页面会重新渲染，一般页面刷新率60HZ/秒，一帧是16.6毫秒，所以可以理解为事件循环每次轮询的时间大概是16.6毫秒</p><p>每一帧浏览器需要做什么？</p><p>我们所看到的网页，都是浏览器一帧一帧绘制出来的，通常认为FPS为60的时候是比较流畅的，而FPS为个位数的时候就属于用户可以感知到的卡顿了，那么在一帧里面浏览器都要做哪些事情呢</p><h2 id="渲染帧的流程"><a href="#渲染帧的流程" class="headerlink" title="渲染帧的流程"></a>渲染帧的流程</h2><p>渲染帧是指浏览器一次完整绘制过程，帧之间的时间间隔是 DOM 视图更新的最小间隔。 由于主流的屏幕刷新率都在 60Hz，那么渲染一帧的时间就必须控制在 16ms 才能保证不掉帧。 也就是说每一次渲染都要在 16ms 内页面才够流畅不会有卡顿感。 这段时间内浏览器需要完成如下事情：</p><ul><li>脚本执行（JavaScript）：脚本造成了需要重绘的改动，比如增删 DOM、请求动画等</li><li>样式计算（CSS Object Model）：级联地生成每个节点的生效样式。</li><li>布局（Layout）：计算布局，执行渲染算法</li><li>重绘（Paint）：各层分别进行绘制（比如 3D 动画）</li><li>合成（Composite）：合成各层的渲染结果</li></ul><p>最初 Webkit 使用定时器进行渲染间隔控制， 2014 年时开始 <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=337617">使用显示器的 vsync 信号控制渲染</a>（其实直接控制的是合成这一步）。 这意味着 16ms 内多次 commit 的 DOM 改动会合并为一次渲染。</p><h2 id="耗时-JS-会造成丢帧"><a href="#耗时-JS-会造成丢帧" class="headerlink" title="耗时 JS 会造成丢帧"></a>耗时 JS 会造成丢帧</h2><p>JavaScript 在并发编程上一个重要特点是“Run To Completion”。在事件循环的一次 Tick 中， 如果要执行的逻辑太多会一直阻塞下一个 Tick，所有异步过程都会被阻塞。 一个流畅的页面中，JavaScript 引擎中的执行队列可能是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">执行 JS -&gt; 空闲 -&gt; 绘制（16ms）-&gt; 执行 JS -&gt; 空闲 -&gt; 绘制（32ms）-&gt; ...</span><br></pre></td></tr></table></figure><p>如果在某个时刻有太多 JavaScript 要执行，就会丢掉一次帧的绘制：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">执行很多 JS...（20ms）-&gt; 空闲 -&gt; 绘制（32ms）-&gt; ...</span><br></pre></td></tr></table></figure><p>例如下面的脚本在保持 JavaScript 忙的状态（持续 5s）下每隔 1s 新增一行 DOM 内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;message&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var then &#x3D; Date.now()</span><br><span class="line">var i &#x3D; 0</span><br><span class="line">var el &#x3D; document.getElementById(&#39;message&#39;)</span><br><span class="line">while (true) &#123;</span><br><span class="line">  var now &#x3D; Date.now()</span><br><span class="line">  if (now - then &gt; 1000) &#123;</span><br><span class="line">    if (i++ &gt;&#x3D; 5) &#123;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">    el.innerText +&#x3D; &#39;hello!\n&#39;</span><br><span class="line">    console.log(i)</span><br><span class="line">    then &#x3D; now</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>可以观察到虽然每秒都会写一次 DOM，但在 5s 结束后才会全部渲染出来，明显耗时脚本阻塞了渲染。</p><p><img src= "/img/loading.gif" data-lazy-src="/2020/12/22/JS-%E5%8D%95%E7%BA%BF%E7%A8%8B/js-block-render.gif" alt="js block render"></p>]]></content>
      
      
      
        <tags>
            
            <tag> nodejs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python 文字版RPG小游戏</title>
      <link href="2020/12/17/python-%E6%96%87%E5%AD%97%E7%89%88RPG%E5%B0%8F%E6%B8%B8%E6%88%8F/"/>
      <url>2020/12/17/python-%E6%96%87%E5%AD%97%E7%89%88RPG%E5%B0%8F%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<p>之前龙哥给我们布置了两个任务</p><p><a href="https://panlianghnu.github.io/2020/12/14/Coder-%E8%AF%AD%E8%A8%80%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/">语言快速上手-学习任务</a> </p><p>这是第一个</p><p><img src= "/img/loading.gif" data-lazy-src="/2020/12/17/python-%E6%96%87%E5%AD%97%E7%89%88RPG%E5%B0%8F%E6%B8%B8%E6%88%8F/image-20201217155246062.png" alt="image-20201217155246062"></p><p>基本就是实现一个文字版本的RPG小游戏，刚好我今天在bilibili看到一个互动视频觉得很有意思，就想着把这个视频用文字的形式复现出来</p><p>视频链接：<a href="https://www.bilibili.com/video/BV1pZ4y1W7LK?from=search&seid=15774110568370964830">【互动视频】卢本伟越狱记</a></p><p>这种互动视频有很多选项，每个选项都会影响之后的剧情，所以我使用一个栈来保存之前的选择，也方便每次互动时，玩家选错选项来有机会反悔回到上一步</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line">stack = []</span><br><span class="line">stack.append(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">len</span>(stack)&gt;<span class="number">0</span>:</span><br><span class="line">    case = stack[-<span class="number">1</span>]   <span class="comment">#  读最后一个case</span></span><br><span class="line">    <span class="keyword">if</span> case == <span class="number">0</span>:      <span class="comment">#  case0:等待开始游戏</span></span><br><span class="line">        print(<span class="string">&#x27;卢本伟越狱记&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;卢本伟开挂被抓了，你能帮助卢本伟成功越狱吗？（你需要扮演卢本伟完成越狱）&#x27;</span>)</span><br><span class="line">        start = <span class="built_in">input</span>(<span class="string">&quot;输入&#x27;start&#x27;开始游戏，输入其他结束\n&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> start != <span class="string">&#x27;start&#x27;</span>:</span><br><span class="line">            print(<span class="string">&quot;你输入了：&quot;</span>,start,<span class="string">&quot; 游戏结束...&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>: <span class="comment"># 游戏开始</span></span><br><span class="line">            stack.append(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> case == <span class="number">1</span>:      <span class="comment">#  case1:开始游戏</span></span><br><span class="line">        print(<span class="string">&quot;卢本伟被关在牢房，这时来了俩警察&quot;</span>)</span><br><span class="line">        print(<span class="string">&#x27;警察1:“you are free guy now...骗你的哈哈哈”&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;警察1:“你有个朋友给你寄了一个包裹，但是你不要想着轻举妄动，我们已经检查过里面了，是吧？”&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;警察2:“（心虚）是啊是啊，我当然检查过了，这是我的工作嘛”&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;两个警察把包裹留下就走了&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;卢本伟打开了包裹，发现一个生日蛋糕，生日蛋糕里面居然藏了东西，你会选择？&#x27;</span>)</span><br><span class="line">        tmp = <span class="built_in">input</span>(<span class="string">&#x27;A.锉刀 B.钻机 C.返回上一步 其他.结束游戏\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> tmp == <span class="string">&quot;A&quot;</span> :</span><br><span class="line">            stack.append(<span class="number">2</span>)   <span class="comment">#  case2: 选择锉刀</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> tmp == <span class="string">&quot;B&quot;</span> :</span><br><span class="line">            stack.append(<span class="number">3</span>)   <span class="comment">#  case3: 选择钻机</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> tmp == <span class="string">&quot;C&quot;</span> :</span><br><span class="line">            <span class="keyword">del</span> stack[-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span> : <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> case == <span class="number">2</span>:       <span class="comment"># case2：选择锉刀</span></span><br><span class="line">        print(<span class="string">&#x27;你选择了锉刀，卢本伟切割了监狱门，并打倒了守卫，这时有人追了过来&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;卢本伟灵机一动，躲进了一个小房间，但是这不是长久之计，必须找到方法越狱&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;卢本伟发现房间里有：A.手雷   B.椅子&#x27;</span>)</span><br><span class="line">        tmp = <span class="built_in">input</span>(<span class="string">&#x27;聪明的你会选择：A.手雷  B.椅子 C.返回上一步 其他.结束游戏\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> tmp == <span class="string">&quot;A&quot;</span> :</span><br><span class="line">            stack.append(<span class="number">4</span>)  <span class="comment"># case4: 选择手雷</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> tmp == <span class="string">&quot;B&quot;</span> :</span><br><span class="line">            stack.append(<span class="number">5</span>)  <span class="comment"># case5: 选择椅子</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> tmp == <span class="string">&quot;C&quot;</span> :</span><br><span class="line">            <span class="keyword">del</span> stack[-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span> : <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> case == <span class="number">4</span>:       <span class="comment"># case4: 选择手雷</span></span><br><span class="line">        print(<span class="string">&#x27;情急之下，卢本伟拿起了地上的手雷，准备和追来的警察拼死一搏&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;两个警察追过俩把门堵上，卢本伟失手把自己炸死了&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;game over&#x27;</span>)</span><br><span class="line">        tmp = <span class="built_in">input</span>(<span class="string">&#x27;输入A重开游戏，输入B返回上一步，输入其他结束游戏\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> tmp == <span class="string">&quot;A&quot;</span>:</span><br><span class="line">            stack = []</span><br><span class="line">            stack.append(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> tmp == <span class="string">&quot;B&quot;</span>:</span><br><span class="line">            <span class="keyword">del</span> stack[-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span> : <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> case == <span class="number">5</span>:       <span class="comment"># case5: 选择椅子</span></span><br><span class="line">        print(<span class="string">&#x27;聪明的卢本伟发现通过椅子可以钻进天花板的通风管道&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;这个时候问题来了，通风管道只能向左或向右&#x27;</span>)</span><br><span class="line">        tmp = <span class="built_in">input</span>(<span class="string">&#x27;你会选择？ A.向右 B.向左 C.返回上一步 其他.结束游戏\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> tmp == <span class="string">&quot;A&quot;</span> : </span><br><span class="line">            stack.append(<span class="number">6</span>)  <span class="comment"># case6: 选择向右</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> tmp == <span class="string">&quot;B&quot;</span> :</span><br><span class="line">            stack.append(<span class="number">7</span>)  <span class="comment"># case7: 选择向左</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> tmp == <span class="string">&quot;C&quot;</span> :</span><br><span class="line">            <span class="keyword">del</span> stack[-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span> : <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> case == <span class="number">6</span>:     <span class="comment"># 选择向右</span></span><br><span class="line">        print(<span class="string">&#x27;卢本伟顺着通风管道爬到了天台&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;在天台，卢本伟发现了 A.喷气背包 B.马桶塞&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;你会选择什么装备逃生？&#x27;</span>)</span><br><span class="line">        tmp = <span class="built_in">input</span>(<span class="string">&#x27;A.喷气背包 B.马桶塞 C.返回上一步 其他.结束游戏\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> tmp == <span class="string">&quot;A&quot;</span> : </span><br><span class="line">            stack.append(<span class="number">8</span>)  <span class="comment"># case8: 选择喷气背包</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> tmp == <span class="string">&quot;B&quot;</span> :</span><br><span class="line">            stack.append(<span class="number">9</span>)  <span class="comment"># case9: 选择马桶塞</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> tmp == <span class="string">&quot;C&quot;</span> :</span><br><span class="line">            <span class="keyword">del</span> stack[-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span> : <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> case == <span class="number">7</span>:     <span class="comment"># 选择向左</span></span><br><span class="line">        print(<span class="string">&#x27;警察们在会议室开会，而卢本伟不小心掉进了会议室，game over&#x27;</span>)</span><br><span class="line">        tmp = <span class="built_in">input</span>(<span class="string">&#x27;输入A重开游戏，输入B返回上一步，输入其他结束游戏\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> tmp == <span class="string">&quot;A&quot;</span>:</span><br><span class="line">            stack = []</span><br><span class="line">            stack.append(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> tmp == <span class="string">&quot;B&quot;</span>:</span><br><span class="line">            <span class="keyword">del</span> stack[-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span> : <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> case == <span class="number">8</span>:       <span class="comment"># case8: 选择喷气背包</span></span><br><span class="line">        print(<span class="string">&#x27;伞兵一号卢本伟准备就绪！！！&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;Oh这是个坏的喷气背包，卢本伟摔死了&#x27;</span>)</span><br><span class="line">        tmp = <span class="built_in">input</span>(<span class="string">&#x27;输入A重开游戏，输入B返回上一步，输入其他结束游戏\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> tmp == <span class="string">&quot;A&quot;</span>:</span><br><span class="line">            stack = []</span><br><span class="line">            stack.append(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> tmp == <span class="string">&quot;B&quot;</span>:</span><br><span class="line">            <span class="keyword">del</span> stack[-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span> : <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> case == <span class="number">9</span>:       <span class="comment"># case9: 选择马桶塞</span></span><br><span class="line">        print(<span class="string">&#x27;卢本伟左手一个马桶塞，右手一个马桶塞&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;凭借强大的臂力和马桶塞的吸力，卢本伟成功的飞檐走壁逃出监狱！！&#x27;</span>)</span><br><span class="line">        tmp = <span class="built_in">input</span>(<span class="string">&#x27;输入A重开游戏，输入B返回上一步，输入其他结束游戏\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> tmp == <span class="string">&quot;A&quot;</span>:</span><br><span class="line">            stack = []</span><br><span class="line">            stack.append(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> tmp == <span class="string">&quot;B&quot;</span>:</span><br><span class="line">            <span class="keyword">del</span> stack[-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span> : <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> case == <span class="number">3</span>:       <span class="comment"># case3: 选择钻机</span></span><br><span class="line">        print(<span class="string">&#x27;你选择了钻机，卢本伟使用钻机钻地，发现地下还有个房间&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;卢本伟想都没想直接跳进了下面的房间，环顾四周&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;房间里有一个井盖好像可以撬开，还有一个传送器上面写着“你会变得透明并可以穿墙”&#x27;</span>)</span><br><span class="line">        tmp = <span class="built_in">input</span>(<span class="string">&#x27;你会选择？ A.传送器 B.撬棍 C.返回上一步 其他.结束游戏\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> tmp == <span class="string">&quot;A&quot;</span> : </span><br><span class="line">            stack.append(<span class="number">10</span>)  <span class="comment"># case10: 选择传送器</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> tmp == <span class="string">&quot;B&quot;</span> :</span><br><span class="line">            stack.append(<span class="number">11</span>)  <span class="comment"># case11: 选择撬棍</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> tmp == <span class="string">&quot;C&quot;</span> :</span><br><span class="line">            <span class="keyword">del</span> stack[-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span> : <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> case == <span class="number">10</span>:</span><br><span class="line">        print(<span class="string">&#x27;你选择了传送器&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;卢本伟按下了传送器，他开始变得透明，墙无法阻挡他，但是地面也无法支撑他，卢本伟直接沉到了地心，死了&#x27;</span>)</span><br><span class="line">        tmp = <span class="built_in">input</span>(<span class="string">&#x27;输入A重开游戏，输入B返回上一步，输入其他结束游戏\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> tmp == <span class="string">&quot;A&quot;</span>:</span><br><span class="line">            stack = []</span><br><span class="line">            stack.append(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> tmp == <span class="string">&quot;B&quot;</span>:</span><br><span class="line">            <span class="keyword">del</span> stack[-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span> : <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> case == <span class="number">11</span>:</span><br><span class="line">        print(<span class="string">&#x27;你选择了撬棍&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;卢本伟撬开了井盖，钻进井盖发现掉到了一楼大厅走廊上&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;卢本伟被两个警察发现，警察们追着他跑&#x27;</span>)</span><br><span class="line">        tmp = <span class="built_in">input</span>(<span class="string">&#x27;这时你会？ A.往左跑 B.往右跑 C.返回上一步 其他.结束游戏\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> tmp == <span class="string">&quot;A&quot;</span>:</span><br><span class="line">            stack.append(<span class="number">12</span>)   <span class="comment"># case12: 往左跑</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> tmp == <span class="string">&quot;B&quot;</span>:</span><br><span class="line">            stack.append(<span class="number">13</span>)   <span class="comment"># case13: 往右跑</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> tmp == <span class="string">&quot;C&quot;</span>:</span><br><span class="line">            <span class="keyword">del</span> stack[-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span> : <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> case == <span class="number">12</span>:</span><br><span class="line">        print(<span class="string">&#x27;你选择向左逃跑&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;那两个警察追不上卢本伟，但是追的人越来越多&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;现在卢本伟被五个带枪的警察包围&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;但是凭借卢本伟的走位，他们一枪没中，甚至射死了自己人&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;卢本赶紧趁乱跑到门口抢了一辆警车跑了&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;越狱成功，game over...&#x27;</span>)</span><br><span class="line">        tmp = <span class="built_in">input</span>(<span class="string">&#x27;输入A重开游戏，输入B返回上一步，输入其他结束游戏\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> tmp == <span class="string">&quot;A&quot;</span>:</span><br><span class="line">            stack = []</span><br><span class="line">            stack.append(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> tmp == <span class="string">&quot;B&quot;</span>:</span><br><span class="line">            <span class="keyword">del</span> stack[-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span> : <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> case == <span class="number">13</span>:</span><br><span class="line">        print(<span class="string">&#x27;卢本伟边走位边逃跑的时候还就那个不小心一头簪死在柱子上&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;无敌的卢本伟倒下了&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;game over...&#x27;</span>)</span><br><span class="line">        tmp = <span class="built_in">input</span>(<span class="string">&#x27;输入A重开游戏，输入B返回上一步，输入其他结束游戏\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> tmp == <span class="string">&quot;A&quot;</span>:</span><br><span class="line">            stack = []</span><br><span class="line">            stack.append(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> tmp == <span class="string">&quot;B&quot;</span>:</span><br><span class="line">            <span class="keyword">del</span> stack[-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span> : <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>下面是剧情介绍（建议去上面的视频链接，更加清晰）：</p><blockquote><p>卢本伟越狱记</p><p>卢本伟开外挂被抓了，你能帮助卢本伟成功越狱吗？（你需要扮演卢本伟完成越狱）</p><p>卢本伟被关在监狱，来了俩警察</p><p>警察1:“you are free guy，骗你的”</p><p>警察1:“你有个朋友给你寄了一个包裹，但是你不要想着轻举妄动，我们已经检查过里面了，是吧？”</p><p>警察2:“（心虚）是啊是啊，我当然检查过了，这是我的工作嘛”</p><p>卢本伟打开了包裹，发现一个生日蛋糕，生日蛋糕里面居然藏了东西，你会选择？A.锉刀 B.钻机</p><p>A.锉刀：你选择了锉刀，卢本伟切割了监狱门，并打倒了守卫，这时有人追了过来</p><p>​        你躲进了一个小房间，房间里有：A.手雷   B.椅子</p><p>​    A.手雷：两个人来抓你，你把自己炸死了</p><p>​    B.椅子：你通过椅子，爬进了通风管道，向左向右？</p><p>​        A.右 你爬到了天台，天台上有：A.喷气背包 B.马桶塞</p><p>​            A.伞兵一号卢本伟准备就绪，Oh，这是个坏的喷气背包，你摔死了</p><p>​            B.你成功的通过马桶塞一步一步吸住墙壁越狱成功！</p><p>​        B.左 警察们在会议室开会，你不小心掉进了会议室，game over</p><p>B.钻机：你选择了钻机，使用钻机钻地，你发现地下还有个房间，</p><p>​    房间里有一个井盖好像可以撬开，还有一个传送器上面写着“你会变得透明并可以穿墙”</p><p>​    A.传送器  B.撬棍</p><p>​    A.你按下了传送器，墙无法阻挡你，地面也无法支撑你，你直接沉到了地球核心，死了</p><p>​    B.你撬开了井盖，掉到了走廊，两个警察追着你跑</p><p>​        A.往左 你被五个人围住，但是凭借着走位，他们一枪没中，你抢了一辆警车跑路了</p><p>​        B.往右 你撞上了柱子，无敌的你倒下了 </p></blockquote><p>游戏装备介绍：</p><p>传送器：</p><p><img src= "/img/loading.gif" data-lazy-src="/2020/12/17/python-%E6%96%87%E5%AD%97%E7%89%88RPG%E5%B0%8F%E6%B8%B8%E6%88%8F/image-20201217155929460.png" alt="image-20201217155929460"></p><p>马桶塞：</p><p><img src= "/img/loading.gif" data-lazy-src="/2020/12/17/python-%E6%96%87%E5%AD%97%E7%89%88RPG%E5%B0%8F%E6%B8%B8%E6%88%8F/image-20201217155949961.png" alt="image-20201217155949961"></p><p>步骤：</p><p><img src= "/img/loading.gif" data-lazy-src="/2020/12/17/python-%E6%96%87%E5%AD%97%E7%89%88RPG%E5%B0%8F%E6%B8%B8%E6%88%8F/UNADJUSTEDNONRAW_thumb_10c.png" alt="UNADJUSTEDNONRAW_thumb_10c"></p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python快速入门</title>
      <link href="2020/12/15/Python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
      <url>2020/12/15/Python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Python快速入门"><a href="#Python快速入门" class="headerlink" title="Python快速入门"></a>Python快速入门</h1><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h4 id="定义一个函数"><a href="#定义一个函数" class="headerlink" title="定义一个函数"></a>定义一个函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">functionname</span>(<span class="params"> parameters </span>):</span></span><br><span class="line">   function_suite</span><br><span class="line">   <span class="keyword">return</span> [expression]</span><br></pre></td></tr></table></figure><h4 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h4><p>python里一切都是对象，参数都是对象的引用</p><ul><li><p>不可变类型：如整数、浮点数、字符串、元组()</p></li><li><p>可变类型：如列表、字典、自定义对象</p></li></ul><p>不可变类型作为参数传入时，对参数的修改其实是修改另一个复制的对象</p><p>可变类型作为参数传入时，函数内的修改会影响到函数外</p><h4 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h4><p>传参数时，要么按照要求（参数顺序，数量）严格传入参数，要么使用关键字参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(climbStairs(climbStairs,<span class="number">5</span>))  <span class="comment"># 斐波那契</span></span><br><span class="line">print(climbStairs(n=<span class="number">5</span>,self=climbStairs))  <span class="comment"># 斐波那契</span></span><br></pre></td></tr></table></figure><p>使用关键字参数，就可以不严格按照顺序来传参，并且代码可读性更好</p><p>注意⚠️：关键字参数不能和普通传参混用，一个参数是关键字参数，其他也要是</p><h4 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printHello</span>(<span class="params">arg=<span class="string">&quot;hello&quot;</span></span>):</span></span><br><span class="line">    print(arg)</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>这个函数可以不输入参数，也可以输入一个参数来替换默认的”hello”</p><h4 id="不定长参数"><a href="#不定长参数" class="headerlink" title="不定长参数"></a>不定长参数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printAll</span>(<span class="params">arg1, *vartuple</span>):</span>  </span><br><span class="line">     <span class="comment"># *vartuple 表示不定长参数，0~n个都可以</span></span><br><span class="line">     <span class="comment"># 而 arg1 保证至少有一个参数传进来，该函数不至于输出空</span></span><br><span class="line">    print(arg1)</span><br><span class="line">    <span class="keyword">for</span> var <span class="keyword">in</span> vartuple:</span><br><span class="line">        print(var)</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure><h4 id="匿名函数（lambda）"><a href="#匿名函数（lambda）" class="headerlink" title="匿名函数（lambda）"></a>匿名函数（lambda）</h4><p>python 使用 lambda 来创建匿名函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># lambda arg1,arg2,arg3... : expression</span></span><br><span class="line"><span class="built_in">pow</span> = <span class="keyword">lambda</span> arg1,arg2 : arg1 ** arg2  </span><br><span class="line"><span class="comment"># pow变量指向 lambda 这个匿名函数</span></span><br><span class="line"><span class="comment"># lambda只是一个表达式，函数体比def简单很多，仅仅能在lambda表达式中封装有限的逻辑进去</span></span><br><span class="line"><span class="comment"># 不能访问自有参数列表之外或全局命名空间里的参数！！</span></span><br><span class="line"><span class="comment"># 不等同于C或C++的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率</span></span><br></pre></td></tr></table></figure><h4 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h4><p><strong>全局变量</strong></p><p>定义在函数外，可以在整个程序范围内访问</p><p><strong>局部变量</strong></p><p>定义在函数内，只能在函数内访问</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量没有类型，变量是任意对象的引用，变量的赋值不需要声明，python是动态类型+强类型的语言</p><h4 id="标准数据类型"><a href="#标准数据类型" class="headerlink" title="标准数据类型"></a>标准数据类型</h4><p>python 提供了6个标准数据类型 </p><p>注意⚠️：没有提供数组类型，建议用列表替代   **a = [ 0 for i in range(1000) ] **</p><ul><li>Numbers              不可变</li><li>Strings                   不可变    序列</li><li>Tuple  (元组)         不可变    序列       （虽然元组的元素不可改变，但是元组可以包含可变对象）</li><li>List  [列表]                            序列</li><li>Dictionary  {字典} </li><li>Set  集合</li></ul><p><strong>Numbers :</strong></p><ul><li><p>int （有符号整数）</p></li><li><p>Long (python2.2 之后被移除，int 溢出会自动变为 long)</p></li><li><p>float （浮点数）</p></li><li><p>complex（复数）</p></li></ul><p><strong>Strings :</strong></p><p>字符串取值：</p><ul><li>从左到右 str[0] ~ str[len-1]</li><li>从右到左 str[-1] ~ str[-len]</li></ul><p>截取字符串：[头下表 : 尾下标]     <strong>这将返回一个新的对象</strong></p><p><img src= "/img/loading.gif" data-lazy-src="/2020/12/15/Python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20201215113418036.png" alt="image-20201215113418036"></p><p>Python列表截取还要第三个参数（步长）</p><p><img src= "/img/loading.gif" data-lazy-src="/2020/12/15/Python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20201215113930063.png" alt="image-20201215113930063"></p><p><strong>列表：</strong></p><p>列表可以完成大多数集合类的数据结构实现 <strong>最常用的类型</strong></p><p>它支持字符，数字，字符串甚至可以包含列表（即嵌套）</p><p>用 + 连接列表， 用 * 表示重复操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&#x27;12345&#x27;</span></span><br><span class="line">b = a[<span class="number">2</span>:] + a[<span class="number">4</span>:]</span><br><span class="line">print(b * <span class="number">2</span>)</span><br><span class="line">输出：<span class="number">34553455</span></span><br></pre></td></tr></table></figure><p>列表内置方法很多</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">append clear copy count extend</span><br><span class="line">index pop remove reverse sort</span><br></pre></td></tr></table></figure><p>列表的元素是可以删除的： del  a[2] </p><p>适用于列表的方法：</p><p>cmp(list1, list2) , 列表类型不同则没啥意义，类型相同则</p><ul><li>哪个列表短哪个列表就小，返回1或-1</li><li>一样长则元素小列表就小，返回1或-1</li><li>所有元素相同则返回0</li></ul><p>len(list)，获得列表长度</p><p>max(list)，返回列表元素最大值</p><p>min(list)，返回列表元素最小值</p><p>list(seq)，将元组转换为列表</p><p><strong>元组：</strong></p><p>可以理解为只读列表，不能二次赋值</p><p>元组用 () 标识</p><p>删除元组只能删除整个元组 del tup</p><p><strong>字典：</strong></p><p>字典(dictionary)是除列表以外python之中最灵活的内置数据结构类型</p><p>字典用 {} 标识</p><p>通过 dict[key] 来访问 value</p><p>字典的key 必须是不可变对象</p><p>可以删除 key-value 也能显示删除整个字典 : del dict[‘key’]  、 del dict</p><p>字典包括以下内置方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">clear get </span><br><span class="line">has_key(key)</span><br><span class="line">copy(浅复制) </span><br><span class="line">items <span class="comment"># 以列表返回可以遍历的 key-value 元组</span></span><br><span class="line">fromkeys(seq[,val])  <span class="comment"># 返回一个列表，keys为这个序列的值，val为默认值</span></span><br><span class="line">keys(返回所有key)</span><br><span class="line">values（返回所有值）</span><br><span class="line">upadte(dict2)   <span class="comment"># 把dict2的键值对更新到dict里</span></span><br><span class="line">pop(key)</span><br><span class="line">popitem()       <span class="comment"># 返回并删除字典中最后一对 key-value</span></span><br></pre></td></tr></table></figure><p><strong>数据类型转换</strong></p><table><thead><tr><th align="center">函数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">int(x [,base])</td><td align="center">将x转换为一个整数</td></tr><tr><td align="center">long(x [,base])</td><td align="center">将x转换为一个长整数</td></tr><tr><td align="center">float(x)</td><td align="center">将x转换到一个浮点数</td></tr><tr><td align="center">complex(real [,imag])</td><td align="center">创建一个复数</td></tr><tr><td align="center">str(x)</td><td align="center">将对象 x 转换为字符串</td></tr><tr><td align="center">repr(x)</td><td align="center">将对象 x 转换为表达式字符串</td></tr><tr><td align="center">eval(str)</td><td align="center">用来计算在字符串中的有效Python表达式,并返回一个对象</td></tr><tr><td align="center">tuple(s)</td><td align="center">将序列 s 转换为一个元组</td></tr><tr><td align="center">list(s)</td><td align="center">将序列 s 转换为一个列表</td></tr><tr><td align="center">set(s)</td><td align="center">转换为可变集合</td></tr><tr><td align="center">dict(d)</td><td align="center">创建一个字典。d 必须是一个序列 (key,value)元组。</td></tr><tr><td align="center">frozenset(s)</td><td align="center">转换为不可变集合</td></tr><tr><td align="center">chr(x)</td><td align="center">将一个整数转换为一个字符</td></tr><tr><td align="center">unichr(x)</td><td align="center">将一个整数转换为Unicode字符</td></tr><tr><td align="center">ord(x)</td><td align="center">将一个字符转换为它的整数值</td></tr><tr><td align="center">hex(x)</td><td align="center">将一个整数转换为一个十六进制字符串</td></tr><tr><td align="center">oct(x)</td><td align="center">将一个整数转换为一个八进制字符串</td></tr></tbody></table><h2 id="元组包含可变对象时"><a href="#元组包含可变对象时" class="headerlink" title="元组包含可变对象时"></a>元组包含可变对象时</h2><p>直接上代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">b = <span class="number">4</span></span><br><span class="line">c = (a,b) <span class="comment"># c为包含可变对象的元组</span></span><br><span class="line">print(c)</span><br><span class="line">a.append(<span class="number">3</span>)</span><br><span class="line">print(c)</span><br><span class="line">a = [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">print(c)</span><br><span class="line"></span><br><span class="line">打印结果：</span><br><span class="line">([<span class="number">1</span>, <span class="number">2</span>], <span class="number">4</span>)</span><br><span class="line">([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>)</span><br><span class="line">([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>可以看到，当 a.append(3)后，c[0]变化了。当 a = [5,6,7] 时，c[0]没变</p><p>所以，元组的元素不可变应该这样理解，生成元组时，元组里的所有元素都会被保存在数据区</p><ul><li><p>a = [5,6,7]，是像字符串赋值那样重新开辟了内存空间，让a指向新的内存，但是元组内的值还是指向原来的内存，所以这个情况元组的值是不会变化的</p></li><li><p>a.append(3)，a本身是没有变化的，但是a指向的内存里的值发生了变化，所以元组也”变化”了</p></li></ul><p>再来看一个情况</p><p><img src= "/img/loading.gif" data-lazy-src="/2020/12/15/Python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20201215225743487.png" alt="image-20201215225743487"></p><p>这个情况也是 a.append()。为什么c没有变化呢？</p><p>list底层是数组实现的，添加这么多元素后，a 指向的内存地址发生了变化，而元组内的值指向的内存地址是不会发生变化的，所以这个时候，a和元组内的”a” 不是一个a了</p><p><strong>所谓元组的不可变指的是元组所指向的内存中的内容不可变</strong></p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p><strong>算数运算：</strong></p><p>+ - * / %  </p><p>**(返回x的y次幂)</p><p>//（返回商的整数部分，python里整数除以整数也会转换成浮点数）</p><p><strong>比较运算：</strong></p><p>==  比较对象是否相等 (字符串可以用这个比较)</p><p>!=  比较对象是否不等   </p><blockquote><pre><code>&lt;      &gt;=      &lt;=</code></pre></blockquote><p><strong>位运算：</strong></p><p>&amp; 按位与</p><p>| 按位或</p><p>^ 按位异或</p><p>~ 按位取反</p><p>&lt;&lt; 左移 （不会溢出，自动变成long）</p><p>&gt;&gt; 右移 （它是算数右移，-4右移变成-2）</p><p><strong>逻辑运算：</strong></p><p>and or not</p><p><strong>成员运算：</strong></p><p>in：如果在指定的序列中找到值返回 True，否则返回 False。</p><p>not in： 如果在指定的序列中没有找到值返回 True，否则返回 False。</p><p><strong>身份运算：</strong></p><p>用于判断变量是否指向同一个对象</p><p>is （和==不一样，==是判断值，is 判断对象）</p><p>is not</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = student(name=<span class="string">&quot;panliang&quot;</span>,age=<span class="number">4</span>)</span><br><span class="line">b = student(name=<span class="string">&quot;panliang&quot;</span>,age=<span class="number">4</span>)</span><br><span class="line"><span class="keyword">if</span> a == b:</span><br><span class="line">    print(<span class="string">&quot;a == b&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&quot;a != b&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> a <span class="keyword">is</span> b: </span><br><span class="line">    print(<span class="string">&quot;a is b&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&quot;a is not b&quot;</span>)</span><br></pre></td></tr></table></figure><p>打印结果：<img src= "/img/loading.gif" data-lazy-src="/2020/12/15/Python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/image-20201215153923819.png" alt="image-20201215153923819"></p><p>可以看到，自定义对象不能用 == 比较（python字符串可以），就算他们的内容相同</p><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (condition):</span><br><span class="line">  statements</span><br></pre></td></tr></table></figure><p>contidion 可以是任何表达式，任何非零、或非空（null）的值均为true。</p><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> sequence:</span><br><span class="line">  statements</span><br></pre></td></tr></table></figure><p>遍历序列所有的元素   </p><p>注意⚠️：给列表赋值时，这样写是不行的 for i in seq 返回的是新的对象</p><p>for 循环经常和 range 函数配合使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">  statements</span><br></pre></td></tr></table></figure><p>range(n)会返回一个列表，i 会从0遍历到n-1</p><p>range也支持多个参数，比如反向遍历 range(n,0,-1)，遍历从n到1（不会到0）</p><p><strong>python3的range()函数返回的是一个可迭代对象（类型是对象），而不是列表（为了性能），所以打印range不会输出列表</strong></p><h4 id="循环的else"><a href="#循环的else" class="headerlink" title="循环的else"></a>循环的else</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>,<span class="number">20</span>):  <span class="comment"># 迭代 10 到 20 之间的数字</span></span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,num): <span class="comment"># 根据因子迭代</span></span><br><span class="line">      <span class="keyword">if</span> num%i == <span class="number">0</span>:      <span class="comment"># 确定第一个因子</span></span><br><span class="line">         j=num/i          <span class="comment"># 计算第二个因子</span></span><br><span class="line">         <span class="built_in">print</span> <span class="string">&#x27;%d 等于 %d * %d&#x27;</span> % (num,i,j)</span><br><span class="line">         <span class="keyword">break</span>            <span class="comment"># 跳出当前循环</span></span><br><span class="line">   <span class="keyword">else</span>:                  <span class="comment"># 循环的 else 部分</span></span><br><span class="line">      <span class="built_in">print</span> num, <span class="string">&#x27;是一个质数&#x27;</span></span><br><span class="line"><span class="comment"># 当循环没有通过break跳出来时， 会执行 else    while循环也类似</span></span><br></pre></td></tr></table></figure><h2 id="模块、输入和输出"><a href="#模块、输入和输出" class="headerlink" title="模块、输入和输出"></a>模块、输入和输出</h2><h4 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> sys.argv:</span><br><span class="line">  print(i)</span><br><span class="line">print(<span class="string">&#x27;\nPython路径为：&#x27;</span>,sys.path,<span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure><p>代码回输出所有通过命令行传入的参数</p><p>sys.path 包含了一个 Python 解释器自动查找所需模块的路径的列表（相当于环境变量）</p><p>import时，会自动执行被导入的包里的程序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">如果希望自己的程序不在被<span class="keyword">import</span>时执行，需要把自己的程序代码写在</span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">  print(<span class="string">&#x27;我自己在运行&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  print(<span class="string">&#x27;我来自另一模块&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="包"><a href="#包" class="headerlink" title="包"></a>包</h4><p>包是一种管理 Python 模块命名空间的形式，采用 package.module 就不会让不同包的模块混淆以及不同模块之间的全局变量互相影响</p><p>在导入一个包的时候，Python 会根据 sys.path 中的目录来寻找这个包中包含的子目录</p><p>目录只有包含一个叫做  __init__.py 的文件才会被认作是一个包，主要是为了避免一些滥俗的名字</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">可能的包结构</span><br><span class="line">sound/                          顶层包</span><br><span class="line">      __init__.py               初始化 sound 包</span><br><span class="line">      formats/                  文件格式转换子包</span><br><span class="line">              __init__.py</span><br><span class="line">              wavread.py</span><br><span class="line">              wavwrite.py</span><br><span class="line">              aiffread.py</span><br><span class="line">              aiffwrite.py</span><br><span class="line">              auread.py</span><br><span class="line">              auwrite.py</span><br><span class="line">              ...</span><br><span class="line">      effects/                  声音效果子包</span><br><span class="line">              __init__.py</span><br><span class="line">              echo.py</span><br><span class="line">              surround.py</span><br><span class="line">              reverse.py</span><br><span class="line">              ...</span><br><span class="line">      filters/                  filters 子包</span><br><span class="line">              __init__.py</span><br><span class="line">              equalizer.py</span><br><span class="line">              vocoder.py</span><br><span class="line">              karaoke.py</span><br><span class="line">              ...</span><br></pre></td></tr></table></figure><p>可以  imort sound.formats.auwrite 来导入 auwrite 模块</p><p>但是调用函数时，也需要sound.formats.auwrite.function</p><p>所以不妨这样 from sound.formats import auwrite</p><p>调用函数时，只需要 auwrite.function , 无需冗长前缀</p><p>甚至可以只导入一个函数或者变量：</p><p>from sound.effects.echo import echofilter</p><p>这种方法会导入子模块: echo，并且可以直接使用他的 echofilter() 函数</p><p>当使用 <strong>from package import item</strong> 时， import 语法会首先把 item 当作一个包定义的名称，如果没找到，再试图按照一个模块去导入。最后按照函数、类、变量这样去找。</p><p>如果还没找到，抛出一个 <strong>:exc:ImportError</strong> 异常。</p><p>反之，如果使用形如 <strong>import item.subitem.subsubitem</strong> 这种导入形式，除了最后一项，都必须是包，而最后一项则可以是模块或者是包，但是不可以是类，函数或者变量的名字。</p><p>从包里导入*，会找到目录下所有的子模块，都导入，但是在windows这类大小写不分的平台上工作很不好，需要包作者在 __init__.py 里的一个 all 列表变量写入导入的包名</p><h2 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h2><h4 id="标准输入输出"><a href="#标准输入输出" class="headerlink" title="标准输入输出"></a>标准输入输出</h4><p>Python提供了 input() 内置函数从标准输入读入一行文本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="built_in">input</span>(<span class="string">&quot;请输入:&quot;</span>)</span><br><span class="line">print(<span class="built_in">str</span>)</span><br></pre></td></tr></table></figure><h4 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">txt = <span class="built_in">open</span>(<span class="string">&#x27;addTowNum.py&#x27;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"><span class="built_in">str</span> = txt.read()</span><br><span class="line">print(<span class="built_in">str</span>)</span><br></pre></td></tr></table></figure><p>open有两个参数，一个是filename， 一个是文件打开模式（可以不写，默认模式为 r ）</p><p>file.read()有一个参数size，表示读取的数据数量（可以不写，默认读文件所有字符）</p><p>file.readline() 读文件一行</p><p>file.write(str) 将str写入文件，返回写入的字符数</p><table><thead><tr><th align="left">模式</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">r</td><td align="left">以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。</td></tr><tr><td align="left">rb</td><td align="left">以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。</td></tr><tr><td align="left">r+</td><td align="left">打开一个文件用于读写。文件指针将会放在文件的开头。</td></tr><tr><td align="left">rb+</td><td align="left">以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。</td></tr><tr><td align="left">w</td><td align="left">打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td></tr><tr><td align="left">wb</td><td align="left">以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td></tr><tr><td align="left">w+</td><td align="left">打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td></tr><tr><td align="left">wb+</td><td align="left">以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td></tr><tr><td align="left">a</td><td align="left">打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td></tr><tr><td align="left">ab</td><td align="left">以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td></tr><tr><td align="left">a+</td><td align="left">打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。</td></tr><tr><td align="left">ab+</td><td align="left">以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。</td></tr></tbody></table><p><img src= "/img/loading.gif" data-lazy-src="/2020/12/15/Python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/2112205-861c05b2bdbc9c28.png" alt="img"></p><p>file.close() 关闭文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;/tmp/foo.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">read_data = f.read()</span><br><span class="line">f.closed</span><br><span class="line">使用<span class="keyword">with</span> 比 <span class="keyword">try</span> <span class="keyword">finally</span> 简单</span><br></pre></td></tr></table></figure><h2 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h2><p>import time</p><h4 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h4><p>time.time()   用于获取当前时间戳（是一个浮点数，表示从1970年1月1日午夜，经过了多少秒）</p><p>无法表示1970年之后的、Unix和Windows只支持到2038年</p><p>非常适合用于计算时间差</p><h4 id="时间元组"><a href="#时间元组" class="headerlink" title="时间元组"></a>时间元组</h4><p>很多python函数用包含9个元素的元组来处理时间：</p><p>struct_time 元组</p><table><thead><tr><th align="left">序号</th><th align="left">属性</th><th align="left">值</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">tm_year</td><td align="left">2008</td></tr><tr><td align="left">1</td><td align="left">tm_mon</td><td align="left">1 到 12</td></tr><tr><td align="left">2</td><td align="left">tm_mday</td><td align="left">1 到 31</td></tr><tr><td align="left">3</td><td align="left">tm_hour</td><td align="left">0 到 23</td></tr><tr><td align="left">4</td><td align="left">tm_min</td><td align="left">0 到 59</td></tr><tr><td align="left">5</td><td align="left">tm_sec</td><td align="left">0 到 61 (60或61 是闰秒)</td></tr><tr><td align="left">6</td><td align="left">tm_wday</td><td align="left">0到6 (0是周一)</td></tr><tr><td align="left">7</td><td align="left">tm_yday</td><td align="left">1 到 366(儒略历)</td></tr><tr><td align="left">8</td><td align="left">tm_isdst</td><td align="left">-1, 0, 1, -1是决定是否为夏令时的旗帜</td></tr></tbody></table><h4 id="时间戳转换为时间元组"><a href="#时间戳转换为时间元组" class="headerlink" title="时间戳转换为时间元组"></a>时间戳转换为时间元组</h4><p>只需要将浮点数传递给如 localtime 之类的函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line">localtime = time.localtime(time.time())</span><br><span class="line">print(<span class="string">&quot;本地时间为：&quot;</span>,localtime)</span><br><span class="line"></span><br><span class="line">本地时间为：time.struct_time(tm_year=<span class="number">2020</span>, tm_mon=<span class="number">12</span>, tm_mday=<span class="number">15</span>, tm_hour=<span class="number">17</span>, tm_min=<span class="number">11</span>, tm_sec=<span class="number">52</span>, tm_wday=<span class="number">1</span>, tm_yday=<span class="number">350</span>, tm_isdst=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h4 id="获取格式化时间"><a href="#获取格式化时间" class="headerlink" title="获取格式化时间"></a>获取格式化时间</h4><p>你可以获取时间元组，然后自定义输出</p><p>但是有一个函数可以很方便得将时间元组转换成字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line">localtime = time.localtime(time.time())</span><br><span class="line">asctime = time.asctime(localtime)</span><br><span class="line">print(asctime)</span><br><span class="line"></span><br><span class="line">Tue Dec <span class="number">15</span> <span class="number">17</span>:<span class="number">20</span>:<span class="number">16</span> <span class="number">2020</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Anaconda安装</title>
      <link href="2020/12/14/Anaconda%E5%AE%89%E8%A3%85/"/>
      <url>2020/12/14/Anaconda%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>Anaconda 是Mac电脑上的一个开源的Python发行版本。Conda是一个开源的包、环境管理器，可以用于在同一个机器上安装不同版本的软件包及其依赖，并能够在不同的环境之间切换。Anaconda包括Conda、Python以及一大堆安装好的工具包，比如：numpy、pandas等。</p><p>　　conda软件包</p><p>　　搜索我们基于云的资源库，查找并安装超过7500个数据科学和机器学习包。使用conda-install命令，您可以开始使用成千上万的开源Conda、R、Python和其他许多软件包。</p><p>　　管理环境</p><p>　　个人版是一个开源、灵活的解决方案，它提供了跨平台方式构建、分发、安装、更新和管理软件的实用工具。<strong>Conda可以轻松管理多个数据环境，这些环境可以单独维护和运行，互不干扰。</strong></p><h3 id="一、下载安装包"><a href="#一、下载安装包" class="headerlink" title="一、下载安装包"></a>一、下载安装包</h3><ul><li><a href="https://www.anaconda.com/distribution/#download-section">Anaconda安装包下载</a></li></ul><p><img src= "/img/loading.gif" data-lazy-src="/2020/12/14/Anaconda%E5%AE%89%E8%A3%85/image-20201214181301536.png" alt="image-20201214181301536"></p><ul><li>官网可能速度比较慢，我在<a href="http://www.pc6.com/mac/842752.html%E4%B8%8B%E7%9A%84">http://www.pc6.com/mac/842752.html下的</a></li></ul><h3 id="二、开始安装"><a href="#二、开始安装" class="headerlink" title="二、开始安装"></a>二、开始安装</h3><p><img src= "/img/loading.gif" data-lazy-src="/2020/12/14/Anaconda%E5%AE%89%E8%A3%85/image-20201214180356537.png" alt="image-20201214180356537"></p><p>一直下一步就行了</p><h3 id="三、安装成功，设置conda环境变量"><a href="#三、安装成功，设置conda环境变量" class="headerlink" title="三、安装成功，设置conda环境变量"></a>三、安装成功，设置conda环境变量</h3><p>我这边不用配环境，默认配好了</p><p>查看验证 conda list</p><p><img src= "/img/loading.gif" data-lazy-src="/2020/12/14/Anaconda%E5%AE%89%E8%A3%85/image-20201214181117531.png" alt="image-20201214181117531"></p><hr><h3 id="conda常用操作命令"><a href="#conda常用操作命令" class="headerlink" title="conda常用操作命令"></a>conda常用操作命令</h3><h5 id="1、查看环境管理的全部命令帮助："><a href="#1、查看环境管理的全部命令帮助：" class="headerlink" title="1、查看环境管理的全部命令帮助："></a>1、查看环境管理的全部命令帮助：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda env -h</span><br><span class="line">或者</span><br><span class="line">conda</span><br></pre></td></tr></table></figure><h5 id="2、查看当前系统下的环境："><a href="#2、查看当前系统下的环境：" class="headerlink" title="2、查看当前系统下的环境："></a>2、查看当前系统下的环境：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda info -e</span><br><span class="line">或者</span><br><span class="line">conda-env list</span><br></pre></td></tr></table></figure><h5 id="3、创建环境："><a href="#3、创建环境：" class="headerlink" title="3、创建环境："></a>3、创建环境：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create env_name     </span><br></pre></td></tr></table></figure><p>【注】 (env_name)是环境名称,这条命令创建一个新的环境，存储位置在安装文件的隐藏文件/.conda文件夹里面</p><p><strong>创建指定python版本的环境：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create env_name python&#x3D;3.6   </span><br></pre></td></tr></table></figure><h5 id="4、激活进入某个环境"><a href="#4、激活进入某个环境" class="headerlink" title="4、激活进入某个环境"></a>4、激活进入某个环境</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">activate env_name</span><br></pre></td></tr></table></figure><h5 id="5、退出某个环境："><a href="#5、退出某个环境：" class="headerlink" title="5、退出某个环境："></a>5、退出某个环境：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deactivate env_name</span><br></pre></td></tr></table></figure><h5 id="6、复制某个环境："><a href="#6、复制某个环境：" class="headerlink" title="6、复制某个环境："></a>6、复制某个环境：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create new_env_name old_env_name</span><br></pre></td></tr></table></figure><h5 id="7、删除某个环境："><a href="#7、删除某个环境：" class="headerlink" title="7、删除某个环境："></a>7、删除某个环境：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda remove env_name</span><br></pre></td></tr></table></figure><h5 id="8、安装包："><a href="#8、安装包：" class="headerlink" title="8、安装包："></a>8、安装包：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda install xxx</span><br><span class="line">pip install xxx</span><br></pre></td></tr></table></figure><h5 id="9、指定的安装环境："><a href="#9、指定的安装环境：" class="headerlink" title="9、指定的安装环境："></a>9、指定的安装环境：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install -n env_name 包名</span><br></pre></td></tr></table></figure><h5 id="10、查看已安装的包："><a href="#10、查看已安装的包：" class="headerlink" title="10、查看已安装的包："></a>10、查看已安装的包：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda list</span><br></pre></td></tr></table></figure><h5 id="11、查看指定环境下的包："><a href="#11、查看指定环境下的包：" class="headerlink" title="11、查看指定环境下的包："></a>11、查看指定环境下的包：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda list -n 环境名</span><br></pre></td></tr></table></figure><h5 id="12、查找包："><a href="#12、查找包：" class="headerlink" title="12、查找包："></a>12、查找包：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda search 包名</span><br></pre></td></tr></table></figure><h5 id="13、更新包："><a href="#13、更新包：" class="headerlink" title="13、更新包："></a>13、更新包：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda update xxx</span><br></pre></td></tr></table></figure><h5 id="14、安装anaconda发行版中所有的包"><a href="#14、安装anaconda发行版中所有的包" class="headerlink" title="14、安装anaconda发行版中所有的包:"></a>14、安装anaconda发行版中所有的包:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install anaconda</span><br></pre></td></tr></table></figure><h5 id="15、卸载包："><a href="#15、卸载包：" class="headerlink" title="15、卸载包："></a>15、卸载包：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda remove xxx</span><br></pre></td></tr></table></figure><h4 id="三、管理conda"><a href="#三、管理conda" class="headerlink" title="三、管理conda"></a>三、管理conda</h4><h5 id="1、检查conda版本："><a href="#1、检查conda版本：" class="headerlink" title="1、检查conda版本："></a>1、检查conda版本：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda -V# 大写V</span><br></pre></td></tr></table></figure><h5 id="2、升级当前版本的conda："><a href="#2、升级当前版本的conda：" class="headerlink" title="2、升级当前版本的conda："></a>2、升级当前版本的conda：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda update conda</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> Anaconda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python简史</title>
      <link href="2020/12/14/python%E7%AE%80%E5%8F%B2/"/>
      <url>2020/12/14/python%E7%AE%80%E5%8F%B2/</url>
      
        <content type="html"><![CDATA[<p>本文作者：Vamei 出处：<a href="http://www.cnblogs.com/vamei">http://www.cnblogs.com/vamei</a></p><p>Python是我喜欢的语言，简洁，优美，容易使用。前两天，我很激昂的向朋友宣传Python的好处。</p><p>听过之后，朋友问我：好吧，我承认Python不错，但它为什么叫Python呢？</p><p>我不是很确定：呃，似乎是一个电视剧的名字。</p><p>朋友又问：那你说的Guido是美国人么？ (Guido von Rossum，Python的作者)</p><p>我再次不是很确定：他从google换到Dropbox工作，但他的名字像是荷兰人的 (有一个von在中间)。</p><p>所以，后面我花了些时间调查Python的历史。这是很好的学习。我看到了Python中许多功能的来源和Python的设计理念，比如哪些功能是历史遗留，哪些功能是重复，如何增加功能…… 而且，Python也是开源(open source)运动的一个成功案例。从Python的历史中，我们可以一窥开源开发的理念和成就。</p><h3 id="Python的起源"><a href="#Python的起源" class="headerlink" title="Python的起源"></a>Python的起源</h3><p>Python的作者，Guido von Rossum，确实是荷兰人。1982年，Guido从阿姆斯特丹大学(University of Amsterdam)获得了数学和计算机硕士学位。然而，尽管他算得上是一位数学家，但他更加享受计算机带来的乐趣。用他的话说，尽管拥有数学和计算机双料资质，他总趋向于做计算机相关的工作，并热衷于做任何和编程相关的活儿。</p><p><img src= "/img/loading.gif" data-lazy-src="/2020/12/14/python%E7%AE%80%E5%8F%B2/06100633-c2ce8755002945df846b5dad1dc25cdd.jpg" alt="img"></p><p>在那个时候，他接触并使用过诸如Pascal、C、 Fortran等语言。这些语言的基本设计原则是让机器能更快运行。在80年代，虽然IBM和苹果已经掀起了个人电脑浪潮，但这些个人电脑的配置很低 (在今天看来)。比如早期的Macintosh，只有8MHz的CPU主频和128KB的RAM，一个大的数组就能占满内存。所有的编译器的核心是做优化，以便让程序能够运行。为了增进效率，语言也迫使程序员像计算机一样思考，以便能写出更符合机器口味的程序。在那个时代，程序员恨不得用手榨取计算机每一寸的能力。有人甚至认为C语言的指针是在浪费内存。至于动态类型，内存自动管理，面向对象…… 别想了，那会让你的电脑陷入瘫痪。</p><p>然而，这种思考方式让Guido感到苦恼。Guido知道如何用C语言写出一个功能，但整个编写过程需要耗费大量的时间 (即使他已经准确的知道了如何实现)。他的另一个选择是shell。Bourne Shell作为UNIX系统的解释器(interpreter)已经长期存在。UNIX的管理员们常常用shell去写一些简单的脚本，以进行一些系统维护的工作，比如定期备份、文件系统管理等等。shell可以像胶水一样，将UNIX下的许多功能连接在一起。许多C语言下上百行的程序，在shell下只用几行就可以完成。然而，shell的本质是调用命令。它并不是一个真正的语言。比如说，shell没有数值型的数据类型，加法运算都很复杂。总之，shell不能全面的调动计算机的功能。</p><p>(关于shell，你可以参考<a href="http://www.cnblogs.com/vamei/archive/2012/09/19/2692452.html">Linux架构</a>和<a href="http://www.cnblogs.com/vamei/archive/2012/09/10/2676740.html">Linux命令行与命令</a>)</p><p>Guido希望有一种语言，这种语言能够像C语言那样，能够全面调用计算机的功能接口，又可以像shell那样，可以轻松的编程。ABC语言让Guido看到希望。ABC是由荷兰的CWI (Centrum Wiskunde &amp; Informatica, 数学和计算机研究所)开发的。Guido在CWI工作，并参与到ABC语言的开发。ABC语言以教学为目的。与当时的大部分语言不同，ABC语言的目标是“让用户感觉更好”。ABC语言希望让语言变得容易阅读，容易使用，容易记忆，容易学习，并以此来激发人们学习编程的兴趣。比如下面是一段来自Wikipedia的ABC程序，这个程序用于统计文本中出现的词(word)的总数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HOW TO RETURN words document:</span><br><span class="line">   PUT &#123;&#125; IN collection</span><br><span class="line">   FOR line IN document:</span><br><span class="line">      FOR word IN split line:</span><br><span class="line">         IF word not.in collection:</span><br><span class="line">            INSERT word IN collection</span><br><span class="line">   RETURN collection</span><br></pre></td></tr></table></figure><p>HOW TO用于定义一个函数。一个Python程序员应该很容易理解这段程序。ABC语言使用冒号(:)和缩进来表示程序块(C语言使用{}来表示程序块)。行尾没有分号。for和if结构中也没有括号()。如果将HOW TO改为def，将PUT行改为collection = []，将INSERT行改为collection.append(word)，这就几乎是一个标准的Python函数。上面的函数读起来就像一段自然的文字。</p><p>尽管已经具备了良好的可读性和易用性，ABC语言最终没有流行起来。在当时，ABC语言编译器需要比较高配置的电脑才能运行。而这些电脑的使用者通常精通计算机，他们更多考虑程序的效率，而非它的学习难度。除了硬件上的困难外，ABC语言的设计也存在一些致命的问题：</p><ul><li><strong>可拓展性差</strong>。ABC语言不是模块化语言。如果想在ABC语言中增加功能，比如对图形化的支持，就必须改动很多地方。</li><li><strong>不能直接进行IO</strong>。ABC语言不能直接操作文件系统。尽管你可以通过诸如文本流的方式导入数据，但ABC无法直接读写文件。输入输出的困难对于计算机语言来说是致命的。你能想像一个打不开车门的跑车么？</li><li><strong>过度革新</strong>。ABC用自然语言的方式来表达程序的意义，比如上面程序中的HOW TO (如何)。然而对于程序员来说，他们更习惯用function或者define来定义一个函数。同样，程序员也习惯了用等号(=)来分配变量。这尽管让ABC语言显得特别，但实际上增加了程序员的学习难度 (程序员大都掌握不止一种语言)。</li><li><strong>传播困难</strong>。ABC编译器很大，必须被保存在磁带(tape)上。当时Guido在访问的时候，就必须有一个大磁带来给别人安装ABC编译器。 这样，ABC语言就很难快速传播。</li></ul><p><img src= "/img/loading.gif" data-lazy-src="/2020/12/14/python%E7%AE%80%E5%8F%B2/06111717-51622dbe8fbb4e54ae64f834584180c0.gif" alt="img"></p><p>1989年，为了打发圣诞节假期，Guido开始写Python语言的编译/解释器。Python来自Guido所挚爱的电视剧Monty Python’s Flying Circus (BBC1960-1970年代播放的室内情景幽默剧，以当时的英国生活为素材)。他希望这个新的叫做Python的语言，能实现他的理念(一种C和shell之间，功能全面，易学易用，可拓展的语言)。Guido作为一个语言设计爱好者，已经有过设计语言的(不很成功)的尝试。这一次，也不过是一次纯粹的hacking行为。</p><h3 id="Python的诞生"><a href="#Python的诞生" class="headerlink" title="Python的诞生"></a>Python的诞生</h3><p>1991年，第一个Python编译器(同时也是解释器)诞生。它是用C语言实现的，并能够调用C库(.so文件)。从一出生，Python已经具有了：类(class)，函数(function)，异常处理(exception)，包括表(list)和词典(dictionary)在内的核心数据类型，以及模块(module)为基础的拓展系统。</p><p><img src= "/img/loading.gif" data-lazy-src="/2020/12/14/python%E7%AE%80%E5%8F%B2/06121511-82e43957fefe4c13ac06bd02a5e9d97a.png" alt="img"></p><p>最初的Python logo: 由Guido的兄弟Just von Rossum设计</p><p>Python语法很多来自C，但又受到ABC语言的强烈影响。来自ABC语言的一些规定直到今天还富有争议，比如强制缩进。但这些语法规定让Python容易读。另一方面，Python聪明的选择服从一些惯例(特别是C语言的惯例)。比如使用等号赋值，使用def来定义函数。Guido认为，如果“常识”上确立的东西，没有必要过度纠结。</p><p>Python从一开始就特别在意可拓展性(extensibility)。Python可以在多个层次上拓展。从高层上，你可以引入.py文件。在底层，你可以引用C语言的库。Python程序员可以快速的使用Python写.py文件作为拓展模块。但当性能是考虑的重要因素时，Python程序员可以深入底层，写C程序，编译为.so文件引入到Python中使用。Python就好像是使用钢构建房一样，先规定好大的框架。而程序员可以在此框架下相当自由的拓展或更改。</p><p>最初的Python完全由Guido本人开发。Python得到Guido同事的欢迎。他们迅速的反馈使用意见，并参与到Python的改进。Guido和一些同事构成Python的核心团队。他们将自己大部分的业余时间用于hack Python (也包括工作时间，因为他们将Python用于工作)。随后，Python拓展到CWI之外。Python将许多机器层面上的细节隐藏，交给编译器处理，并凸显出逻辑层面的编程思考。Python程序员可以花更多的时间用于思考程序的逻辑，而不是具体的实现细节 (Guido有一件T恤，写着：人生苦短，我用Python)。这一特征吸引了广大的程序员。Python开始流行。</p><p>我们不得不暂停我们的Python时间，转而看一看这时的计算机概况。1990年代初，个人计算机开始进入普通家庭。Intel发布了486处理器，windows发布window 3.0开始的一系列视窗系统。计算机的性能大大提高。程序员开始关注计算机的易用性 (比如图形化界面)。 <img src= "/img/loading.gif" data-lazy-src="/2020/12/14/python%E7%AE%80%E5%8F%B2/06121437-2bed48b285d746c2a147d1d63cc05483.png" alt="img"></p><p>Windows 3.0</p><p>由于计算机性能的提高，软件的世界也开始随之改变。硬件足以满足许多个人电脑的需要。硬件厂商甚至渴望高需求软件的出现，以带动硬件的更新换代。C++和Java相继流行。C++和Java提供了面向对象的编程范式，以及丰富的对象库。在牺牲了一定的性能的代价下，C++和Java大大提高了程序的产量。语言的易用性被提到一个新的高度。我们还记得，ABC失败的一个重要原因是硬件的性能限制。从这方面说，Python要比ABC幸运许多。</p><p>另一个悄然发生的改变是Internet。1990年代还是个人电脑的时代，windows和Intel挟PC以令天下，盛极一时。尽管Internet为主体的信息革命尚未到来，但许多程序员以及资深计算机用户已经在频繁使用Internet进行交流 (包括email和newsgroup)。Internet让信息交流成本大大下降。一种新的软件开发模式开始流行：开源 (open source)。程序员利用业余时间进行软件开发，并开放源代码。1991年，Linus在comp.os.minix新闻组上发布了Linux内核源代码，吸引大批hacker的加入。Linux和GNU相互合作，最终构成了一个充满活力的开源平台。</p><p>硬件性能不是瓶颈，Python又容易使用，所以许多人开始转向Python。Guido维护了一个maillist，Python用户就通过邮件进行交流。Python用户来自许多领域，有不同的背景，对Python也有不同的需求。Python相当的开放，又容易拓展，所以当用户不满足于现有功能，很容易对Python进行拓展或改造。随后，这些用户将改动发给Guido，并由Guido决定是否将新的特征加入到Python或者标准库中。如果代码能被纳入Python自身或者标准库，这将极大的荣誉。Python自身也因此变得更好。</p><p>(Guido不得不作出许多决定，这也是他被称为<a href="http://en.wikipedia.org/wiki/Benevolent_Dictator_For_Life">Benevolent Dictator For Life</a>的原因)</p><p>Python被称为“Battery Included”，是说它以及其标准库的功能强大。这些是整个社区的贡献。Python的开发者来自不同领域，他们将不同领域的优点带给Python。比如Python标准库中的正则表达(regular expression)是参考Perl，而lambda, map, filter, reduce函数参考Lisp。Python本身的一些功能以及大部分的标准库来自于社区。Python的社区不断扩大，进而拥有了自己的newsgroup，网站(python.org)，以及基金 (Python Software Foundation)。从Python 2.0开始，Python也从maillist的开发方式，转为完全开源的开发方式。社区气氛已经形成，工作被整个社区分担，Python也获得了更加高速的发展。</p><p>(由于Guido享有绝对的仲裁权，所以在Python早期maillist的开发时代，不少爱好者相当担心Guido的生命。他们甚至作出假设：如果Guido挂了的话，Python会怎样。见<a href="http://www.python.org/search/hypermail/python-1994q2/1040.html">If Guido was hit by a bus</a>)</p><p>到今天，Python的框架已经确立。Python语言以对象为核心组织代码(Everything is object)，支持多种编程范式(multi-paradigm)，采用动态类型(dynamic typing)，自动进行内存回收(garbage collection)。Python支持解释运行(interpret)，并能调用C库进行拓展。Python有强大的标准库 (battery included)。由于标准库的体系已经稳定，所以Python的生态系统开始拓展到第三方包。这些包，如Django, web.py, wxpython, numpy, matplotlib,PIL，将Python升级成了物种丰富的热带雨林。</p><p>今天Python已经进入到3.0的时代。由于Python 3.0向后不兼容，所以从2.0到3.0的过渡并不容易。另一方面，Python的性能依然值得改进，Python的运算性能低于C++和Java(见<a href="https://groups.google.com/forum/?fromgroups#!topic/unladen-swallow/TtvEBvVEZD4">Google的讨论</a>)。Python依然是一个在发展中的语言。我期待看到Python的未来。</p><h3 id="Python启示录"><a href="#Python启示录" class="headerlink" title="Python启示录"></a>Python启示录</h3><p>Python崇尚优美、清晰、简单，是一个优秀并广泛使用的语言 (TIOBE语言排行第八，Google的第三大开发语言，Dropbox的基础语言，豆瓣的服务器语言)。这个世界并不缺乏优秀的语言，但Python的发展史作为一个代表，带给我许多启示。</p><p>在Python的开发过程中，社区起到了重要的作用。Guido自认为自己不是全能型的程序员，所以他只负责制订框架。如果问题太复杂，他会选择绕过去，也就是cut the corner。这些问题最终由社区中的其他人解决。社区中的人才是异常丰富的，就连创建网站，筹集基金这样与开发稍远的事情，也有人乐意于处理。如今的项目开发越来越复杂，越来越庞大，合作以及开放的心态成为项目最终成功的关键。</p><p>Python从其他语言中学到了很多，无论是已经进入历史的ABC，还是依然在使用的C和Perl，以及许多没有列出的其他语言。可以说，Python的成功代表了它所有借鉴的语言的成功。同样，Ruby借鉴了Python，它的成功也代表了Python某些方面的成功。每个语言都是混合体，都有它优秀的地方，但也有各种各样的缺陷。同时，一个语言“好与不好”的评判，往往受制于平台、硬件、时代等等外部原因。程序员经历过许多语言之争。我想，为什么不以开放的心态和客观的分析，去区分一下每个语言的具体优点缺点，去区分内部和外部的因素。说不定哪一天发现，我不喜欢的某个语言中，正包含了我所需要的东西。</p><p>无论Python未来的命运如何，Python的历史已经是本很有趣的小说。</p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MacOS安装python3并设置默认</title>
      <link href="2020/12/14/MacOS%E5%AE%89%E8%A3%85python3%E5%B9%B6%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4/"/>
      <url>2020/12/14/MacOS%E5%AE%89%E8%A3%85python3%E5%B9%B6%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="MacOS-安装Python3-8并设置为默认版本"><a href="#MacOS-安装Python3-8并设置为默认版本" class="headerlink" title="MacOS 安装Python3.8并设置为默认版本"></a>MacOS 安装Python3.8并设置为默认版本</h1><h3 id="1、安装Python版本管理工具"><a href="#1、安装Python版本管理工具" class="headerlink" title="1、安装Python版本管理工具"></a>1、安装Python版本管理工具</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install pyenv</span><br></pre></td></tr></table></figure><h3 id="2、添加环境变量（使用bash则添加环境变量到-bashrc-或-profile-或-bash-profile）"><a href="#2、添加环境变量（使用bash则添加环境变量到-bashrc-或-profile-或-bash-profile）" class="headerlink" title="2、添加环境变量（使用bash则添加环境变量到.bashrc 或.profile 或.bash_profile）"></a>2、添加环境变量（使用bash则添加环境变量到.bashrc 或.profile 或.bash_profile）</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=&quot;$(pyenv root)/shims:$PATH&quot;&#x27;</span> &gt;&gt; ~/.zshrc</span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure><h3 id="3、安装Python版本"><a href="#3、安装Python版本" class="headerlink" title="3、安装Python版本"></a>3、安装Python版本</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyenv install <span class="number">3.8</span>.<span class="number">5</span></span><br></pre></td></tr></table></figure><h3 id="4、设置默认版本（以后切换也用这个）"><a href="#4、设置默认版本（以后切换也用这个）" class="headerlink" title="4、设置默认版本（以后切换也用这个）"></a>4、设置默认版本（以后切换也用这个）</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyenv global <span class="number">3.8</span>.<span class="number">5</span></span><br></pre></td></tr></table></figure><h3 id="5、检查Python版本"><a href="#5、检查Python版本" class="headerlink" title="5、检查Python版本"></a>5、检查Python版本</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python <span class="literal">-V</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="/2020/12/14/MacOS%E5%AE%89%E8%A3%85python3%E5%B9%B6%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4/image-20201214171822380.png" alt="image-20201214171822380"></p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> MacOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Coder - 语言快速上手</title>
      <link href="2020/12/14/Coder-%E8%AF%AD%E8%A8%80%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"/>
      <url>2020/12/14/Coder-%E8%AF%AD%E8%A8%80%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Coder-语言快速上手"><a href="#Coder-语言快速上手" class="headerlink" title="Coder - 语言快速上手"></a>Coder - 语言快速上手</h1><p>图灵完备：</p><p>有的语言不是图灵完备的：比如 windows 的 bat 批处理语言、Linux 的 shell、html。只能处理一些自动化的东西</p><p>图灵完备的语言：</p><ul><li>能控制数据、有输入输出、有逻辑处理等。所有图灵机能做的事情、都能用这个语言实现。图灵完备的语言可以互相替代，但是不一样的语言有不一样的优势</li></ul><p>快速学习一门语言：</p><ul><li><p>先了解这个语言的来历、原因、特点、开发环境</p></li><li><p>程序逻辑：变量定义、程序员的约定（驼峰等）、顺序语句、循环分支（看懂其他、自己会写一种就行）、try catch</p></li><li><p>变量加深理解</p><ul><li>强类型弱类型<ul><li>c弱类型（比如打印时需要指定%d、正确使用类型靠程序员自己）</li><li>python强类型（通过 var a = ‘a’，编程语言就知道它是一个字符）</li></ul></li><li>动态类型<ul><li>（声明变量时不用指定类型）比如python、go、swift</li></ul></li><li>静态类型<ul><li>（声明变量时需要指定类型）</li></ul></li><li>值类型 （基本类型）<ul><li>在栈里面直接定义变量（C/C++几乎全是值类型）</li></ul></li><li>引用类型 （封装类型）<ul><li>有的语言所有的变量都是引用（python和js几乎都是引用类型）</li></ul></li><li><strong>值类型和引用类型（影响 == ），但是有的引用类型语言处理了==</strong></li><li>时间和日期（如何处理、保存、计算、格式、方法）</li><li>字符串：<ul><li>理解内存</li><li>可变不可变</li><li>java有字符串常量池（有时候string a == b 是可以的）</li><li>正则表达式（匹配模式）</li></ul></li></ul></li><li><p>容器类型：各种方法、遍历、删除、复制（深浅）、容器序列化（xml、）    可以上项目</p></li><li><p>编程语言的抽象方法、类（继承封装多态）、接口、函数                                  可以写设计模式</p></li><li><p>函数式编程的特性</p></li><li><p>熟练度、生态、包管理工具（pip等）</p></li><li><p>语言的高级功能：比如 java 的高性能并发、网络支持、磁盘管理、携程等       professional</p></li></ul><h1 id="训练任务："><a href="#训练任务：" class="headerlink" title="训练任务："></a>训练任务：</h1><p>完成一个支持消息循环的交互程序：</p><ul><li>运行后不结束</li><li>标准输入输出</li><li>单线程就行</li><li>不需要UI</li><li>文字版RPG小游戏、需要6步以上的剧情</li></ul><p>第二个编程语言：</p><ul><li>精细控制</li><li>对二进制位进行操作</li><li>凯撒密码对数据加密<ul><li>输入加密的移位</li><li>输入加密字符串</li><li>生成加密的字符串（支持重定向）</li><li>还能解密</li></ul></li><li>做一个解密程序（破解凯撒密码、不知道加密的移位）。需要自己判断正确的字符串</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 学习笔记</title>
      <link href="2020/12/13/Git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2020/12/13/Git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Git-学习"><a href="#Git-学习" class="headerlink" title="Git 学习"></a>Git 学习</h1><p>以往的 version control 是记录补丁（RCS），记录新文件和上一个文件的变化（比如新增了一行aaa、删除了一行bbbb），从而保证版本控制，可以回退，但是这样的 version control 只能管理文本，不能管理多媒体等其他文件</p><p>Git 不一样，每一次提交的文件，都是保存完整的文件，Git 版本库拥有每个版本文件的快照（SNAP），切换速度非常快，除了管理代码外，还可以管理多媒体等文件</p><p><strong>集中化的版本控制</strong></p><ul><li><p>让不同系统上的开发者协同工作</p></li><li><p>有一个单一的集中管理的服务器，保存所有文件的修订版本，大家从这台服务器拉取文件，或者提交更新</p></li><li><p>好处：</p></li></ul><ul><li><p>大家都能在一定程度上看到别人在做什么</p></li><li><p>管理一个CVCS比每个客户端都维护一个本地数据库来得容易</p></li><li><p>坏处：</p></li></ul><ul><li>单点故障</li></ul><p><strong>分布式版本控制</strong></p><ul><li>客户端不止提取最新版本的文件快照，而是把代码仓库完整地镜像下来，包括完整的历史记录</li><li>每一次的克隆，其实都是对代码仓库的完整备份</li><li>避免了单点故障，也不需要维护一个中央服务器</li><li>可以在同一项目中和不同的工作小组的人协作</li></ul><p>Git 是一个分布式的版本管理系统</p><h3 id="Git-特点"><a href="#Git-特点" class="headerlink" title="Git 特点"></a>Git 特点</h3><ul><li><strong>直接记录快照</strong>，而非差异比较（每当提交更新或者保存项目状态时，就会对当时的全部文件创建一个快照，并保存这个快照的索引。为了效率，没有修改的文件不会重新存储，而是保留一个链接指向之前存储的文件）</li><li>近乎所有操作都是<strong>本地执行</strong>（快！）没有网络延迟</li><li><strong>保证完整性</strong>，类似区块链，所有数据保存时都计算哈希，并且以哈希来引用！（SHA-1）</li><li><strong>几乎只有添加数据</strong>，（删除其实也是提交一个快照，所以我之前的阿里云密钥现在还在给我发段信！！！）</li><li>三种状态：committed、modified、staged<ul><li>committed：表示数据已经保存在本地数据库中</li><li>modified：表示数据已经修改、但还没有保存到数据库中</li><li>staged：表示对一个已修改的文件的当前版本作了标记，使之包含在下次提交的快照中（类似暂存吧）</li></ul></li><li>三个阶段：工作区、暂存区、Git 目录<ul><li>工作区是项目的某个版本的内容，提取出来放在磁盘上供你修改</li><li>暂存区是一个文件，保存下次将要提交的文件列表信息，一般在.git里面</li><li>Git 仓库目录：.git 文件夹，保存Git 的元数据和对象数据库，克隆就是克隆这个</li><li><img src= "/img/loading.gif" data-lazy-src="/2020/12/13/Git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA0NjQ0Nw==,size_16,color_FFFFFF,t_70-20201213205846326.png" alt="在这里插入图片描述"></li></ul></li></ul><h3 id="Git-基本工作流程"><a href="#Git-基本工作流程" class="headerlink" title="Git 基本工作流程"></a>Git 基本工作流程</h3><p>1、在工作区中修改文件</p><p>2、将想下次提交的更改选择性地暂存（别把配置文件提交！！！）</p><p>3、提交更新，将快照永久性地存储到 Git 目录</p><h3 id="建立Git-仓库"><a href="#建立Git-仓库" class="headerlink" title="建立Git 仓库"></a>建立Git 仓库</h3><ul><li>git init</li><li>git clone ( git clone 会复制所有的版本，然后将最新版本的文件放在工作区)</li></ul><h3 id="Git-add"><a href="#Git-add" class="headerlink" title="Git add"></a>Git add</h3><p>没有被 add 的文件，Git 会忽略它</p><p>所有被 Git add 的文件都会有副本</p><p>git add 是一个多功能命令</p><ul><li>没有被追踪的文件，使用 git add 会让 git 将这个文件加入管理范畴</li><li>已经追踪的文件，使用 git add 会将该文件放到暂存区</li><li>合并时，使用 git add 可以把有冲突的文件标记为已解决</li></ul><p><strong>可以理解为将内容添加到下一次提交中</strong></p><p>当你修改了文件并且 git add 后，保存在暂存区，之后又修改了这个文件</p><p>再次查看 git status</p><p><img src= "/img/loading.gif" data-lazy-src="/2020/12/13/Git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA0NjQ0Nw==,size_16,color_FFFFFF,t_70-20201213205846214.png" alt="在这里插入图片描述"></p><p>可以看到这个文件同时出现在 to be committed 和 not staged</p><p>所以，git add 并不是添加这个文件，而是添加的 SNAP （当时的文件）</p><p>git add 之后的修改并没有添加到暂存区</p><h3 id="Git-ignore"><a href="#Git-ignore" class="headerlink" title="Git ignore"></a>Git ignore</h3><p>我们想要忽略一些编译文件、日志文件等，又不想让他总提示我没追踪，就要git忽略它</p><p>编写一个文件 .gitignore</p><p>文件 .gitignore 的格式规范如下：<br>所有空行或者以 # 开头的行都会被 Git 忽略。<br>可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中。<br>匹配模式可以以（/）开头防止递归。<br>匹配模式可以以（/）结尾指定目录。<br>要忽略指定模式以外的文件或目录，可以在模式前加上叹号（!）取反。</p><p>所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。</p><p>星号（*）匹配零个或多个任意字符；[abc] 匹配任何一个列在方括号中的字符 （这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）；</p><p>问号（?）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符， 表示所有在这两个字符范围内的都可以匹配（比如 [0-9] 表示匹配所有 0 到 9 的数字）。</p><p>使用两个星号（<strong>）表示匹配任意中间目录，比如 a/</strong>/z 可以匹配 a/z 、 a/b/z 或 a/b/c/z 等。</p><p>一个仓库可能只根目录下有一个 .gitignore 文件。 然而，子目录下也可以有额外的 .gitignore 文件。子目录中的 .gitignore 文件中的规则只作用于它所在的目录中。</p><h3 id="Git-diff"><a href="#Git-diff" class="headerlink" title="Git diff"></a>Git diff</h3><p>git status 只能看到文件当前的状态</p><p>使用 git diff 查看：</p><ul><li>当前做的哪些更新尚未暂存？</li><li>有哪些更新已暂存并准备好下次提交？</li></ul><p><strong>只是使用文件补丁的格式给你展示，并不是底层使用文件补丁实现</strong></p><p>git diff 不加参数，比较的是工作目录中<strong>当前文件</strong>和<strong>暂存区快照</strong>的差异</p><p>git diff –staged ，比较的是<strong>暂存区快照</strong>和<strong>最后一次提交的文件</strong>的差异</p><p>经常 git add 之后 git diff 没有信息就是这个原因</p><h3 id="Git-commit"><a href="#Git-commit" class="headerlink" title="Git commit"></a>Git commit</h3><p>只会提交已经 add 的文件作为快照</p><p><strong>git commit -a</strong> ：将所有已经跟踪的文件一并提交（跳过 add 过程）</p><p> 这很方便，但是很有可能会提交一些你不想提交的文件（比如说配置文件）</p><p>git commit –amend : 上次提交漏掉了几个文件（马上git add）、或者提交信息写错了，用这个命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;asd&quot;</span><br><span class="line">git add forgotten_file</span><br><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><p> 最终只会有一个提交</p><h3 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h3><p>从 Git 中移除某个文件，就需要将它移出跟踪文件清单（也是从暂存区移出）</p><p>git rm ： 连带着在工作区也删除了（因为工作区只是 .git 的一个版本快照）</p><p>如果只是在工作目录删除文件，那只会作为一次操作记录，会出现 Changes not staged for commit</p><p>如果要删除之前修改过、已经放到暂存区的文件，需要使用 git rm -f ， 这样的数据不能被 Git 恢复</p><p>删除 git 暂存区的文件 而保留在磁盘： git rm –cached README</p><h3 id="移动文件-（不重要）"><a href="#移动文件-（不重要）" class="headerlink" title="移动文件 （不重要）"></a>移动文件 （不重要）</h3><p>git mv file_from file_to</p><p>git mv 相当于下面三个命令：</p><ul><li>mv file1 file2</li><li>git rm file1</li><li>git add file2</li></ul><h3 id="查看提交历史（重要）"><a href="#查看提交历史（重要）" class="headerlink" title="查看提交历史（重要）"></a>查看提交历史（重要）</h3><p>git log ：</p><ul><li>-n 显示最近 n 次提交</li><li>-p 按照补丁格式显示统计信息</li><li>–stat 显示简略统计信息</li><li>–pretty(很有用)，比如 git log –pretty=oneline ， 将信息展示为一行</li><li><img src= "/img/loading.gif" data-lazy-src="/2020/12/13/Git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA0NjQ0Nw==,size_16,color_FFFFFF,t_70-20201213205847355.png" alt="在这里插入图片描述"></li><li>–pretty=format 还有很多种参数</li></ul><h3 id="撤销操作（重要）"><a href="#撤销操作（重要）" class="headerlink" title="撤销操作（重要）"></a>撤销操作（重要）</h3><p>一、取消暂存的文件：</p><p> 不同的版本不一样，git status 会提示你，怎么取消暂存，我这边是 git restore –staged</p><p> <img src= "/img/loading.gif" data-lazy-src="/2020/12/13/Git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20201210225545985.png" alt="在这里插入图片描述"></p><p>二、撤销对文件对修改：</p><p> 不同的版本不一样，git status 会提示你，怎么取消修改，我这边是 git restore file</p><p> <img src= "/img/loading.gif" data-lazy-src="/2020/12/13/Git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20201210225553980.png" alt="在这里插入图片描述"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">“这是一个危险的命令。 你对那个文件在本地的任何修改都会消失</span><br><span class="line">Git 会用最近提交的版本覆盖掉它。 除非你确实清楚不想要对那个文件的本地修改了，否则请不要使用这个命令。”</span><br></pre></td></tr></table></figure><p>Git 中任何 已提交 的东西几乎总是可以恢复</p><h3 id="远程仓库使用（重要）"><a href="#远程仓库使用（重要）" class="headerlink" title="远程仓库使用（重要）"></a>远程仓库使用（重要）</h3><p>并不一定是 github 或者 gittee 才是远程仓库，任何不在本地的 git 仓库都是远程仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote    &#x2F;&#x2F; 查看已经配置的远程仓库</span><br><span class="line">git remote -v  &#x2F;&#x2F; 查看简写以及URL，会全部列出</span><br></pre></td></tr></table></figure><p><strong>查看远程仓库</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote show &lt;remote&gt; (常用)</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="/2020/12/13/Git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20201210225605488.png" alt="在这里插入图片描述"></p><p>可以看到远程有两个分支、一个main一个master</p><p><strong>添加远程仓库</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add  &quot;shortname&quot;  &quot;url&quot;</span><br></pre></td></tr></table></figure><h3 id="fetch-和-pull（重要）"><a href="#fetch-和-pull（重要）" class="headerlink" title="fetch 和 pull（重要）"></a>fetch 和 pull（重要）</h3><p>git fetch remote</p><p>会访问远程仓库，拉取所有你还没有的数据。拉取完后，会拥有所有分支的引用</p><p>如果 clone 了一个仓库，会自动添加远程仓库，默认为 origin</p><p>git fetch origin 会抓上一次抓取后新的推送的所有工作</p><p><strong>fetch 只会将数据下载到本地仓库，而不会自动合并</strong></p><p><strong>pull 在抓取数据后会尝试直接合并分支</strong> ，git pull 会从最初克隆的服务器上抓取数据并自动尝试合并</p><p>git pull 相当于三条命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git pull&#x2F;fetch &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;  (常用)</span><br><span class="line">git fetch origin master:tmp   &#x2F;&#x2F; 从远程拉一个分支到tmp分支</span><br><span class="line">git merge tmp                 &#x2F;&#x2F; 尝试合并当前分支和tmp分支</span><br><span class="line">git branch -d tmp             &#x2F;&#x2F; 删除tmp分支</span><br></pre></td></tr></table></figure><p>pull 自带的merge 不是很好用（有时候会发生错误），建议还是 git fetch origin master:tmp</p><h3 id="push"><a href="#push" class="headerlink" title="push"></a>push</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br></pre></td></tr></table></figure><p>如果省略远程分支名，则表示将本地分支推送与之存在”追踪关系”的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p><strong>push 前一定要先抓取、消除冲突，再 push。开始工作前也 fetch 一下，在最新的版本上开发</strong></p><h3 id="git-tag"><a href="#git-tag" class="headerlink" title="git tag"></a>git tag</h3><p>git tag 命令查看所有标签 也可以 git tag -l “v1.8*” 列出所有版本号为1.8开头的版本</p><p>git 有两种标签：</p><ul><li>轻量标签：只是某个特定 commit 的引用<ul><li>git tag v1.4</li></ul></li><li>附注标签：是Git 数据库中的一个完整对象，是可以被校验的，包含打标签的人的名字、邮箱、日期、还可以签名验证 、 创建附注标签很简单<ul><li>git tag -a v1.4 -m ”my version 1.4“</li></ul></li></ul><p><strong>标签要另外push才会到远程</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin v1.1</span><br></pre></td></tr></table></figure><p>注意⚠️：tag 是和某个 commit 直接绑定的，而非 branch</p><p>所以你切换分支了，还是可以看到这个 tag（ git show v1.2 )</p><p>所以你推到远程去， 不需要指定分支 而是直接 push origin v1.2</p><h3 id="版本回滚（重要）"><a href="#版本回滚（重要）" class="headerlink" title="版本回滚（重要）"></a>版本回滚（重要）</h3><p>首先通过 git log 或者 git tag 查看 xxx</p><p>git reset –hard xxx ( xxx为某个 commit 的hash 或者某个 tag )</p><p>回滚后看不到 git log 了怎么办？( tag还是能看见 ) git reflog</p><h3 id="git-分支（重要）"><a href="#git-分支（重要）" class="headerlink" title="git 分支（重要）"></a>git 分支（重要）</h3><p>将每个commit 理解为链表的节点、就很容易理解分支了</p><p>HEAD 指针，指向当前所在的本地分支，HEAD指向master，你就在master分支上</p><p>其实所有的 HEAD、master、dev、都是一个指向commit 的指针，只是不同的分支向不同的方向延续</p><p>git switch 切换分支、会改变你的工作目录</p><p><img src= "/img/loading.gif" data-lazy-src="/2020/12/13/Git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA0NjQ0Nw==,size_16,color_FFFFFF,t_70-20201213205847160.png" alt="在这里插入图片描述"></p><p>这种情况如果修改了同一个文件，merge会冲突，这个时候需要手动解决冲突，再 add 、 commit</p><p>git branch 查看（新建）分支（基本命令）</p><p>git branch -d 删除分支</p><p>稳定分支的指针总是在提交历史中落后一大截，而前沿分支的指针往往比较靠前。</p><p><img src= "/img/loading.gif" data-lazy-src="/2020/12/13/Git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20201210225623821.png" alt="在这里插入图片描述"></p><p><strong>删除远程分支</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push origin --delete serverfix</span><br><span class="line">To https:&#x2F;&#x2F;github.com&#x2F;schacon&#x2F;simplegit</span><br></pre></td></tr></table></figure><h3 id="变基"><a href="#变基" class="headerlink" title="变基"></a>变基</h3><p>整合分支最容易的就是 merge 命令，会将两个分支的最新快照、以及二者的最近共同祖先，三者合并，生成新的 commit</p><p>还有一种合并的方法：</p><p>变基： git switch c4 \ git rebase c5 将 C4 的修改 按顺序应用到 C5</p><p><img src= "/img/loading.gif" data-lazy-src="/2020/12/13/Git-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA0NjQ0Nw==,size_16,color_FFFFFF,t_70-20201213205848106.png" alt="在这里插入图片描述"></p><p>提取C4的补丁和修改、在C3的基础上再应用一次</p><p>结果都是一样，但是变基使得提交历史更加整洁</p><p><strong>变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起</strong></p><p>变基的风险：</p><p><strong>如果提交存在于你的仓库之外，而别人可能基于这些提交进行开发，那么不要执行变基</strong></p><h3 id="大厂实际工作中-Git-流程"><a href="#大厂实际工作中-Git-流程" class="headerlink" title="大厂实际工作中 Git 流程"></a>大厂实际工作中 Git 流程</h3><h4 id="master-永远是正常稳定可用的主干分支"><a href="#master-永远是正常稳定可用的主干分支" class="headerlink" title="master 永远是正常稳定可用的主干分支"></a>master 永远是正常稳定可用的主干分支</h4><p>拉出一个 dev 分支，check out from master （master镜像）、类似防火墙</p><p>dev 是所有开发小组的一个共用分支</p><p>但是如果开发人员都向dev 提交，会频繁发生冲突</p><p>所以开发人员各再拉分支</p><p>开发人员要提交到dev之前，小组内先合一下</p><p>测试人员一般从 dev 拉代码测试、没问题了之后，运维把 dev 合并到 master</p><p>从 master 拉一些 Tag 、 Release 发布小更新 、 feature（加一些新的东西、不想影响原来的东西）</p><p>git 5、6成的时间都在解决冲突</p><p>大厂还有专门的 CMO ：配置管理员：解决各种冲突</p>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统原理与程序逻辑训练</title>
      <link href="2020/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E7%A8%8B%E5%BA%8F%E9%80%BB%E8%BE%91%E8%AE%AD%E7%BB%83/"/>
      <url>2020/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E7%A8%8B%E5%BA%8F%E9%80%BB%E8%BE%91%E8%AE%AD%E7%BB%83/</url>
      
        <content type="html"><![CDATA[<h2 id="C语言和操作系统的交互"><a href="#C语言和操作系统的交互" class="headerlink" title="C语言和操作系统的交互"></a>C语言和操作系统的交互</h2><p>C语言的main函数其实就是和操作系统的交互之一，执行程序前，操作系统将程序的二进制可执行代码加载到内存的代码段，同时会把函数名为main的函数作为程序的入口</p><p>Linux 的终端里：</p><p>命令1 &amp;&amp; 命令2</p><p>表示先执行命令1，成功了再执行命令2，如果命令1执行错误则不会执行命令2</p><p><strong>小技巧：可以用 echo $? 查看上一个命令执行的返回值</strong></p><p>而C语言的 int main() 需要有一个int 类型的返回值，这也涉及到和Linux 操作系统的交互</p><p>return 0 不是乱写，而是代表执行成功，程序正常退出，操作系统可以获得main 函数的返回值，通过 echo $? 打印到终端，通过main 函数的返回值，操作系统可以执行不同的逻辑</p><p>C语言的int main(int argv,char * argc[]) ，参数从终端读参数， argv代表参数个数，argc代表参数列表</p><p>这些是操作系统和C语言的交互</p><p>经典程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv [])</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;argc;i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;argc[%d] is %s\n&quot;</span>,i,argv[i]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="/2020/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E7%A8%8B%E5%BA%8F%E9%80%BB%E8%BE%91%E8%AE%AD%E7%BB%83/20201209094206212.png" alt="C语言命令后参数"><br>这个程序可以很直观的看到Linux 在调用C语言程序时，传入的各个参数</p><h2 id="Linux-标准输入输出流、错误流"><a href="#Linux-标准输入输出流、错误流" class="headerlink" title="Linux 标准输入输出流、错误流"></a>Linux 标准输入输出流、错误流</h2><p>stdin stdout stderr</p><p>stdin : 默认是键盘输入，可以通过流的重定向改变输入流</p><p>stdout：默认是显示器输出，也可以重定向到网卡、打印机等</p><p>stderr：错误流</p><p>echo $? 命令可以打印出当前程序的返回值</p><p>流在Linux 系统里被抽象成一个个文件，比如我要往打印机写东西，我就会打开“打印机”这个文件，往里面写东西</p><p>每启动一个包含&lt;stdio.h&gt;的程序，Linux会默认打开 stdin\ stdout\ stderr这三个文件</p><p>比如 :</p><p>printf(“hello”) = fprintf(stdout,“hello”)</p><p>scanf(“%d”,&amp;a) = fscanf(stdin,”%d”,&amp;a)</p><p>fprintf(stderr, “the value must &gt; 0”)</p><p>输出到 stderr 默认也是显示器，我以前在DevC++里输出到stderr， 是输出红色字体，ubuntu的终端好像没有对这个stderr进行特殊标记，只能通过重定向或者 echo $? 来知道确实是发生了错误</p><h2 id="Linux-流的重定向"><a href="#Linux-流的重定向" class="headerlink" title="Linux 流的重定向"></a>Linux 流的重定向</h2><p>0 是标准输入流</p><p>1 是标准输出流</p><p>2 是标准错误流</p><p>./a.out 1&gt;&gt; a.txt 代表对a.out 这个程序的 标准输出流 <strong>重定向</strong> 到 a.txt （1可以默认不写）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="/2020/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E7%A8%8B%E5%BA%8F%E9%80%BB%E8%BE%91%E8%AE%AD%E7%BB%83/20201209094636928.png" alt="hello world 输出流重定向"></p><p><img src= "/img/loading.gif" data-lazy-src="/2020/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E7%A8%8B%E5%BA%8F%E9%80%BB%E8%BE%91%E8%AE%AD%E7%BB%83/20201209094657899.png" alt="ls -l 输出流重定向"><br>可以看到 ls -l 的信息被输出到了文件 b.txt</p><p>其实双箭头和单箭头都可以作为流的重定向，他们有小小的区别</p><p>双箭头不会覆盖文件，会在文件末尾写值</p><p>单箭头则会覆盖文件 ./a.out &gt; a.txt</p><p>&lt; 是标准输入流的重定向<br><img src= "/img/loading.gif" data-lazy-src="/2020/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E7%A8%8B%E5%BA%8F%E9%80%BB%E8%BE%91%E8%AE%AD%E7%BB%83/20201209094812322.png" alt="流的重定向"><br>这三个重定向是可以组合使用的</p><h2 id="Linux-管道"><a href="#Linux-管道" class="headerlink" title="Linux 管道"></a>Linux 管道</h2><p>| 表示管道</p><p>比如： ls /etc/ | grep ab</p><p>表示，将 ls 产生的标准输出流，通过管道，传递给 grep（文本搜索的小程序）的标准输入流</p><p>看看实际操作：<br><img src= "/img/loading.gif" data-lazy-src="/2020/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E7%A8%8B%E5%BA%8F%E9%80%BB%E8%BE%91%E8%AE%AD%E7%BB%83/20201209094843144.png" alt="管道"></p><p>这就是grep 搜索 ls 的结果，找出结果里包含ab的行，输出到标准输出流</p><p><img src= "/img/loading.gif" data-lazy-src="/2020/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E7%A8%8B%E5%BA%8F%E9%80%BB%E8%BE%91%E8%AE%AD%E7%BB%83/20201209094914129.png" alt="找出包含ssh的进程"><br>这就是grep 搜索 ps 的结果，找出结果里包含ssh的进程，输出到标准输出流</p><h5 id="Linux-管道实战"><a href="#Linux-管道实战" class="headerlink" title="Linux 管道实战"></a>Linux 管道实战</h5><p>两个程序，一个输出sum和count，一个通过sum和count求平均值<br><img src= "/img/loading.gif" data-lazy-src="/2020/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E7%A8%8B%E5%BA%8F%E9%80%BB%E8%BE%91%E8%AE%AD%E7%BB%83/20201209100415817.png" alt="Linux管道实战"><br>这两个程序可以直接通过管道相连，让第一个程序的输出进入下一个程序的标准输入<br><img src= "/img/loading.gif" data-lazy-src="/2020/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E7%A8%8B%E5%BA%8F%E9%80%BB%E8%BE%91%E8%AE%AD%E7%BB%83/20201209100432148.png" alt="Linux 管道实战"><br>这次直接输出来的是平均数</p><p>很简单的将两个独立小工具变成更加复杂的工具使用</p><h2 id="Make-学习"><a href="#Make-学习" class="headerlink" title="Make 学习"></a>Make 学习</h2><p>在代码目录下 编写Makefile 文件</p><p># 代表注释</p><p>hello.out: max.o hello.c #这行代表hello.out 需要max.o 和 hello.c 两个文件</p><p> gcc max.o hello.c -o hello.out # 这行必须以table开头，表示实际的gcc命令</p><p>max.o: max.c</p><p> gcc -c max.c<br><img src= "/img/loading.gif" data-lazy-src="/2020/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E7%A8%8B%E5%BA%8F%E9%80%BB%E8%BE%91%E8%AE%AD%E7%BB%83/20201209100743504.png" alt="Make"><br>可以看到我的Makefile 里定义了main.out 和 compute.o 的编译方式，为了调试方便我加了 -g</p><p>现在make 试一下</p><p><img src= "/img/loading.gif" data-lazy-src="/2020/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E7%A8%8B%E5%BA%8F%E9%80%BB%E8%BE%91%E8%AE%AD%E7%BB%83/20201209101228554.png" alt="make"><br>可以看到运行make 后，生成了 main.out compute.o</p><p>运行也是没有问题的<br><img src= "/img/loading.gif" data-lazy-src="/2020/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E7%A8%8B%E5%BA%8F%E9%80%BB%E8%BE%91%E8%AE%AD%E7%BB%83/20201209101343486.png" alt="在这里插入图片描述"></p><h5 id="为什么使用make？"><a href="#为什么使用make？" class="headerlink" title="为什么使用make？"></a>为什么使用make？</h5><p>使用make ，可以让大型程序在小部分代码改动时，不至于全部重新编写</p><p>make 会在Makefile文件中查询需要的文件是否已经有了，如果某部分文件已经存在则会跳过</p><p>make可以大大的节省编译时间（已经编译了不需要重新编译的文件 make 会帮我们跳过），并且Makefile写好各文件的依赖规则，每次编译都能方便程序员直接调用（大型项目自己写gcc不可想象）</p><h2 id="GDB-调试"><a href="#GDB-调试" class="headerlink" title="GDB 调试"></a>GDB 调试</h2><p>先编译时加 -g 参数</p><p>执行 gdb ./main.out</p><p>b 12 标记断点</p><p>l 输出源代码</p><p>n 下一步</p><p>s 单步进入</p><p>p 打印参数数据、地址、函数等</p><p>bt 打印堆栈</p><p>f 进入栈帧</p><h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><p>指向函数的指针变量。 因此“函数指针”本身首先应是指针变量，只不过该指针变量指向函数。这正如用指针变量可指向整型变量、字符型、数组一样，这里是指向函数。C在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。有了指向函数的指针变量后，可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样。</p><p><strong>函数指针有两个用途：调用函数和做函数的参数</strong></p><p>&amp;a 是 得到a的地址</p><p>p 打印一个</p><p>x/3d 打印三个整数</p><p>x/3cb 打印三个字符，b是一个个打印</p><p>回调函数： 在调用一个函数（A函数）时，传入一个函数指针（B函数）作为参数，在A函数运行期间，调用了B函数，那么这就是一个回调。回调函数可以帮助我们实现很多功能</p><p>比如 C语言标准库就为我们实现了快速排序，但是标准库的快速排序它并不知道你要排序的数据是整数、还是字符，甚至是自己定义的结构体，如果是基本类型还好说，但如果是你要对自己定义的结构体排序的话，它并不知道你的结构体是如何进行排序的，这个时候你需要把排序的定义告诉它，即你需要实现一个比较大小的函数，将这个函数作为参数传递给这个标准库函数。这时就可以调用快速排序为你的结构体排序了。</p><p>可以看到有了回调，我们就不需要关心快速排序实现的细节，只需要将我们定义的比较函数传给排序函数，就可以帮助我们实现快速排序。</p><h3 id="操作系统内存管理"><a href="#操作系统内存管理" class="headerlink" title="操作系统内存管理"></a>操作系统内存管理</h3><p><img src= "/img/loading.gif" data-lazy-src="/2020/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E7%A8%8B%E5%BA%8F%E9%80%BB%E8%BE%91%E8%AE%AD%E7%BB%83/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA0NjQ0Nw==,size_16,color_FFFFFF,t_70-20201213205748706.png" alt="操作系统内存管理"></p><p>如图所示：操作系统内核使用的是高地址段，代码段是最低的地址段</p><p>系统内核是不允许被其他进程修改的</p><p>代码段用于保存运行的各个程序的二进制代码</p><p>代码段上面是数据段，用来存储一些全局变量、常量、字符串等</p><p><strong>堆</strong></p><p>数据段上面是堆内存空间，是程序动态申请的内存空间，堆内存比较大，所以程序如果要申请一个大数组什么的，需要调用malloc来申请一片堆内存，堆内存是需要自己去释放的（C语言），Java、go等语言有垃圾回收，不需要程序员来手动回收</p><p><strong>栈</strong></p><p>栈内存用于维护程序运行时环境，每调用一个函数，即会开辟一个新的栈帧（所以在递归调用时，如果递归深度太高会产生巨大的空间复杂度，甚至会出现段错误，核心转储</p><p>每个栈帧都有两个寄存器，一个栈指针寄存器（ESP寄存器，指向栈顶），一个栈的基地址（EBP，指向栈的底部），当然栈是往下长的，EBP的地址会大一些</p><p>每次调用函数即会在栈帧底部保存一个返回值（EBP的值），然后向下新开辟一个栈帧（让EBP往下指，ESP=EBP - 栈大小），(push ebp) (mov ebp, esp)</p><p>然后栈内存记录函数里新定义的各个变量</p><p>函数执行完，返回的时候，mov esp,ebp， 让esp = ebp，再pop ebp，栈顶弹出之前保存的返回值给ebp，这样就回到了上一个栈帧，返回值一般是eax寄存器传递</p><p><strong>程序调用时内存变化</strong></p><p>当操作系统调用执行一个程序时</p><p>将二进制代码（text）放入代码段</p><p>将二进制程序的常量、字符串、全局变量等 放入数据段</p><p>根据代码段，新开辟栈帧用于维护运行时环境，然后cpu根据PC寄存器取指令，执行指令</p><p>终端执行一个 ./main.out 时，函数的调用流程：</p><p>用户在终端敲击回车时，会触发CPU的中断，CPU会保存当前程序的各种寄存器的值，保存栈帧的信息等，放入进程结构体中（内存），操作系统陷入内核态，根据中断向量表和中断编号，找到对应的中断处理函数，发现现在要调用一个程序，于是操作系统将程序二进制可执行代码载入内存的代码段，常量、字符串等载入内存的数据段，为该程序申请时间片，把程序的状态修改为就绪状态，当程序执行时，新开辟（或者从进程结构体中读取之前的）栈帧，执行代码段段二进制代码</p><h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><p>昨天写了一些简单程序设计，打印正方形、空心正方形、等腰三角形、空心菱形、“回”字等</p><p>很久没写过这种程序了。。。刚开始写正方形、三角形都还好，基本上写一遍就过了，不会一直调试，反复测试才能过。后面到了复杂的菱形、“回”字，就需要大量的调试，不断的设计 i、j 的值。让 i、j、num这三个变量组成一个线性函数，设计一个二维的矩形</p><p>但是龙哥让我们把一些重复劳动抽象出来</p><p>比如写一个 printChar(char ch, int n) ; 打印 n 个字符，这个简单的函数就大大地提升了我们的开发效率，让我们不需要将注意力集中在打印几个字符上，我们只需要关注这个图形的规律，第几行先打印几个空格，再打印几个字符即可</p><p>程序设计确实应该是一个不断抽象的过程，如果main 函数里的每一行代码都设计到最后的结果，那以后再来看这份代码又看不懂了。开发的时候应该逻辑更清晰一些，哪几行代码干了什么事，什么函数负责干什么，main 函数里只负责很宏观的事情，实现细节应该抽象出来</p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> c语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020-12-4-学习笔记</title>
      <link href="2020/12/13/2020-12-4-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2020/12/13/2020-12-4-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="处理器的架构不断变化"><a href="#处理器的架构不断变化" class="headerlink" title="处理器的架构不断变化"></a>处理器的架构不断变化</h3><p>X86架构是通用指令集，X86的芯片也是通用芯片</p><p>即这个芯片可以完成各种其他架构芯片的任务，比如作为鼠标芯片、路由器芯片、交换机芯片等</p><p>ARM架构是精简指令集、功耗低、速度快、手机上和苹果M1芯片是ARM架构</p><h3 id="磁盘阵列"><a href="#磁盘阵列" class="headerlink" title="磁盘阵列"></a>磁盘阵列</h3><p>磁盘阵列就是把几个盘组合起来，操作系统读出来是一个盘，但底层是好几个盘</p><p>RAID0: 操作系统对磁盘的读写在两个盘同时进行，数据被分片在两个盘分开存储，读写速度几乎翻倍，容量不变（还是两个盘的大小）</p><p>RAID1:操作系统对磁盘的读写会被镜像一次，相当于另一个盘作为实时备份，这样两个盘变成一个盘，速度不变，容量减半（两个盘读出来只有一个盘的大小），大大的增加了系统的可靠性，数据损坏可以实时恢复，甚至一个盘坏了还能换一个新盘用</p><p>RAID10（不是十）：四个盘变成一个盘，把RAID0和RAID1结合起来</p><h3 id="负载均衡-集群（今天是简单集群，不是分布式集群）"><a href="#负载均衡-集群（今天是简单集群，不是分布式集群）" class="headerlink" title="负载均衡 集群（今天是简单集群，不是分布式集群）"></a>负载均衡 集群（今天是简单集群，不是分布式集群）</h3><p>服务器对外提供服务时，服务器承受的压力随着用户的增加而增加，对服务器的性能要求也会不断上升，提升服务器性能的方式有两种，一种垂直扩容，一种平行扩容</p><h4 id="垂直扩容"><a href="#垂直扩容" class="headerlink" title="垂直扩容"></a>垂直扩容</h4><p>升级CPU、内存等</p><p>好处：简单、最稳定，源代码不需要修改可以直接获得性能提升</p><p>坏处：花钱多，性能提升一倍、业务负载并不能提升一倍（OS对硬件管理开销增加、散热问题等） 同时服务器也不可能无限升级</p><h4 id="平行扩容"><a href="#平行扩容" class="headerlink" title="平行扩容"></a>平行扩容</h4><p>比较麻烦，需要负载均衡</p><p>很多种负载均衡：</p><p>轮询（默认）</p><p>比如：DNS服务器的域名轮询解析 （dns port 缓存用户的session id，让他每次访问统一服务器，就会话维持），但是数据库不能轮询，</p><p>F5负载均衡器，类似NAT一样接一端外网，一端接很多服务器，可用性高，安全性也高，服务器不会被直接攻击，以前比较贵，现在比较便宜了</p><p>LVS负载均衡，linux服务器作为负载均衡</p><p>nginx反向代理（实验），中小企业最常用，C语言实现，可以承载比tomcat 多10几倍的并发请求</p><hr><p>今天先不写了，晚安</p>]]></content>
      
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 安装时的一些坑</title>
      <link href="2020/12/13/Linux-%E5%AE%89%E8%A3%85%E6%97%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/"/>
      <url>2020/12/13/Linux-%E5%AE%89%E8%A3%85%E6%97%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-安装时分区的挂载问题"><a href="#Linux-安装时分区的挂载问题" class="headerlink" title="Linux 安装时分区的挂载问题"></a>Linux 安装时分区的挂载问题</h1><p>Linux 单独挂载 /boot。可以单独更新内核，不怕更新内核丢失数据</p><p>Linux 单独挂载/swap。 Swap分区会在内存不够时，作为虚拟内存使用（但速度很慢），现在内存一般都够了，这个分区是否单独挂载就无所谓了。</p><ul><li>有的古老的应用可能对内存小的机器有优化，有的变量内存需求比较高或者不常用，因而故意取一个很大的地址（让操作系统分配不了这么大的内存地址，从而分配一个虚拟内存），这样的软件如果没有挂载swap分区是有可能跑不起来的</li></ul><p>Linux 单独挂载/var 。 默认tomcat、navicat等应用的日志文件放在这里，单独挂载可以在日志快满时换一个盘来，不至于丢失用户日志数据，并且可以热插拔</p><p>Linux单独挂载/opt 。 可以建议自己写的程序放在/opt，非必须</p><p>Linux单独挂载/usr 。 方便备份软件</p><p>Linux单独挂载/user 。 方便备份用户数据</p><h1 id="BIOS、EFI的区别"><a href="#BIOS、EFI的区别" class="headerlink" title="BIOS、EFI的区别"></a>BIOS、EFI的区别</h1><p>主板使用BIOS还是EFI，对Linux 启动盘的制作有很大影响！</p><p><strong>BIOS 是简单输入输出系统</strong></p><p>是固化到计算机主板上一个ROM上的程序</p><p>当计算机启动时，CPU会加载ROM上的程序</p><p>BIOS 完成机器的自检后，会扫描硬盘，读取硬盘特定位置的操作系统引导程序（操作系统自举程序），引导程序启动操作系统的各程序</p><p>BIOS的功能非常简单，对于操作系统来说，如果主板使用的是BIOS，那么操作系统就必须面对所有的硬件，大到主板显卡，小到鼠标键盘，每次重装系统或者系统升级，都必须手动安装新的驱动</p><p>BIOS 主板的系统，虽然攻击者不知道系统盘中操作系统的密码进不了系统，但是可以通过插入一个U盘进入系统，如果其他磁盘没有其他加密手段的话，攻击者可以轻易窃取其他磁盘的数据</p><p><strong>UEFI全称Unified Extensible Firmware Interface，即“统一的可扩展固件接口”</strong></p><p>UEFI是一个微内核系统，具有操控所有硬件资源的能力</p><p>可以在里面进行各种设置，比如安全设置，用户用U盘启动系统，只能查看自己U盘里的数据，不能对别的盘进行操作</p><p>用户可以进入一个类似shell 的环境，调入执行任何UEFI 程序，可以是自检程序、可以是操作系统引导软件等</p><p>Mac 的UEFI 甚至可以在里面驱动网卡、连接投影仪，在UEFI里的各种操作可以直接投影出去</p><p>UEFI 的u盘启动盘一般可以兼容BIOS，即使主板只有BIOS，也可以 UEFI 引导进系统，但是当你u盘拔了，可能又进不了系统了 ， 所以制作启动盘的时候一定要注意主板型号（大部分服务器主板较老还是用的bios）</p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> bios </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用命令</title>
      <link href="2020/12/13/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>2020/12/13/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-常用命令"><a href="#Linux-常用命令" class="headerlink" title="Linux 常用命令"></a>Linux 常用命令</h1><p>Linux 命令太多，很多命令又有很多参数，不常用的命令是很容易忘记的，做一个备忘<br><a href="https://blog.csdn.net/jiaonizuoren/article/details/79187444">参考的博客链接</a></p><h3 id="显示目录和文件的命令"><a href="#显示目录和文件的命令" class="headerlink" title="显示目录和文件的命令"></a>显示目录和文件的命令</h3><ul><li>Ls：用于查看所有文件夹的命令。</li><li>ls -l，显示详细信息（常用）</li><li>Tree： 以树状图列出目录内容（需要apt install tree)</li><li>Du：显示目录或文件大小 ，查看磁盘信息</li></ul><h3 id="修改目录，文件权限和属主及数组命令"><a href="#修改目录，文件权限和属主及数组命令" class="headerlink" title="修改目录，文件权限和属主及数组命令"></a>修改目录，文件权限和属主及数组命令</h3><ul><li>Chmod：用于改变指定目录或文件的权限命令。</li><li>Chown：用于改变文件拥有属性的命令。</li><li>Chgrp：用于改变文件群组的命令。</li><li>Chattr：用于设置文件具有不可删除和修改权限。</li><li>Lsattr：用于显示文件或目录的隐藏属性。</li></ul><h3 id="创建和删除目录的命令"><a href="#创建和删除目录的命令" class="headerlink" title="创建和删除目录的命令"></a>创建和删除目录的命令</h3><ul><li>Mkdir：用于创建目录</li><li>Rm -f：用于删除目录</li></ul><h3 id="创建和删除，重命名，复制文件的命令"><a href="#创建和删除，重命名，复制文件的命令" class="headerlink" title="创建和删除，重命名，复制文件的命令"></a>创建和删除，重命名，复制文件的命令</h3><ul><li>Touch：创建一个新的文件</li><li>Vi:创建一个新的文件</li><li>Rm：删除文件或目录</li><li>Mv：重命名或移动文件的命令</li><li>Cp：复制命令</li><li>Scp：用于将本地的文件或目录复制到远程服务器</li><li>Wget：用于下载ftp或http服务器文件到本地。</li></ul><p>##显示文件内容的命令</p><ul><li>Cat：用于显示指定文件的全部内容</li><li>More：用分页的形式显示指定文件的内容</li><li>Less：用分页的形式显示指定文件的内容，区别是more和less翻页使用的操作键不同。</li><li>Head：用于显示文件的前n行内容。</li><li>Tail：用于显示文件的后n行内容。</li><li>Tail -f：用于自动刷新的显示文件后n行数据内容。</li></ul><h3 id="查找命令"><a href="#查找命令" class="headerlink" title="查找命令"></a>查找命令</h3><p>Find：查找指定目录或文件的命令。</p><p>Whereis：查找指定的文件源和二进制文件和手册等</p><p>Which：用于查询命令或别名的位置。</p><p>Locate：快速查找系统数据库中指定的内容。</p><p>Grep：在指定的文件或标准输出，标准输入内，查找满足条件的内容。</p><h3 id="关机和重启计算机的命令"><a href="#关机和重启计算机的命令" class="headerlink" title="关机和重启计算机的命令"></a>关机和重启计算机的命令</h3><ul><li><p>Shutdown：-r 关机后立即重启（reboot now 也行）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-k 并不真正的关机，而只是发出警告信息给所有用户</span><br><span class="line">  </span><br><span class="line">-h 关机后不重新启动</span><br></pre></td></tr></table></figure></li><li><p>Poweroff：用于关机和关闭电源</p></li><li><p>Init：改变系统运行级别</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">0级用于关闭系统</span><br><span class="line"></span><br><span class="line">1 级用于单一使用者模式</span><br><span class="line"></span><br><span class="line">2级用来进行多用户使用模式（但不带网络功能）</span><br><span class="line"></span><br><span class="line">3级用来进行多用户使用模式（带网络全功能）</span><br><span class="line"></span><br><span class="line">4级用来进行用户自定义使用模式</span><br><span class="line"></span><br><span class="line">5级表示进入x  windows时的模式</span><br><span class="line"></span><br><span class="line">6级用来重启系统</span><br></pre></td></tr></table></figure></li><li><p>Reboot： 用于计算机重启</p></li><li><p>Halt：用于关闭计算机系统</p></li></ul><h3 id="压缩和打包命令"><a href="#压缩和打包命令" class="headerlink" title="压缩和打包命令"></a>压缩和打包命令</h3><p>Tar：用于多个文件或目录进行打包，但不压缩，同时也用命令进行解包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-A 新增压缩文件到已存在的压缩</span><br><span class="line">-c 建立新的压缩文件</span><br><span class="line">-d 记录文件的差别</span><br><span class="line">-r 添加文件到已经压缩的文件</span><br><span class="line">-u 添加改变了和现有的文件到已经存在的压缩文件</span><br><span class="line">-x 从压缩的文件中提取文件</span><br><span class="line">-t 显示压缩文件的内容</span><br><span class="line">-z 支持gzip解压文件</span><br><span class="line">-j 支持bzip2解压文件</span><br><span class="line">-Z 支持compress解压文件</span><br><span class="line">-v 显示操作过程</span><br><span class="line">-l 文件系统边界设置</span><br><span class="line">-k 保留原有文件不覆盖</span><br><span class="line">-m 保留文件不被覆盖</span><br><span class="line">-W 确认压缩文件的正确性</span><br></pre></td></tr></table></figure><h3 id="用户操作命令"><a href="#用户操作命令" class="headerlink" title="用户操作命令"></a>用户操作命令</h3><p>Linux用户在操作系统可以进行日常管理和维护，涉及到的相关配置文件保存在 /etc/</p><p>Su：切换用户命令</p><p>Sudo：一系统管理员的身份执行命令</p><p>Passwd：用于修改用户的密码</p><p>adduser：用于创建新用户，同时会创建该用户的组，默认用户a属于主组a，还会创建用户的默认home目录等信息</p><p>deluser：用于删除用户，删除用户后home目录并不会主动删除，需要手动再删除</p><h5 id="三个change"><a href="#三个change" class="headerlink" title="三个change"></a>三个change</h5><ul><li>chmod ， 修改文件权限：rwxrwxrwx，比如 chmod 777 a.txt 打开a的所有权限</li><li>chgrp ， 修改文件或文件夹所属的组。 比如chgrp group1 a .txt 让a属于group1</li><li>chown， 修改文件或文件夹的所有者。 比如chown user1 a.txt 让a属于user1</li></ul><h3 id="改变目录和查看当前目录命令"><a href="#改变目录和查看当前目录命令" class="headerlink" title="改变目录和查看当前目录命令"></a>改变目录和查看当前目录命令</h3><p>Cd：进入工作目录</p><p>Cd …：会退到上一级命令</p><p>Pwd：显示当前用户所在工作目录位置</p><h3 id="文件连接命令"><a href="#文件连接命令" class="headerlink" title="文件连接命令"></a>文件连接命令</h3><p>Ln：为源文件创建一个连接，并不将源文件复制一份，即占用的空间很小。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">可以分为软件连接和硬链接。</span><br><span class="line"></span><br><span class="line">软连接：也称为符号连接，即为文件或目录创建一个快捷方式。</span><br></pre></td></tr></table></figure><p>硬链接：给一个文件取多于一个名字，放在不同目录中，方便用户使用。</p><p>Ln命令参数如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-f：在创建连接时，先将与目的对象同名的文件或目录删除。</span><br><span class="line"></span><br><span class="line">-d：允许系统管理者硬链接自己的目录。</span><br><span class="line"></span><br><span class="line">-i：在删除与目的对象同名文件或目录时先询问用户。</span><br><span class="line"></span><br><span class="line">-n：在创建软连接时，将目的对象视为一般的文件。</span><br><span class="line"></span><br><span class="line">-s：创建软连接，即符号连接。</span><br><span class="line"></span><br><span class="line">-v：在连接之前显示文件或目录名。</span><br><span class="line"></span><br><span class="line">-b：将在连接时会被覆盖或删除的文件进行备份。</span><br></pre></td></tr></table></figure><h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><p>Ps：显示瞬间进程的动态</p><p>Date：显示或设定系统的日期与时间。</p><p>Kill： 杀死一些特定的进程</p><p>Logout：退出系统</p><p>Clear：清屏</p><p>Passwd：设置用户密码</p><h3 id="vi编辑器"><a href="#vi编辑器" class="headerlink" title="vi编辑器"></a>vi编辑器</h3><p>首先用vi命令打开一个文件</p><p>末行模式命令：</p><p>:n,m w path/filename 保存指定范围文档（ n表开始行，m表结束行）</p><p>:q! 对文件做过修改后，强制退出</p><p>:q 没有对文件做过修改退出</p><p>Wq或x 保存退出</p><p>dd 删除光标所在行</p><p>: set number 显示行号</p><p>: n 跳转到n行</p><p>: s 替换字符串 : s/test/test2/g /g全局替换 /也可以用%代替</p><p>/ 查找字符串</p><h3 id="网络通信常用的命令"><a href="#网络通信常用的命令" class="headerlink" title="网络通信常用的命令"></a>网络通信常用的命令</h3><p>Arp：网络地址显示及控制</p><p>ftp：文件传输</p><p>Lftp：文件传输</p><p>Mail：发送/接收电子邮件</p><p>Mesg：允许或拒绝其他用户向自己所用的终端发送信息</p><p>Mutt E-mail 管理程序</p><p>Ncftp ：文件传输</p><p>Netstat：显示网络连接.路由表和网络接口信息</p><p>Pine：收发电子邮件，浏览新闻组</p><p>Ping：用于查看网络是否连接通畅</p><p>Ssh：安全模式下远程登陆</p><p>Telnet：远程登录</p><p>Traceroute：显示到达某一主机所经由的路径及所使用的时间。</p><p>Wget：从网路上自动下载文件</p><h3 id="SSH-注意事项"><a href="#SSH-注意事项" class="headerlink" title="SSH 注意事项"></a>SSH 注意事项</h3><ul><li>确保配置好了SSH登陆、再关闭密码登陆，否则有登不上服务器的风险</li><li>员工离职了直接deluser、再删除他的home，他就无法再登陆服务器了</li><li>SSH端口最好配置一下端口，默认的22端口可能会被恶意扫描</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> ubuntu </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装Ubuntu</title>
      <link href="2020/12/13/%E5%AE%89%E8%A3%85Ubuntu/"/>
      <url>2020/12/13/%E5%AE%89%E8%A3%85Ubuntu/</url>
      
        <content type="html"><![CDATA[<p><strong>前言</strong><br>以前我会写一些学习笔记.md，但没有发博客的习惯，现在参加了线下脱产的CSDN技术训练营，要求每个人定期的发自己的学习心得，刚好让我养成发博客的习惯。</p><h1 id="安装Ubuntu"><a href="#安装Ubuntu" class="headerlink" title="安装Ubuntu"></a>安装Ubuntu</h1><p>既然要学习Linux 和C语言编程，那么第一件事当然是装一个Linux系统。<br>我这里选择的是Ubuntu 20.04LTS版本，Ubuntu 的安装有全图形界面、驱动也比较好装（比如对英特尔显卡支持就比很多Linux发行版好），用的是Debian系的软件包管理，软件资源丰富。Ubuntu用的人很多，找各种教程也比较方便。<br>下面是安装Ubuntu的步骤了，安装之前先要空出一个磁盘来，或者分一个盘出来，如果经常用建议50GB往上，我主要就做做实验就只分了20GB</p><h4 id="一、下载镜像"><a href="#一、下载镜像" class="headerlink" title="一、下载镜像"></a>一、下载镜像</h4><p><img src= "/img/loading.gif" data-lazy-src="/2020/12/13/%E5%AE%89%E8%A3%85Ubuntu/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA0NjQ0Nw==,size_16,color_FFFFFF,t_70.png" alt="下载Ubuntu镜像"></p><h4 id="二、下载启动盘制作工具"><a href="#二、下载启动盘制作工具" class="headerlink" title="二、下载启动盘制作工具"></a>二、下载启动盘制作工具</h4><p><img src= "/img/loading.gif" data-lazy-src="/2020/12/13/%E5%AE%89%E8%A3%85Ubuntu/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA0NjQ0Nw==,size_16,color_FFFFFF,t_70-20201213205346071.png" alt="下载启动盘制作工具"><br>Rufus 可以方便地制作一个启动盘<br>因为我之前做过kubuntu的启动盘所以我的u盘名字叫Kubuntu…听说要装ubuntu20.04LTS，我又把kubuntu格了…</p><h4 id="三、制作启动盘"><a href="#三、制作启动盘" class="headerlink" title="三、制作启动盘"></a>三、制作启动盘</h4><p><img src= "/img/loading.gif" data-lazy-src="/2020/12/13/%E5%AE%89%E8%A3%85Ubuntu/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA0NjQ0Nw==,size_16,color_FFFFFF,t_70-20201213205346216.png" alt="制作启动盘"><br>导入之前下好的Ubuntu镜像文件，系统类型选择UEFI（后面会介绍EFI和BIOS区别），文件系统选默认的FAT32就好（FAT32可以同时被Windows和MacOS识别，兼容性不错，其他的默认就好</p><h4 id="四、重启电脑"><a href="#四、重启电脑" class="headerlink" title="四、重启电脑"></a>四、重启电脑</h4><p>插入U盘，重启电脑，按住F2进入BIOS</p><h4 id="五、进入bios"><a href="#五、进入bios" class="headerlink" title="五、进入bios"></a>五、进入bios</h4><p><img src= "/img/loading.gif" data-lazy-src="/2020/12/13/%E5%AE%89%E8%A3%85Ubuntu/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA0NjQ0Nw==,size_16,color_FFFFFF,t_70-20201213205352699.png" alt="进入BIOS"><br>直接在Exit里选择UEFI 回车即可从U盘启动</p><h4 id="六、加载启动盘"><a href="#六、加载启动盘" class="headerlink" title="六、加载启动盘"></a>六、加载启动盘</h4><p><img src= "/img/loading.gif" data-lazy-src="/2020/12/13/%E5%AE%89%E8%A3%85Ubuntu/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA0NjQ0Nw==,size_16,color_FFFFFF,t_70-20201213205431118.png" alt="加载启动盘"><br>系统在检查U盘里的数据</p><h4 id="七、选择安装路径"><a href="#七、选择安装路径" class="headerlink" title="七、选择安装路径"></a>七、选择安装路径</h4><p><img src= "/img/loading.gif" data-lazy-src="/2020/12/13/%E5%AE%89%E8%A3%85Ubuntu/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA0NjQ0Nw==,size_16,color_FFFFFF,t_70-20201213205408169.png" alt="选择安装路径"><br>请原谅我的手机拍电脑屏幕…<br>我直接将根目录/ 挂载到我之前分出来的20GB新盘里去了，格式化选择EXT4文件系统（现在Linux一般都用EXT4）<br>我是图省事，只挂载了根目录/ ，其他目录都是默认的，后面会介绍各个目录分别挂载的好处，<strong>我只是图方便</strong>，大家看看就好，没必要照着我的弄</p><p>这一步完了之后都是自动化安装了<br><img src= "/img/loading.gif" data-lazy-src="/2020/12/13/%E5%AE%89%E8%A3%85Ubuntu/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA0NjQ0Nw==,size_16,color_FFFFFF,t_70-20201213205349242.png" alt="自动化安装"></p><h4 id="八、安装成功"><a href="#八、安装成功" class="headerlink" title="八、安装成功"></a>八、安装成功</h4><p>uname -a 查看ubuntu的版本信息<br><img src= "/img/loading.gif" data-lazy-src="/2020/12/13/%E5%AE%89%E8%A3%85Ubuntu/20201207220818119.png" alt="安装成功"></p><h4 id="九、切换国内源"><a href="#九、切换国内源" class="headerlink" title="九、切换国内源"></a>九、切换国内源</h4><p>在使用Ubuntu的时候，我们会经常用到 apt-get install 命令，这个命令就是从你的源地址下载互联网软件包到本机并安装，Ubuntu官方的源速度很慢，经常有一个软件包下几小时的情况，所以我们得换个源</p><p>Ubuntu20.04自带了换源GUI</p><p>打开<strong>软件和更新</strong>，进入设置-Ubuntu软件-下载自<br>这里可以选择下载服务器，我选择的阿里云的源，确定后会自动让你更新源，相当于执行apt-get update，输密码即可</p><h4 id="十、驱动N卡"><a href="#十、驱动N卡" class="headerlink" title="十、驱动N卡"></a>十、驱动N卡</h4><p>Ubuntu 默认是用核显的，我们想要使用独显还得装一下驱动<br><img src= "/img/loading.gif" data-lazy-src="/2020/12/13/%E5%AE%89%E8%A3%85Ubuntu/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA0NjQ0Nw==,size_16,color_FFFFFF,t_70-20201213205346572.png" alt="驱动N卡"><br>ubuntu 对n卡支持很好，直接在<strong>软件和更新-附加驱动</strong>上点两下就装好了<br>deepin还要加油，装个n卡驱动死活装不上</p><p>终端执行nvidia-smi 查看n卡信息：<br><img src= "/img/loading.gif" data-lazy-src="/2020/12/13/%E5%AE%89%E8%A3%85Ubuntu/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA0NjQ0Nw==,size_16,color_FFFFFF,t_70-20201213205350733.png" alt="nvidia-smi"><br>可以看到n卡被正确驱动了</p><h4 id="安装deepin-wine"><a href="#安装deepin-wine" class="headerlink" title="安装deepin-wine"></a>安装deepin-wine</h4><p>Linux 的软件生态对比Windows 还是差了点<br>比如QQ for Linux 还是09年的界面，微信、钉钉就压根没有官方的Linux 支持版本（QQ微信的Web端还经常不让你用），但是2020年了，谁能摆脱这几个软件呢，想在Linux 里跑Windows 软件，我们需要装一个deepin-wine<br>wget -O- <a href="https://deepin-wine.i-m.dev/setup.sh">https://deepin-wine.i-m.dev/setup.sh</a> | sh<br>sudo apt-get install deepin.com.wechat<br>sudo apt-get install deepin.com.qq.im<br><img src= "/img/loading.gif" data-lazy-src="/2020/12/13/%E5%AE%89%E8%A3%85Ubuntu/202012072219355.png" alt="QQ微信"><br>可惜，ubuntu对wine支持不好，最小化有bug，没有deepin支持得好</p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>修复不显示图片</title>
      <link href="2020/12/13/%E4%BF%AE%E5%A4%8D%E4%B8%8D%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87/"/>
      <url>2020/12/13/%E4%BF%AE%E5%A4%8D%E4%B8%8D%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo-图片显示问题及使用typora设置图片路径"><a href="#hexo-图片显示问题及使用typora设置图片路径" class="headerlink" title="hexo 图片显示问题及使用typora设置图片路径"></a>hexo 图片显示问题及使用typora设置图片路径</h1><p>使用<code>hexo</code>生成静态资源后,由于<code>url</code>的问题会出现图片加载的问题,现在网上的文章及官方的解决方案大概分为三种:</p><ol><li>将图片放入<code>source/images</code>目录下,每次<code>generate</code>都会生成图片,在使用相对或绝对路径进行引用</li><li> 配置<code>hexo</code>的<code>_config.yml</code>文件, 将 <code>post_asset_folder</code> 设置为<code>true</code>, 这样每次new 生成一个文章时都会同步生成一个同名的文件夹,然后设置相对或绝对路径. </li><li> 使用<code>hexo</code>官方的解决方案,使用模版变量, <code>&#123;% asset_img slug [title] %&#125; </code> </li></ol><p>但是在配置过程中发现这三种方式都多多少少存在一些问题,前两中首页跟内容页会有一个加载失败的问题,而第三种则失去了<code>markdown</code>的意义.</p><p>解决方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">设置post_asset_folder  为 true, 安装插件 asset-image</span><br><span class="line">npm install https:&#x2F;&#x2F;github.com&#x2F;CodeFalling&#x2F;hexo-asset-image</span><br><span class="line">设置图片为相对路径</span><br><span class="line">hexo clean &amp;&amp; hexo generate &amp;&amp; hexo s 运行查看</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="/2020/12/13/%E4%BF%AE%E5%A4%8D%E4%B8%8D%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87/image-20201213204449791.png" alt="image-20201213204449791"></p><p><img src= "/img/loading.gif" data-lazy-src="/2020/12/13/%E4%BF%AE%E5%A4%8D%E4%B8%8D%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87/image-20201213204508726.png" alt="image-20201213204508726"></p><p>Nice！</p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>first blog</title>
      <link href="2020/12/12/first-blog/"/>
      <url>2020/12/12/first-blog/</url>
      
        <content type="html"><![CDATA[<h1 id="这是我的第一个博客"><a href="#这是我的第一个博客" class="headerlink" title="这是我的第一个博客"></a>这是我的第一个博客</h1><p>😁</p><p>😄</p><p>😂</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
